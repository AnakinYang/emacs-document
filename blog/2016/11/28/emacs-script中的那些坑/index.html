<!DOCTYPE html>
<html lang="en">
<head>
  <title>emacs-script中的那些坑 - EMACS-DOCUMENT</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <meta name="author" content="lujun9972" />
  <!-- <link rel="stylesheet" href="../../../../../media/css/main.css" type="text/css"/>
       <link rel="stylesheet" href="../../../../../media/css/comment.css" type="text/css"/> -->
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/dark.css'>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
</head>

  <body><div class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="../../../../../">EMACS-DOCUMENT</a></h1>
    <p>=============&gt;集思广益</p>
    <nav class="site-nav">
      <ul class="trigger">
        <li><a href="../../../../../years/">Years</a></li>
        <li><a href="../../../../../authors/">Authors</a></li>
        <li><a href="../../../../../tags/">Tags</a></li>
        <li><a href="../../../../../about/">About</a></li>
        <li><a href="https://github.com/lujun9972/emacs-document">Github</a></li>
        <li><a href="../../../../../rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="https://www.bing.com/search">
      <input type="text" class="field" name="q" id="s" placeholder="Search">
      <input type="hidden" name="as_sitesearch" value="lujun9972.github.io/emacs-document">
    </form>
  </header>
</div>

<div>
<div class="post">
<h1 class="title">emacs-script中的那些坑</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgaedd26d">Making Emacs Lisp scripts executable</a></li>
<li><a href="#org3b806f9">Inhibiting site-start</a></li>
<li><a href="#org66d402c">Processing command line arguments</a></li>
<li><a href="#orgc2f3fe0">Standard output and input</a></li>
<li><a href="#orgebd807e">Debugging</a></li>
<li><a href="#org1b3da16">Keep your hands clean</a></li>
</ul>
</div>
</div>
<p>
Emacs可不仅仅是一个编辑器而已, 它还是一个完整的Emacs Lisp解释器及其运行环境. 我们不仅仅可以用EmacsLisp来扩展和定制Emacs,还能编写完整的程序应用呢.
Nic Ferrier的 <a href="https://github.com/nicferrier/elnode">elnode</a> 服务器就是一个最好的例子. 我们完全可以用EmacsLisp写一些规模较小的shell脚本与工具.
</p>

<p>
不过你真的开始写就会发现, 用EmacsLisp编程要比想想中复杂一些. 几十年来Emacs都是作为交互式的应用程序来用的,这给Emacs和EmacsLisp留下了深深的烙印,也使得用它来编写独立的非交互式脚本变得格外的困难.
</p>

<div id="outline-container-orgaedd26d" class="outline-2">
<h2 id="orgaedd26d">Making Emacs Lisp scripts executable</h2>
<div class="outline-text-2" id="text-orgaedd26d">
<p>
如今Emacs提供了一个很方便的 <code>--script</code> 选项来加载并执行指定的文件^<a href="http://www.lunaryorn.com/posts/emacs-script-pitfalls.html#fn:1">1</a>, 然而如何分配一个合适的shebang呢?
新手常常会这么做:
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #2aa1ae; background-color: #292e34;">#</span><span style="color: #2aa1ae; background-color: #292e34;">!/usr/bin/</span><span style="color: #4f97d7; font-weight: bold;">emacs</span><span style="color: #2aa1ae; background-color: #292e34;"> --script</span>
<span style="color: #4f97d7;">(</span>message <span style="color: #2d9574;">"Hello world"</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
然而Emacs并不是/bin/sh, 它的位置在不同系统上是不一样的. 甚至可能有多个不同版本的Emacs分布于不同的地方.
举个例子,在OSX上 <code>/usr/bin/emacs</code> 指向的是早已过时的Emacs 22,而实际使用的Emacs一般是通过Homebrew来安装的,它的路径是 <code>/usr/local/bin/emacs</code>.
</p>

<p>
通常我们会使用 <code>/usr/bin/env</code> 来解决这个问题:
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #2aa1ae; background-color: #292e34;">#</span><span style="color: #2aa1ae; background-color: #292e34;">!/usr/bin/</span><span style="color: #4f97d7; font-weight: bold;">env</span><span style="color: #2aa1ae; background-color: #292e34;"> emacs --script</span>
<span style="color: #4f97d7;">(</span>message <span style="color: #2d9574;">"Hello world"</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
但这又带来了另一个可移植性问题: Linux并不会分割 shebang 后面的参数,因此会将 <code>emacs --script</code> 作为单个参数传递给 <code>/usr/bin/env</code>, 因此这个方法不管用.
</p>

<p>
正确的做法需要花一些小伎俩^<a href="http://www.lunaryorn.com/posts/emacs-script-pitfalls.html#fn:2">2</a>:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span style="color: #2d9574;">":"</span><span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">exec emacs --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>
<span style="color: #4f97d7;">(</span>message <span style="color: #2d9574;">"Hello world"</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
这样就可以将EmacsLisp代码嵌入到POSIX shell脚本中了,该脚本会以合适的参数来调用emacs.
第二行中的分号可以为Emacs隐藏 <code>exec</code> 语句, 而对shell来说,无意义的冒号语句则将第二行变成一个合法的连续执行两条命令的语句.
而且这个冒号被引用起来了使之成为EmacsLisp中合法的字符串字面量.
</p>

<p>
第二行后面的文件本地变量让Emacs使用EmacsLisp Mode来处理该脚本,而不用管shebang的存在(译者注:一般Emacs会将带shebang的脚本看成是shell脚本,因此可能会进入sh-mode),同时还启用了静态绑定.
</p>

<p>
这个小花招对于任何遵守POSIX的shell都管用. 更棒的是,我们现在可以传递任意参数给emacs可执行文件了,这使得我们可以摆脱 <code>--script</code> 带来的一些小麻烦.
</p>
</div>
</div>

<div id="outline-container-org3b806f9" class="outline-2">
<h2 id="org3b806f9">Inhibiting site-start</h2>
<div class="outline-text-2" id="text-org3b806f9">
<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Initial-Options.html#index-g_t_002d_002dscript-4535d">–script</a> 选项基本上只是 <code>--batch -l</code> 的简写形式,也就是进入批处理模式并加载指定文件的意思. 
批处理模式主要使得Emacs不再创建frame,并且在处理完所有命令行参数(也包括执行我们的脚本这一步)后自动退出.
此外, <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Initial-Options.html#index-g_t_002d_002dbatch-4534">–batch</a> 还会禁用用户的初始化文件. 不过Emacs依然会加载global site初始化文件:
</p>

<blockquote>
<p>
--batch implies -q (do not load an initialization file), but site-start.el
is loaded nonetheless. It also causes Emacs to exit after processing all
the command options. In addition, it disables auto-saving except in
buffers for which auto-saving is explicitly requested.
</p>
</blockquote>

<p>
global site的初始化过程要做好多乱七八糟的事情,它会设置好全局安装好的package,在最坏的情况下会严重推迟Emacs的启动时间.
何况,在我们的脚本运行前加载那么多的packages也不太好.
</p>

<p>
我们可以通过添加 <code>--quick</code> 选项来明确禁止global site的初始化过程, 它能给我们一个纯净的不带任何初始化过程的Emacs.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span style="color: #2d9574;">":"</span><span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">exec emacs --quick --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>
<span style="color: #4f97d7;">(</span>message <span style="color: #2d9574;">"Hello world"</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
如果你确实需要加载global site初始化过程,你可以在代码中明确加载<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Init-File.html#index-site_002drun_002dfile">site-run-file</a>:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #4f97d7;">(</span>load site-run-file 'no-error 'no-message<span style="color: #4f97d7;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org66d402c" class="outline-2">
<h2 id="org66d402c">Processing command line arguments</h2>
<div class="outline-text-2" id="text-org66d402c">
<p>
Emacs使用 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Command_002dLine-Arguments.html#index-command_002dline_002dargs_002dleft">command-line-args-left</a> 来持有命令行参数,它其实也是argv的别名^<a href="http://www.lunaryorn.com/posts/emacs-script-pitfalls.html#fn:3">3</a>:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span style="color: #2d9574;">":"</span><span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">exec emacs --quick --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>

<span style="color: #4f97d7;">(</span>message <span style="color: #2d9574;">"Hello: %S"</span> argv<span style="color: #4f97d7;">)</span>
</pre>
</div>

<pre class="example">
$ ./hello.el 'John Doe'
Hello: ("John Doe")
</pre>

<p>
然而当传递选项时却遇到了些问题:
</p>

<pre class="example">
$ ./hello.el --greeting 'Good morning %s!' 'John Doe'
Hello: ("--greeting" "Good morning %s!" "John Doe")
Unknown option `--greeting'
</pre>

<p>
Emacs尝试自己去解释 <code>--greeting</code>,当然会提示无此选项了. 那么我们该怎样让Emacs不要去解释我们传递给脚本的选项呢?
</p>

<p>
startup.el的源代码,更准确地说是函数 <code>command-line-1</code> 的源代码指出了解决方案: Emacs会立即按照各参数出现的顺序来处理所有传递给它的命令行参数.
每处理完一个参数之后就将它从 <code>argv</code> 中删除掉,因此 <code>argv</code> 也有一个别名叫做 <code>command-line-args-left</code>.
</p>

<p>
由于 <code>command-line-args-left</code> 或者说 <code>argv</code> 是一个全局变量,我们可以在脚本退出前将所有 <code>argv</code> 中未处理的参数给全删掉:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span style="color: #2d9574;">":"</span><span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">exec emacs --quick --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>

<span style="color: #4f97d7;">(</span>message <span style="color: #2d9574;">"Hello: %S"</span> argv<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">setq</span> argv nil<span style="color: #4f97d7;">)</span>
</pre>
</div>

<pre class="example">
$ ./hello.el --greeting 'Good morning %s!' 'John Doe'
Hello: ("--greeting" "Good morning %s!" "John Doe")
</pre>

<p>
另外, 我们也可以强制让Emacs提前退出,这种方法也不错:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span style="color: #2d9574;">":"</span><span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">exec emacs --quick --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>

<span style="color: #4f97d7;">(</span>message <span style="color: #2d9574;">"Hello: %S"</span> argv<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>kill-emacs <span style="color: #a45bad;">0</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
然而正如一名读者<a href="https://github.com/lunaryorn/blog/issues/15">指出的</a>, 这是这样还不够. Emacs现在虽然会忽略掉我们自定义的那些惨了,然而它还是会处理掉那些它自己支持的那些参数.
也就是说我们的脚本不可能支持 <code>--version</code> 参数了:
</p>

<pre class="example">
$ ./hello.el --version
GNU Emacs 25.0.50.1
Copyright (C) 2014 Free Software Foundation, Inc.
GNU Emacs comes with ABSOLUTELY NO WARRANTY.
You may redistribute copies of Emacs
under the terms of the GNU General Public License.
For more information about these matters, see the file named COPYING.
</pre>

<p>
Emacs会输出自己的版本信息,并且在我们的脚本看到 <code>--version</code> 参数之前就退出了.
我们需要使用标准的双破折号来将传递给Emacs的选项从脚本参数中分离出来,这样以来我们的脚本就能处理那些Emacs支持的参数了^<a href="http://www.lunaryorn.com/posts/emacs-script-pitfalls.html#fn:4">4</a>:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span style="color: #2d9574;">":"</span><span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>

<span style="color: #4f97d7;">(</span>message <span style="color: #2d9574;">"Hello: %S"</span> argv<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>kill-emacs <span style="color: #a45bad;">0</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
现在我们可以传递 <code>--version</code> 参数给脚本了,不过美中不足的是,双破折号也会作为参数传递到脚本中去,所以我们要记得把第一个参数舍去:
</p>

<pre class="example">
$ ./hello.el --version
Hello: ("--" "--version")
</pre>

<p>
一般来说都会在一个循环中处理所有参数,每处理完一个参数就弹出这个参数. 不过在最开始的时候记得要弹出那个双破折号参数哦:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span style="color: #2d9574;">":"</span><span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">let</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>greeting <span style="color: #2d9574;">"Hello %s!"</span><span style="color: #2d9574;">)</span>
      options-done
      names<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">pop</span> argv<span style="color: #bc6ec5;">)</span>  <span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">Remove the -- separator</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">while</span> argv
    <span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">let</span> <span style="color: #67b11d;">(</span><span style="color: #b1951d;">(</span>option <span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">pop</span> argv<span style="color: #4f97d7;">)</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span>
      <span style="color: #67b11d;">(</span><span style="color: #4f97d7; font-weight: bold;">cond</span>
       <span style="color: #b1951d;">(</span>options-done <span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">push</span> option names<span style="color: #4f97d7;">)</span><span style="color: #b1951d;">)</span>
       <span style="color: #2aa1ae; background-color: #292e34;">;; </span><span style="color: #2aa1ae; background-color: #292e34;">Don't process options after "--"</span>
       <span style="color: #b1951d;">(</span><span style="color: #4f97d7;">(</span>string= option <span style="color: #2d9574;">"--"</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">setq</span> options-done t<span style="color: #4f97d7;">)</span><span style="color: #b1951d;">)</span>
       <span style="color: #b1951d;">(</span><span style="color: #4f97d7;">(</span>string= option <span style="color: #2d9574;">"--greeting"</span><span style="color: #4f97d7;">)</span>
        <span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">setq</span> greeting <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">pop</span> argv<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span><span style="color: #b1951d;">)</span>
       <span style="color: #2aa1ae; background-color: #292e34;">;; </span><span style="color: #2aa1ae; background-color: #292e34;">--greeting=Foo</span>
       <span style="color: #b1951d;">(</span><span style="color: #4f97d7;">(</span>string-match <span style="color: #2d9574;">"\\`--greeting=</span><span style="color: #2d9574; font-weight: bold;">\\</span><span style="color: #2d9574; font-weight: bold;">(</span><span style="color: #2d9574; font-weight: bold;">\\</span><span style="color: #2d9574; font-weight: bold;">(?:</span><span style="color: #2d9574;">.</span><span style="color: #2d9574; font-weight: bold;">\\</span><span style="color: #2d9574; font-weight: bold;">|</span><span style="color: #2d9574;">\n</span><span style="color: #2d9574; font-weight: bold;">\\</span><span style="color: #2d9574; font-weight: bold;">)</span><span style="color: #2d9574;">*</span><span style="color: #2d9574; font-weight: bold;">\\</span><span style="color: #2d9574; font-weight: bold;">)</span><span style="color: #2d9574;">\\'"</span> option<span style="color: #4f97d7;">)</span>
        <span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">setq</span> greeting <span style="color: #bc6ec5;">(</span>match-string <span style="color: #a45bad;">1</span> option<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span><span style="color: #b1951d;">)</span>
       <span style="color: #b1951d;">(</span><span style="color: #4f97d7;">(</span>string-prefix-p <span style="color: #2d9574;">"--"</span> option<span style="color: #4f97d7;">)</span>
        <span style="color: #4f97d7;">(</span>message <span style="color: #2d9574;">"Unknown option: %s"</span> option<span style="color: #4f97d7;">)</span>
        <span style="color: #4f97d7;">(</span>kill-emacs <span style="color: #a45bad;">1</span><span style="color: #4f97d7;">)</span><span style="color: #b1951d;">)</span>
       <span style="color: #b1951d;">(</span>t <span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">push</span> option names<span style="color: #4f97d7;">)</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span>

      <span style="color: #67b11d;">(</span><span style="color: #4f97d7; font-weight: bold;">unless</span> <span style="color: #b1951d;">(</span>&gt; <span style="color: #4f97d7;">(</span>length greeting<span style="color: #4f97d7;">)</span> <span style="color: #a45bad;">0</span><span style="color: #b1951d;">)</span>
        <span style="color: #b1951d;">(</span>message <span style="color: #2d9574;">"Missing argument for --greeting!"</span><span style="color: #b1951d;">)</span>
        <span style="color: #b1951d;">(</span>kill-emacs <span style="color: #a45bad;">1</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>

  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">unless</span> names
    <span style="color: #2d9574;">(</span>message <span style="color: #2d9574;">"Missing names!"</span><span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span>kill-emacs <span style="color: #a45bad;">1</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>

  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">dolist</span> <span style="color: #2d9574;">(</span>name <span style="color: #67b11d;">(</span>nreverse names<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span>message greeting name<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>

  <span style="color: #bc6ec5;">(</span>kill-emacs <span style="color: #a45bad;">0</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
现在Emacs不会再干扰我们自己的选项和参数了:
</p>

<pre class="example">
$ ./hello.el --greeting='Hello %s' 'John Doe' 'Donald Duck'
Hello John Doe
Hello Donald Duck
</pre>
</div>
</div>

<div id="outline-container-orgc2f3fe0" class="outline-2">
<h2 id="orgc2f3fe0">Standard output and input</h2>
<div class="outline-text-2" id="text-orgc2f3fe0">
<p>
在前面的例子中,我们在脚本中用 <code>message</code> 来输出文本. 这其实有点问题,我们不能正常地重定向输出了:
</p>

<pre class="example">
$ ./hello.el 'John Doe' 'Donald Duck' &gt; /dev/null
Hello John Doe!
Hello Donald Duck!
</pre>

<p>
<code>message</code> 将内容写到stderr中, 然而一个合格的脚本应该将内容通过stdout输出.
要想将内容输出到stdout,你需要使用 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Output-Functions.html#index-print">print</a>, <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Output-Functions.html#index-prin1">prin1</a>, <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Output-Functions.html#index-princ">princ</a> 等这一系列的函数. 所有这些函数都会将Lisp对象以打印的表示方法输出,但是不同的函数有不同的格式化方法与引用方式.
</p>

<p>
如果只是简单的输出, 可以选择 <code>princ</code>, 它输出时没有任何格式以及引用. 而且一般来说,不带引用的字符串的"打印表示方式"就是字符串本身,因此我们可以使用该函数来将一系列的名字输出到stdout中:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span style="color: #2d9574;">":"</span><span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">exec emacs --quick --script "$0" "$@" # -*-emacs-lisp-*-</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">while</span> argv
  <span style="color: #bc6ec5;">(</span>princ <span style="color: #2d9574;">(</span>format <span style="color: #2d9574;">"Hello %s!"</span> <span style="color: #67b11d;">(</span><span style="color: #4f97d7; font-weight: bold;">pop</span> argv<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>terpri<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span>kill-emacs <span style="color: #a45bad;">0</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
与 <code>message</code> 不同的是, <code>princ</code> 并不接受一个格式化字符串, 因此我们需要自己来调用 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Formatting-Strings.html#index-format">format</a> 函数. <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Output-Functions.html#index-terpri">terpri</a> 则是一个只输出换行的小工具. 
脚本输出的结果正是我们想要的,而且我们现在可以重定向输出了:
</p>

<p>
$ ./hello.el 'John Doe' 'Donald Duck'
Hello John Doe!
Hello Donald Duck!
$ ./hello.el 'John Doe' 'Donald Duck' &gt;/dev/null
</p>

<p>
刚才我们讲了标准输出,那么标准输入怎么处理呢? EmacsLisp没有明确的输入函数,但是minibuffer在batch模式下会从标准输入读取数据^<a href="http://www.lunaryorn.com/posts/emacs-script-pitfalls.html#fn:5">5</a>:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span style="color: #2d9574;">":"</span><span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">exec emacs --quick --script "$0" "$@" # -*-emacs-lisp-*-</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">let</span> <span style="color: #bc6ec5;">(</span>name<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">while</span> <span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">and</span> <span style="color: #67b11d;">(</span><span style="color: #4f97d7; font-weight: bold;">setq</span> name <span style="color: #b1951d;">(</span><span style="color: #4f97d7; font-weight: bold;">ignore-errors</span> <span style="color: #4f97d7;">(</span>read-from-minibuffer <span style="color: #2d9574;">""</span><span style="color: #4f97d7;">)</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span>
              <span style="color: #67b11d;">(</span>&gt; <span style="color: #b1951d;">(</span>length name<span style="color: #b1951d;">)</span> <span style="color: #a45bad;">0</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span>princ <span style="color: #67b11d;">(</span>format <span style="color: #2d9574;">"Hello %s!"</span> name<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span>terpri<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span>kill-emacs <span style="color: #a45bad;">0</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
我们用 <code>read-from-minibuffer</code> 来从标准输入中读取数据,只要读到一个空字符串或者有错误发生.
记住,EOF(例如C-d)会引发一个error,因此我们可以像其他程序一样用 <code>C-d</code> 离开输入循环.
</p>

<pre class="example">
$ ./hello.el
John Doe
Hello John Doe!
Donald Duck
Hello Donald Duck!
</pre>

<p>
这其实还是有它的局限性. 你只能一行一行地读取数据,而且不能直接访问 <code>TTY</code>. 前一个问题到还没什么,但后一个问题限制住了Emacs脚本处理图形的能力,并且它无法实现任何类似curses这样的文本UI.
</p>

<p>
请注意! Emacs24及其之前的版本的Emacs在batch模式下用 <code>read-passwd</code> 从标准输出读取密码时,会在终端上显示出密码的内容.
Emacs25版本的 <code>read-passwd</code> 解决了这个问题.
</p>
</div>
</div>

<div id="outline-container-orgebd807e" class="outline-2">
<h2 id="orgebd807e">Debugging</h2>
<div class="outline-text-2" id="text-orgebd807e">
<p>
默认情况下, Emacs无论是interactive模式下还是在batch模式下,它的错误提示都非常的的简洁: 它仅仅是输出错误说明,但不显示任何调用栈的信息. 
假设有这么一段脚本,其中包含了一些拼写错误:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span style="color: #2d9574;">":"</span><span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">exec emacs --quick --script "$0" "$@" # -*-emacs-lisp-*-</span>

<span style="color: #4f97d7;">(</span>message <span style="color: #2d9574;">"%S"</span> <span style="color: #bc6ec5;">(</span>+ <span style="color: #2d9574;">(</span>car argv<span style="color: #2d9574;">)</span> <span style="color: #2d9574;">(</span>cadr argv<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">setq</span> argv nil<span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
然而它的错误提示并没有太大的用处:
</p>

<pre class="example">
$ ./hello.el 10 20
Wrong type argument: number-or-marker-p, "10"
</pre>

<p>
在interactive模式下, 我们只需要先执行 <code>M-x toggle-debug-on-error</code> 然后重新执行一次该命令就行了. 
随后Emacs就会在触发error时进入调试状态,并输出调用栈信息.
</p>

<p>
然而在batch模式下, 我们无法重新执行出错的命令, 因此我们需要在一开始就通过设置 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Error-Debugging.html#index-debug_002don_002derror">debug-on-error</a> 的方法来启用跟踪调用栈的功能.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">#!/bin/sh
<span style="color: #2d9574;">":"</span><span style="color: #2aa1ae; background-color: #292e34;">; </span><span style="color: #2aa1ae; background-color: #292e34;">exec emacs --quick --script "$0" "$@" # -*-emacs-lisp-*-</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">setq</span> debug-on-error t<span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span>message <span style="color: #2d9574;">"%S"</span> <span style="color: #bc6ec5;">(</span>+ <span style="color: #2d9574;">(</span>car argv<span style="color: #2d9574;">)</span> <span style="color: #2d9574;">(</span>cadr argv<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">setq</span> argv nil<span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
这样一来产生错误时就会输出调用栈的信息了:
</p>

<pre class="example">
$ ./hello.el 10 20
Debugger entered--Lisp error: (wrong-type-argument number-or-marker-p "10")
  +("10" "20")
  (message "%S" (+ (car argv) (cadr argv)))
  eval-buffer(#&lt;buffer  *load*&gt; nil "/Users/swiesner/Developer/Sandbox/hello.el" nil t)  ; Reading at buffer position 140
  load-with-code-conversion("/Users/swiesner/Developer/Sandbox/hello.el" "/Users/swiesner/Developer/Sandbox/hello.el" nil t)
  load("/Users/swiesner/Developer/Sandbox/hello.el" nil t t)
  command-line-1(("-scriptload" "./hello.el" "10" "20"))
  command-line()
  normal-top-level()
</pre>
</div>
</div>

<div id="outline-container-org1b3da16" class="outline-2">
<h2 id="org1b3da16">Keep your hands clean</h2>
<div class="outline-text-2" id="text-org1b3da16">
<p>
虽然我们都很热爱EmacsLisp, 但它确实不适合于编写脚本以及独立的程序. EmacsLisp 并不能算是一门独立的编程语言,也不是一个独立的运行环境.
它与Emacs紧密相连,而Emacs的主要功能还是作为一门交互式的文本编辑器来用的.
</p>

<p>
我写此文的意义一方面是希望能在你确实需要编写非交互式EmacsLisp程序(例如你可能需要用脚本来运行你的Emacs测试组件)时帮助到你. 但最主要还是想告诉你EmacsLisp在Emacs外是多么的难用.
</p>

<p>
不要没事找事了. 可以的话,尽量使用其他语言吧,像Python,Ruby等语言都不错. 如果你确实喜欢Lisp,那么就使用CommonLisp吧, <a href="http://www.sbcl.org">SBCL</a> 就很不错. 如果你能使用像OCaml或Haskell这样的纯函数式语言的话,那就更不错了.
</p>
</div>
</div>

</div>
</div>
<div>
        <div class="post-meta">
            <span title="post date" class="post-info">2016-11-28</span>
            <span title="last modification date" class="post-info">2016-11-28</span>
            <span title="tags" class="post-info">:N/A:</span>
            <span title="author" class="post-info"><a href="mailto:lujun9972 &lt;at&gt; T520">lujun9972</a></span>
        </div>
    <script src="../../../../../media/js/jquery-2.1.3.min.js"></script>
    <script src="../../../../../media/js/md5.min.js"></script>
        <section>
            <div id="gitalk-container"></div>
            <script type="text/javascript">
             var gitalk = new Gitalk({
                 clientID: 'fdcb5d9da3f4acb4862c',
                 clientSecret: 'dd0a16312a206782cb7669dcec5e96874ab48170',
                 repo: 'lujun9972.github.com',
                 owner: 'lujun9972',
                 admin: ['lujun9972'],
                 id: md5(location.pathname),      // Ensure uniqueness and length less than 50
                 distractionFreeMode: false  // Facebook-like distraction free mode
             })
             gitalk.render('gitalk-container')
            </script>
        </section>
    <script src="../../../../../media/js/main.js"></script>
    <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 26.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
            Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:lujun9972 &lt;at&gt; T520">lujun9972</a>
            &nbsp;&nbsp;-&nbsp;&nbsp;
            Powered by <a href="https://github.com/emacs-china/ego" target="_blank">EGO</a><br/>
            <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
            <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
    </div>
            </div>
            <script type="text/javascript"
                    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG">
            </script>
            <script type="text/x-mathjax-config">
             MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });
            </script>
</div>

  </div>
  <!-- https://instant.page/
       Make your site’s pages instant in 1 minute and improve your conversion rate by 1%  -->
  <script src="../../../../../instant.page/1.1.0" type="module" integrity="sha384-EwBObn5QAxP8f09iemwAJljc+sU+eUXeL9vSBw1eNmVarwhKk2F9vBEpaN9rsrtp"></script>
  </body>
</html>
