<!DOCTYPE html>
<html lang="en">
<head>
  <title>掌握Eshelltraceroute - EMACS-DOCUMENT</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <meta name="author" content="samrayleung" />
  <!-- <link rel="stylesheet" href="https://lujun9972.github.io/emacs-document/media/css/main.css" type="text/css"/>
       <link rel="stylesheet" href="https://lujun9972.github.io/emacs-document/media/css/comment.css" type="text/css"/> -->
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/dark.css'>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
</head>

  <body><div class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="https://lujun9972.github.io/emacs-document/">EMACS-DOCUMENT</a></h1>
    <p>=============&gt;集思广益</p>
    <nav class="site-nav">
      <ul class="trigger">
        <li><a href="https://lujun9972.github.io/emacs-document/years/">Years</a></li>
        <li><a href="https://lujun9972.github.io/emacs-document/authors/">Authors</a></li>
        <li><a href="https://lujun9972.github.io/emacs-document/tags/">Tags</a></li>
        <li><a href="https://lujun9972.github.io/emacs-document/about/">About</a></li>
        <li><a href="https://github.com/lujun9972/emacs-document">Github</a></li>
        <li><a href="https://lujun9972.github.io/emacs-document/rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="https://www.bing.com/search">
      <input type="text" class="field" name="q" id="s" placeholder="Search">
      <input type="hidden" name="as_sitesearch" value="lujun9972.github.io/emacs-document">
    </form>
  </header>
</div>

<div>
<div class="post">
<h1 class="title">掌握Eshelltraceroute</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf97ba33">1. Overview</a></li>
<li><a href="#org8002402">2. Commands</a></li>
<li><a href="#org0da1841">3. Technical Details</a></li>
<li><a href="#org44aee99">4. Built-in Commands</a></li>
<li><a href="#orge136d94">5. Command Interception</a></li>
<li><a href="#org9b323fc">6. Subshells</a></li>
<li><a href="#org1fbc405">7. Useful Elisp Commands</a>
<ul>
<li><a href="#org6888687">7.1. listify ARGS</a></li>
<li><a href="#org9e5efb5">7.2. addpath PATH</a></li>
<li><a href="#org313a90b">7.3. unset ENV-VAR</a></li>
<li><a href="#orgfbaf1b7">7.4. find-file FILE</a></li>
<li><a href="#orge7742db">7.5. dired DIRECTORY</a></li>
<li><a href="#org52bf204">7.6. calc-eval EXPR</a></li>
<li><a href="#org3f91c35">7.7. upcase STR /downcase STR</a></li>
<li><a href="#org5af298a">7.8. vc-dir DIRECTORY</a></li>
<li><a href="#orgcfba23a">7.9. ediff-files FILE1 FILE2</a></li>
</ul>
</li>
<li><a href="#org42bfa66">8. Aliasing</a>
<ul>
<li><a href="#org7ebeedb">8.1. Useful Examples</a></li>
</ul>
</li>
<li><a href="#org4e03b1e">9. Visual Commands</a></li>
<li><a href="#org123f784">10. Command History</a>
<ul>
<li><a href="#org592d1b0">10.1. M-r /M-s</a></li>
<li><a href="#orgbfcca46">10.2. M-p/M-n</a></li>
<li><a href="#orgedd4519">10.3. C-p/C-n</a></li>
<li><a href="#orgab450f9">10.4. C-c M-r /C-c M-s</a></li>
</ul>
</li>
<li><a href="#orgb115b39">11. History Interaction</a>
<ul>
<li><a href="#org4a9bf90">11.1. !!</a></li>
<li><a href="#org6e574bc">11.2. !ls</a></li>
<li><a href="#orge4b6ca1">11.3. !?ls</a></li>
<li><a href="#org1418652">11.4. !ls:n</a></li>
<li><a href="#orgb550f13">11.5. !ls&lt;tab&gt;</a></li>
<li><a href="#org4c23a51">11.6. ^old^new</a></li>
<li><a href="#org4ab9d23">11.7. $_</a></li>
</ul>
</li>
<li><a href="#org93a6a57">12. Commandline Interaction</a></li>
<li><a href="#org214d831">13. The Eshell Prompt</a></li>
<li><a href="#org1026034">14. The Commandline</a></li>
<li><a href="#org3968e18">15. Useful Keybindings</a>
<ul>
<li><a href="#orgf656352">15.1. C-c M-b</a></li>
<li><a href="#org0ed8c86">15.2. C-c M-i</a></li>
<li><a href="#org7757f1b">15.3. C-c M-v</a></li>
<li><a href="#orgb2e3fb5">15.4. C-c M-d</a></li>
</ul>
</li>
<li><a href="#org379ada3">16. Argument Predicates</a>
<ul>
<li><a href="#orgbe241a2">16.1. Syntax Reference</a></li>
<li><a href="#org6fd82ba">16.2. Globbing</a></li>
<li><a href="#org4373954">16.3. Elisp Lists</a></li>
<li><a href="#org0751412">16.4. Adding New Modifiers and Predicates</a></li>
</ul>
</li>
<li><a href="#org39074c7">17. Plan 9 Smart Shell</a></li>
<li><a href="#orgd07e595">18. Redirection</a></li>
<li><a href="#org3259d3e">19. To Emacs</a></li>
<li><a href="#org0866531">20. To Pseudo-Devices</a>
<ul>
<li><a href="#org96f3706">20.1. /dev/eshell</a></li>
<li><a href="#org588b224">20.2. /dev/null</a></li>
<li><a href="#orgd853a7c">20.3. /dev/clip</a></li>
<li><a href="#org040f376">20.4. /dev/kill</a></li>
<li><a href="#org3255d9e">20.5. To custom virtual target</a></li>
</ul>
</li>
<li><a href="#org2c9f5b0">21. TRAMP</a></li>
<li><a href="#orgbb1a292">22. Startup Scripts</a></li>
<li><a href="#orgfbc8d54">23. More Customization</a></li>
<li><a href="#org35d37b4">24. Conclusion</a></li>
</ul>
</div>
</div>
<p>
Emacs支持若干种shell,但是就功能丰富度，以及与Emacs的集成程度而言，
无一能望Eshell项背。Eshell是一个完全由Emacs Lisp编写的shell,但是不要以为这样
Eshell在功能上就会先天不足，它能代替绝大部分GNU核心功能集和Bourne shell家族的命令
以及相关特性。此外，通过用Emacs Lisp重写了类似 <b>ls</b> 和 <b>cp</b> 等常用命令，使Eshell 
可以成为真正的跨平台Shell.但是，Eshell有一个很大的不足，那就是Eshell严重缺乏文档
与之形成鲜明对比的是，Emacs及其生态都拥有丰富的文档
</p>
<div id="outline-container-orgf97ba33" class="outline-2">
<h2 id="orgf97ba33"><span class="section-number-2">1</span> Overview</h2>
<div class="outline-text-2" id="text-1">
<p>
与Emacs中的其他shell不一样的是，Eshell不是继承默认与的子进程进行交互的 <b>comint-mode</b>
因为Eshell不是一个子进程，所以它就没有必要使用 <b>comint-mode</b> 了；不过似乎这是件
好事，因为这意味着 <b>comint-mode</b> 的例程和钩子是不会作用于Eshell的。此外，几乎
所有 <b>comint-mode</b> 的常用命令，都在Eshell中重新实现了，并且使用相同的按键绑定
.当然，也有为数不多的按键绑定没有迁移到Eshell,例如在Eshll中搜索历史命令的
<i>comint-history-isearch-backward-regexp</i> 是绑定到了 <b>M-r</b>,而原来shell中相同
功能的命令的按键就是 <b>C-r</b>
Eshell可以在所有的平台都正常工作，其实和Eshell真正进行交互的是一个通用的中间件
(即Emacs Lisp/C的一个库),而该中间件又会跟你的操作系统进行通信，处理例如复制文件
等相关操作。此外，这个中间件甚至支持在Eshell中使用 <b>Tramp</b> 的特性
由于Emacs是血统纯正的Unix产物，Eshell是可以重现例如bash等传统Unix shell以及
其他GNU工具链的同样功能的。此外，如果你使用的是Windows,你应该感到庆幸，因为你
再也不用折腾 <i>cygwin</i> ,也不需要为跨平台移植Emacs而担忧依赖问题。事实上，对比
<i>cygwin</i> 的bash,在很多方面，Eshell对Windows的支持是做得更好滴。例如，你不再
需要 <b>/cygdrive/c</b> 来扩展相应的功能，因为Eshell自身就支持Windows/MS-DOS的路径
(所以 <b>cd D:</b> 或者 <b>D:</b> 同样都可以进入D盘)
虽然Eshell有很多好处，但是我还是要列出那些让人们很困惑的观点(或者说是误解):
</p>
<ol class="org-ol">
<li>Eshell不是一个终端模拟器，它不是跟shell进行通信，事实上，它就是一个shell.</li>
</ol>
<p>
它做的所有工作，无论是在屏幕展示数据，还是获取目录里面的信息，它都是通过Emacs
实现的，然后Emacs会再跟你的操作系统进行通信
</p>
<ol class="org-ol">
<li>由于Eshell跟其他进程通信的方式 (特别是异步通信),所以可能导致它的缓冲区(Buffers)
和其他中断操作出现问题</li>
<li>Eshell无法直接支持交互命令 (按照Eshell的说法，叫做“可视化命令”),例如top</li>
</ol>
<p>
,所以你一定要告诉Eshll应在单独的 <b>ansi-term</b> 实例运行此类命令
</p>
<ol class="org-ol">
<li>它不是 <i>bash</i> 或者 <i>zsh</i>,更不是 <i>csh</i>,所以不要像操作它们那样操作Eshell</li>
</ol>
<p>
即使Eshell跟它们真的很像。因此，如果你想更加高效地使用Eshell,你最好把它当作
一个不一样的shell
</p>
</div>
</div>
<div id="outline-container-org8002402" class="outline-2">
<h2 id="org8002402"><span class="section-number-2">2</span> Commands</h2>
<div class="outline-text-2" id="text-2">
<p>
Eshell是可以调用几乎所有的已加载的elisp函数的；这种灵活性是其它shell无法想象的
也是它们力所不能及的。事实上，这种在shell里面跟elisp函数结合的玩法理应得到更多
人的支持和推崇，因为它真的很酷(当然也很有用).假如你想在Emacs里面打开 <b>foobar.txt</b>
,你只需调用 <b>find-file foobar.txt</b>,Eshell就会调用对应的 <b>(find-file "foobar.txt")</b>
,并为你打开文件
</p>
</div>
</div>
<div id="outline-container-org0da1841" class="outline-2">
<h2 id="org0da1841"><span class="section-number-2">3</span> Technical Details</h2>
<div class="outline-text-2" id="text-3">
<p>
所有被Eshell执行的命令都有一个执行的顺序，这是必需传递给Emacs的有序列表，因为
这个列表决定了Eshell的哪一部分应该处理该命令的。如果该列表中没有找到可以执行
你的操作的函数或者对应命令，你会被告知，你输入的是无效命令
假设 你想调用 <b>cp</b> 命令，调用顺序如下：
</p>
<ol class="org-ol">
<li>完整的路径 (即 <b>/bin/cp</b>),在 <b>/bin</b> 目录下执行 <b>cp</b></li>
<li>寻找命令的前缀， <i>eshell-explict-command-char</i> (默认值是 "*"),如果有前缀的话</li>
</ol>
<p>
那么，在搜索路径寻找对应的命令 
</p>
<ol class="org-ol">
<li>寻找shell命令的别名 (<b>alias</b> 命令)</li>
<li>在搜索路径寻找 <b>cp</b> ,即 <b>$PATH</b> (或者 <b>eshell-path-env</b>) 定义的路径</li>
<li>寻找叫做 <b>cp</b> 的Lisp函数 或者 叫 <b>eshell/cp</b> 的elisp函数</li>
</ol>
<p>
变量 <i>eshell-prefer-lisp-functions</i> 让内部的elisp函数调用要先于外部调用，这
意味着，当该变量值为 <b>t</b> 的时候，Eshell会 <b>最先</b> 调用elisp函数，而不是 <b>最后</b>
才调用；但是，当命令前缀(即 <i>eshll-explicit-command-char</i>)被指定，该变量会被忽略
</p>
</div>
</div>
<div id="outline-container-org44aee99" class="outline-2">
<h2 id="org44aee99"><span class="section-number-2">4</span> Built-in Commands</h2>
<div class="outline-text-2" id="text-4">
<p>
Eshell有很多很好用的通过Emacs-Lisp重写的命令，这些命令实现了绝大部分GNU核心工具集
或者你所钟爱的shell的特性，所以这些命令被称为"Alias functions"(别名函数).
但是Eshell并不是全盘模拟其他Shell的功能特性，如果你传递了一些参数，试图调用Eshell
未实现的功能时，Eshell会自动调用外部的对应的命令来实现你想要的功能 (当然前提
是你已经安装该命令)
下面列出Eshell已经重新实现的命令：
<b>cat</b> , <b>cp</b> , <b>ls</b> , <b>cd</b> , <b>export</b> , <b>dirs</b> , <b>du</b> , <b>echo</b> , <b>env</b> , <b>kill</b>
<b>ln</b> , <b>mkdir</b> , <b>mv</b> , <b>alias</b> , <b>popd</b> , <b>pushd</b> , <b>pwd</b> , <b>rm</b> , <b>rmdir</b> 
<b>time</b> , <b>umask</b>.
Eshell注重跟原有的GNU工具功能同步，所以你不用担心因Eshell命令跟其他原生Shell命令不一致
而导致的问题
</p>
</div>
</div>
<div id="outline-container-orge136d94" class="outline-2">
<h2 id="orge136d94"><span class="section-number-2">5</span> Command Interception</h2>
<div class="outline-text-2" id="text-5">
<p>
Eshell有一个很cool的特性，那就是某些命令会被拦截并且传递给Emacs.这种机制允许
你调用一个命令例如 <b>man ls</b>,但是真正调用处理的是Emacs内置的 <b>man</b>.此外，对于
之前提及的交互式命令而言，这种特性是很重要的，因为Eshell是没有能力处理该命令的。
但真正展现该特性威力的还是那么复杂的命令，例如 <b>grep</b> <b>diff</b>,因为Emacs本身就
内置了更加强大的 <i>grep</i> 和 <i>diff</i> 工具。这种特性真真实实展示了Eshell对比
其他shell的强大之处
下列的命令都会被重定向到Emacs内置的功能去：
<b>agrep</b> , <b>diff</b> , <b>egrep</b> , <b>fgrep</b> , <b>glimpse</b> , <b>grep</b> , <b>info</b> , <b>jobs</b> 
<b>locate</b> , <b>man</b> , <b>occur</b> , <b>su</b> , <b>sudo</b> , <b>whoami</b>
<b>su</b> <b>sudo</b> <b>whoami</b> 是与 <b>TRAMP</b> 相关的命令，所以如果你是连接到远程shell的
这些命令也是可以正常工作的
</p>
</div>
</div>
<div id="outline-container-org9b323fc" class="outline-2">
<h2 id="org9b323fc"><span class="section-number-2">6</span> Subshells</h2>
<div class="outline-text-2" id="text-6">
<p>
你可以使用 <b>$()</b> 来调用命令，并且把命令对应的输出当作接下来命令的参数，就好像
你在bash那样使用。但是你要谨记的一样事情就是你是无法使用反引号 *``*来生成
一个subshell的。虽然你也可以使用像调用subshell的语法来调用标准的elisp form:
<b>(form &#x2026;.)</b> 注意没有了 <b>$</b>,不过我并不推荐这种用法，因为很多情况，这种用法都
是不行的
</p>
</div>
</div>
<div id="outline-container-org1fbc405" class="outline-2">
<h2 id="org1fbc405"><span class="section-number-2">7</span> Useful Elisp Commands</h2>
<div class="outline-text-2" id="text-7">
<p>
Eshell有一套可以让你每天的生活变得更美好的帮助函数(helper function),此外
你可以在Eshell调用几乎所有的elisp函数，这就意味着，你拥有无上的能力来控制你
的shell.接下来，我会列举那些为Eshell专门编写的命令和一些我觉得很有用的命令。
我也编写了挺多的elisp函数了 (部分是专门写给Eshell,其他的就不是了)
</p>
</div>
<div id="outline-container-org6888687" class="outline-3">
<h3 id="org6888687"><span class="section-number-3">7.1</span> listify ARGS</h3>
<div class="outline-text-3" id="text-7-1">
<p>
将字符串参数解析成elisp列表符号，然后打印到屏幕。该函数不仅可以解析POSIX
类型的参数，也可以解析MS-DOS/Windows类型参数
</p>
</div>
</div>
<div id="outline-container-org9e5efb5" class="outline-3">
<h3 id="org9e5efb5"><span class="section-number-3">7.2</span> addpath PATH</h3>
<div class="outline-text-3" id="text-7-2">
<p>
将参数 (必须是文件路径) 添加到环境变量 <b>$PATH</b>,如果没有参数被指定的话，那么
将原有的变量值输出到屏幕
</p>
</div>
</div>
<div id="outline-container-org313a90b" class="outline-3">
<h3 id="org313a90b"><span class="section-number-3">7.3</span> unset ENV-VAR</h3>
<div class="outline-text-3" id="text-7-3">
<p>
移除已有的环境变量
</p>
</div>
</div>
<div id="outline-container-orgfbaf1b7" class="outline-3">
<h3 id="orgfbaf1b7"><span class="section-number-3">7.4</span> find-file FILE</h3>
<div class="outline-text-3" id="text-7-4">
<p>
搜索文件FILE,然后在Emacs中打开该文件。这个函数与 <b>TRAMP</b> 相关，所以也可以
远程工作
</p>
</div>
</div>
<div id="outline-container-orge7742db" class="outline-3">
<h3 id="orge7742db"><span class="section-number-3">7.5</span> dired DIRECTORY</h3>
<div class="outline-text-3" id="text-7-5">
<p>
在目录 <b>DIRECTORY</b> 下打开一个dired缓冲区
</p>
</div>
</div>
<div id="outline-container-org52bf204" class="outline-3">
<h3 id="org52bf204"><span class="section-number-3">7.6</span> calc-eval EXPR</h3>
<div class="outline-text-3" id="text-7-6">
<p>
在Emacs calculator执行该表达式 <b>EXPR</b>
</p>
</div>
</div>
<div id="outline-container-org3f91c35" class="outline-3">
<h3 id="org3f91c35"><span class="section-number-3">7.7</span> upcase STR /downcase STR</h3>
<div class="outline-text-3" id="text-7-7">
<p>
字符串STR大小写转换
</p>
</div>
</div>
<div id="outline-container-org5af298a" class="outline-3">
<h3 id="org5af298a"><span class="section-number-3">7.8</span> vc-dir DIRECTORY</h3>
<div class="outline-text-3" id="text-7-8">
<p>
展示在版本控制下的目录 <b>DIRECTORY</b> 的状态，跟大多数版本控制工具的 <b>status</b> 
命令相同
</p>
</div>
</div>
<div id="outline-container-orgcfba23a" class="outline-3">
<h3 id="orgcfba23a"><span class="section-number-3">7.9</span> ediff-files FILE1 FILE2</h3>
<div class="outline-text-3" id="text-7-9">
<p>
使用Emacs的比较引擎 (diff engine) ediff,对文件 <b>FILE1</b> <b>FILE2</b> 进行比较
</p>
</div>
</div>
</div>
<div id="outline-container-org42bfa66" class="outline-2">
<h2 id="org42bfa66"><span class="section-number-2">8</span> Aliasing</h2>
<div class="outline-text-2" id="text-8">
<p>
你可以像在其它主流的shell那样给Eshell命令赋予别名，操作是一样滴，此外，你甚至可以
混合使用elisp函数和Eshell命令。 <b>alias</b> 命令的格式是 <b>alias alias-name definition</b>
<b>definition</b> 必须由一对单引号 <b>''</b> 包围。你也可以使用其它shell的参数引用形式：
例如 <b>$1</b> 指第一个参数， <b>$2</b> 指第二个参数，依此类推，或者 <i>$*</i> 指所有的参数。
当参数没有在 <b>definition</b> 被引用，Eshell会自动把参数添加到命令的末尾，并把参数
忽略
如果想移除一条命令的别名，只需不对变量 <b>definition</b> 赋值 (即 <b>alias alias-name</b>)
别名就会被自动移除，如果想列出所有的别名，只需输入 <b>alias</b>
Eshell会把命令的别名及其定义写入到变量 <b>eshell-aliases-file</b> 然后统一被变量
<b>Eshell-directory-name</b> 管理；然后别名默认会被统一写入到 <b>~/.Eshell/alias</b>.
每次你更改一个命令别名，都会重复上面的流程
另外一个很有用的特性就是别名自动修正 (<i>auto-correcting aliasing</i>),如果你输入
一个无效的命令太多次 (变量 <b>eshll-bad-command-tolerance</b> 表示触发自动更正的最低
次数，默认值为3),Eshell会为你真正想执行的命令提供别名 例如你想输入的是 <b>cp</b> 
但是输入了太多次的 <b>co</b>,所以下次你输入 <b>co</b> 的时候，Eshell就会自动执行 <b>cp</b>.
当然，如果你不喜欢这种特性的话，你可以把最低次数设得很大
</p>
</div>
<div id="outline-container-org7ebeedb" class="outline-3">
<h3 id="org7ebeedb"><span class="section-number-3">8.1</span> Useful Examples</h3>
<div class="outline-text-3" id="text-8-1">
<p>
让我们把长长的 <b>find-file</b> 命令映射到更顺手的别名 <b>ff</b>:
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #4f97d7;">alias</span> ff <span style="color: #2d9574;">'find-file $1'</span>
</pre>
</div>
<p>
把 <b>dired</b> 映射到 <b>d</b>:
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #4f97d7;">alias</span> d <span style="color: #2d9574;">'dired $1'</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org4e03b1e" class="outline-2">
<h2 id="org4e03b1e"><span class="section-number-2">9</span> Visual Commands</h2>
<div class="outline-text-2" id="text-9">
<p>
有一些对Eshell而言是太复杂的命令，Eshell是无法直接显示的，所以需要特殊的处理
例如 <b>top</b> ,是无法与一些哑终端(dumb terminal)一起正常工作的。为了使这些命令正常
工作，Eshell会运行一个终端模拟器 <b>term</b> 来执行这些的命令 (即被称为可视化的命令)
如果你想修改可视化命令的列表，你可以修改变量 <b>eshell-visual-commands</b>
</p>
</div>
</div>
<div id="outline-container-org123f784" class="outline-2">
<h2 id="org123f784"><span class="section-number-2">10</span> Command History</h2>
<div class="outline-text-2" id="text-10">
<p>
Eshell有功能丰富的命令行历史机制，但是因为Eshell不是继承 <b>comint-mode</b> 的
所以 <b>comint-mode</b> 与历史相关的功能，Eshell是没法用的，不过它绝大部份的功能
都已经在Eshell重新实现了
</p>
</div>
<div id="outline-container-org592d1b0" class="outline-3">
<h3 id="org592d1b0"><span class="section-number-3">10.1</span> M-r /M-s</h3>
<div class="outline-text-3" id="text-10-1">
<p>
向前或者向后搜索命令，支持正则表达式
</p>
</div>
</div>
<div id="outline-container-orgbfcca46" class="outline-3">
<h3 id="orgbfcca46"><span class="section-number-3">10.2</span> M-p/M-n</h3>
<div class="outline-text-3" id="text-10-2">
<p>
在历史命令列表中前进或者后退
</p>
</div>
</div>
<div id="outline-container-orgedd4519" class="outline-3">
<h3 id="orgedd4519"><span class="section-number-3">10.3</span> C-p/C-n</h3>
<div class="outline-text-3" id="text-10-3">
<p>
Eshell上一条命令或者下一条命令
</p>
</div>
</div>
<div id="outline-container-orgab450f9" class="outline-3">
<h3 id="orgab450f9"><span class="section-number-3">10.4</span> C-c M-r /C-c M-s</h3>
<div class="outline-text-3" id="text-10-4">
<p>
回到上一条/下一条历史命令，历史命令必须与现在的命令输入一致。例如 现在的输入是：
<b>ls</b> ,那么回到的上一条 /下一条历史命令必须是 <b>ls</b>,或者以 <b>ls</b> 开头的命令，如 <b>lsmod</b>
</p>

<p>
不足的是，新的经过修改的命令 <b>comint-history-isearch-backward-regexp</b> (在 
<b>comint</b> 键绑定是 <b>M-r</b>)在Eshll是无法使用的，因为Eshell不是继承于 <b>comint</b>
(所以在升级中被忽略了)
</p>
</div>
</div>
</div>
<div id="outline-container-orgb115b39" class="outline-2">
<h2 id="orgb115b39"><span class="section-number-2">11</span> History Interaction</h2>
<div class="outline-text-2" id="text-11">
<p>
像bash和其它shell那样，Eshell也支持历史的修改和交互。如果想要知道历史交互
是怎么操作的，你就需要回去翻一下bash的手册了。接下来我会总结一下Eshell大部份
的历史交互用法
</p>
</div>
<div id="outline-container-org4a9bf90" class="outline-3">
<h3 id="org4a9bf90"><span class="section-number-3">11.1</span> !!</h3>
<div class="outline-text-3" id="text-11-1">
<p>
重复上一条命令
</p>
</div>
</div>
<div id="outline-container-org6e574bc" class="outline-3">
<h3 id="org6e574bc"><span class="section-number-3">11.2</span> !ls</h3>
<div class="outline-text-3" id="text-11-2">
<p>
重复上一条以 <i>ls</i> 开头的命令
</p>
</div>
</div>
<div id="outline-container-orge4b6ca1" class="outline-3">
<h3 id="orge4b6ca1"><span class="section-number-3">11.3</span> !?ls</h3>
<div class="outline-text-3" id="text-11-3">
<p>
重复上一条包含 <i>ls</i> 的命令
</p>
</div>
</div>
<div id="outline-container-org1418652" class="outline-3">
<h3 id="org1418652"><span class="section-number-3">11.4</span> !ls:n</h3>
<div class="outline-text-3" id="text-11-4">
<p>
从上一条以 <i>ls</i> 开头的命令截取第n个参数
</p>
</div>
</div>
<div id="outline-container-orgb550f13" class="outline-3">
<h3 id="orgb550f13"><span class="section-number-3">11.5</span> !ls&lt;tab&gt;</h3>
<div class="outline-text-3" id="text-11-5">
<p>
使用命令补全，显示补全结果中包含 <b>ls</b> 的命令
</p>
</div>
</div>
<div id="outline-container-org4c23a51" class="outline-3">
<h3 id="org4c23a51"><span class="section-number-3">11.6</span> ^old^new</h3>
<div class="outline-text-3" id="text-11-6">
<p>
快速替换，对于上一条命令，使用 <b>old</b> 来代替命令中的 <b>new</b> (备注：似乎有Bug)
</p>
</div>
</div>
<div id="outline-container-org4ab9d23" class="outline-3">
<h3 id="org4ab9d23"><span class="section-number-3">11.7</span> $_</h3>
<div class="outline-text-3" id="text-11-7">
<p>
返回上一条执行的命令的最后一个参数
</p>

<p>
Eshll也支持bash历史修改(例如 !!:s/old/new/),如果你想了解更多的信息，
<a href="https://www.gnu.org/software/bash/manual/bash.html#History-Interaction">the bash reference on history interaction</a> 可以告诉你你想知道的东西
</p>
</div>
</div>
</div>
<div id="outline-container-org93a6a57" class="outline-2">
<h2 id="org93a6a57"><span class="section-number-2">12</span> Commandline Interaction</h2>
</div>
<div id="outline-container-org214d831" class="outline-2">
<h2 id="org214d831"><span class="section-number-2">13</span> The Eshell Prompt</h2>
<div class="outline-text-2" id="text-13">
<p>
你可以通过修改变量 <b>eshell-prompt-function</b> 来自定义Eshell的提示符；该变量
有一个函数定义了Eshell命令行提示符应该包含的内容。通过用elisp来管理Eshell
命令行提示符的配置，你就可以实现你想要的任何特性。你需要注意的事情就是：你需要
告诉Eshell,命令行提示符长什么样子，所以你必须修改变量 <b>eshell-prompt-regexp</b>
,那样Eshell就会知道你想要的提示符长什么样子了
</p>
</div>
</div>
<div id="outline-container-org1026034" class="outline-2">
<h2 id="org1026034"><span class="section-number-2">14</span> The Commandline</h2>
<div class="outline-text-2" id="text-14">
<p>
Eshell可以使用反斜杠 <b>\</b> 来转义新行，以及基本的多行输入。另外一个输入多行的
文学字符串 (literal string)的方法就是使用单引号：输入一个单引号，然后回车，
接着你就可以输入你想输入的内容，最后用另外一个单引号结束输入。如果你使用双引号
的话，Eshell会自动展开subshell命令并且展开相应的变量
得益于Eshell的调用机制，你甚至可以回去继续修改引号里面的文本。当你想回去修改
你不喜欢的内容，让Eshell像你预期那样工作的时候，你就会觉得这种特性真的相当
有用
</p>
</div>
</div>
<div id="outline-container-org3968e18" class="outline-2">
<h2 id="org3968e18"><span class="section-number-2">15</span> Useful Keybindings</h2>
<div class="outline-text-2" id="text-15">
<p>
Eshell做了很多与Eamcs进行交互的功能的改进，而且，这些改进足以影响你的生活
质量，让我为你一一道来：
</p>
</div>
<div id="outline-container-orgf656352" class="outline-3">
<h3 id="orgf656352"><span class="section-number-3">15.1</span> C-c M-b</h3>
<div class="outline-text-3" id="text-15-1">
<p>
将已经某个缓冲区的名字插入到当前光标
</p>
</div>
</div>
<div id="outline-container-org0ed8c86" class="outline-3">
<h3 id="org0ed8c86"><span class="section-number-3">15.2</span> C-c M-i</h3>
<div class="outline-text-3" id="text-15-2">
<p>
将已经某个进程的名字插入到当前光标
</p>
</div>
</div>
<div id="outline-container-org7757f1b" class="outline-3">
<h3 id="org7757f1b"><span class="section-number-3">15.3</span> C-c M-v</h3>
<div class="outline-text-3" id="text-15-3">
<p>
将一个环境变量的名字插入到当前光标
</p>
</div>
</div>
<div id="outline-container-orgb2e3fb5" class="outline-3">
<h3 id="orgb2e3fb5"><span class="section-number-3">15.4</span> C-c M-d</h3>
<div class="outline-text-3" id="text-15-4">
<p>
在直接输入和延迟输入(回车确认)之间切换 (对不能与来源于其他缓冲区的输入正常工作
的命令来说就很有用了)
</p>
</div>
</div>
</div>
<div id="outline-container-org379ada3" class="outline-2">
<h2 id="org379ada3"><span class="section-number-2">16</span> Argument Predicates</h2>
<div class="outline-text-2" id="text-16">
<p>
参数谓词是一个很擅长过滤文件，甚至elisp列表的工具。Eshell的谓词语法是参照zsh
的，所以如果你熟悉zsh的参数谓词，你也可以以同样的方式来使用Eshell.
与Eshell绝大部分迥异的是，参数谓词是有详细的文档的。你可以通过输入 <b>eshell-display-predicate-help</b>
或者 <b>eshell-display-modifier-help</b> 来查看帮助文档
参数谓词用来过滤有相同模式的文件是很有用，你不需再花费额外的时间来使用诸如 
<b>find</b> <b>ls</b> 此类命令。
虽然有帮助手册，但是手册还是很简单，不尽人意，所以我自己总结了一些用法来帮助读者
了解相关特性。但是最好的学习方法还是多尝试，多出错，多总结
</p>
</div>
<div id="outline-container-orgbe241a2" class="outline-3">
<h3 id="orgbe241a2"><span class="section-number-3">16.1</span> Syntax Reference</h3>
<div class="outline-text-3" id="text-16-1">
<p>
我就不把那么多的谓词和修饰符一一列出来了，因为Eshell的手册已经作了很详细
的解释了，你需要做的就是自己查看
</p>
</div>
</div>
<div id="outline-container-org6fd82ba" class="outline-3">
<h3 id="org6fd82ba"><span class="section-number-3">16.2</span> Globbing</h3>
<div class="outline-text-3" id="text-16-2">
<p>
Eshell的匹配模式和其他常用shell的是基本一致滴：shell会扩展文件和路径的匹配
模式，然后将匹配后的列表当作参数传递给相应的命令，例如 <b>ls</b>.这就是为什么你一起使用
<b>find</b> 和 <b>xargs</b> 命令的时候，最好要把 <b>-print0</b> 传递给 <b>find</b> 并且把 <b>-0</b>
传递给 <b>xargs</b>.因为如果你不这样做的话，文件名或者路径名中的特殊字符或者空格就会
让 <b>xargs</b> 不知道如何正确地处理。通过使用 <b>NUL</b> 字符作为分隔符，保证字符可以被
正确地标记，并且文件中紧跟着 <b>/</b> 的 <b>NUL</b> 字符会被标记为无效字符
</p>
</div>
</div>
<div id="outline-container-org4373954" class="outline-3">
<h3 id="org4373954"><span class="section-number-3">16.3</span> Elisp Lists</h3>
<div class="outline-text-3" id="text-16-3">
<p>
如果你把Eshell的列表理解成输出的 <i>form</i> 的elisp列表，你会发现理解起来变得容易
因为事实上Eshell是可以通过Elisp来处理列表的，而处理列表恰恰是Lisp擅长的东西
最简单的模式扩展就是 <i>echo *</i>,该命令会把当前文件夹下所有匹配的文件以列表的形式
打印出来。因为，正如我先前提及的那样，通配符扩展是同步一致进行的，所以我可以在
在使用 <i>*</i> 的同时再使用另外一个修饰符。例如:
我们把当前文件夹下的所有文件名变成大写的形式，并以列表的形式打印出来：
</p>
<div class="org-src-container">
<pre class="src src-shell">/ $ echo *<span style="color: #4f97d7;">(</span>:U<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span><span style="color: #2d9574;">"BAR"</span> <span style="color: #2d9574;">"BIN/"</span> <span style="color: #2d9574;">"DEV/"</span> <span style="color: #2d9574;">"ETC/"</span> <span style="color: #2d9574;">"FOO"</span> <span style="color: #2d9574;">"HOME/"</span> <span style="color: #2d9574;">"LIB/"</span> <span style="color: #2d9574;">"TMP/"</span> <span style="color: #2d9574;">"USR/"</span> <span style="color: #2d9574;">"VAR/"</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
请注意，我是怎样在使用模式扩展的同时使用 <b>()</b>.这对括号可以让你使用参数修饰符或者
是谓词。修饰符是可以修饰你的结果列表的(很惊讶吧).修饰符总是以冒号 <b>:</b> 开头滴，
而谓词却不一样。
我会展示另外一个例子，这次这个例子我会使用谓词来过滤目录：
</p>
<div class="org-src-container">
<pre class="src src-shell">/ $ echo *<span style="color: #4f97d7;">(</span>^/<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span><span style="color: #2d9574;">"bar"</span> <span style="color: #2d9574;">"foo"</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
这个 <b>^</b> 在上面的命令的作用，是跟在正则表达式中一样，用作取反，而斜杠的作用 <b>/</b> 
是只代表目录，所以上面的作用就是打印所有文件
</p>

<p>
对于修饰符和谓词，我也可以不使用模式扩展
</p>
<div class="org-src-container">
<pre class="src src-shell">/ $ echo <span style="color: #4f97d7;">(</span><span style="color: #2d9574;">"foo"</span> <span style="color: #2d9574;">"bar"</span> <span style="color: #2d9574;">"baz"</span> <span style="color: #2d9574;">"foo"</span><span style="color: #4f97d7;">)(</span>:gs/foo/blarg<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span><span style="color: #2d9574;">"blarg"</span> <span style="color: #2d9574;">"bar"</span> <span style="color: #2d9574;">"baz"</span> <span style="color: #2d9574;">"blarg"</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
这次我是把所有的 <i>foo</i> 代替为 <i>blarg</i>.你可以发现语法是相同的，只是这次我不是
使用模式匹配来获取文件列表，而是直接输入文件的列表
使用参数谓词和修饰符的好处是你大大减少了输入的命令行数量，因为用谓词可以处理权限
，属主，文件属性，甚至更多方面的问题 
</p>
</div>
</div>
<div id="outline-container-org0751412" class="outline-3">
<h3 id="org0751412"><span class="section-number-3">16.4</span> Adding New Modifiers and Predicates</h3>
<div class="outline-text-3" id="text-16-4">
<p>
你也可以添加自己的谓词 (<b>eshell-predicate-alist</b>)或者修饰符 (<b>eshell-modifier-alist</b>):
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #4f97d7;">(</span>add-to-list 'eshell-modifier-alist '<span style="color: #bc6ec5;">(</span>?X . '<span style="color: #2d9574;">(</span>lambda<span style="color: #67b11d;">(</span>lst<span style="color: #67b11d;">)(</span>mapcar 'rot13 lst<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
我已经将 <b>rot13</b> 绑定到 <b>X</b> 了，替换结果如下：
</p>
<div class="org-src-container">
<pre class="src src-shell">/ $ echo <span style="color: #4f97d7;">(</span><span style="color: #2d9574;">"foo"</span> <span style="color: #2d9574;">"bar"</span> <span style="color: #2d9574;">"baz"</span><span style="color: #4f97d7;">)(</span>:X<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span><span style="color: #2d9574;">"sbb"</span> <span style="color: #2d9574;">"one"</span> <span style="color: #2d9574;">"onm"</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org39074c7" class="outline-2">
<h2 id="org39074c7"><span class="section-number-2">17</span> Plan 9 Smart Shell</h2>
<div class="outline-text-2" id="text-17">
<p>
Eshell有一个 <b>Plan 9</b> 终端的弱化版，叫做 <i>the Eshell smart display</i>.
Eshell的智能展示(<i>smart display</i>)意味着它改进了所有黑客所习惯的 <i>输入－运行－修改</i> 
工作流程。智能展示特别之处在于，Eshell的光标不会像普通的shell那样，落在你运行
的命令的输出后面；相反，光标的位置会保持在你输入命令的位置，让你可以通过 <b>M-p</b> <b>M-n</b> 
或者其他修改历史的命令更容易地修改你输入的命令
如果你启用了 <b>smart display</b> 模式，你还可以使用 <b>SPC</b> 向下翻页，或者使用 <b>BACKSPACE</b>
向上翻页来查看那些长时间运行的命令的输出。如果你按下了任何其它的按键，光标会直接
跳到你缓冲区的结尾，就好像你没有启用 <b>smart display</b> 运行命令时那样
值得注意的是，如果Eshell检测到你想回顾最后一条执行的命令时，Eshell会很贴心
地帮你回顾的，但是，如果你没有这样的行为，Eshell的光标会直接跳转到缓冲区的结尾
这么看来，Eshell真的很智能，而且它也有一些设置可以让你微调相关的行为。
你会发现智能显示 (smart display)真的非常有用，特别是你可以通过移动按键就能修改
刚刚执行过的命令；例如修改拼写错误的命令或者是给相应的命令添加参数
智能显示还可以被设置成当命令成功执行时，不使用扩展的 <b>edit mode</b>;并且隐藏命令输出
,就好像你执行 <b>chown</b> 那样。这也是我喜欢的玩法，如果你也想试试这种玩法，你可以把
下面的elisp代码添加到你的 <b>.emacs</b> 文件：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">require</span> '<span style="color: #a45bad;">eshell</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">require</span> '<span style="color: #a45bad;">em-smart</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">setq</span> eshell-where-to-jump 'begin<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">setq</span> eshell-review-quick-commands nil<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">setq</span> eshell-smart-space-goes-to-end t<span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
如果Eshell已经被初始化(即你已经在Emacs运行了一个Eshell实例),那样的话，运行
上面的代码是不会起作用的。你必须在Eshell里面按下 <b>M-:</b> 然后输入(shell-smart-initialize)
,或者直接重启Emacs
智能显示真的是非常有用的特性，但是你一时半刻是很难完全领会其全部的精妙之处滴。
你直接输入一个命令，Eshell的光标就会跳转到缓冲区的结尾，所以你会觉得光标似乎
本来就在那里
</p>
</div>
</div>
<div id="outline-container-orgd07e595" class="outline-2">
<h2 id="orgd07e595"><span class="section-number-2">18</span> Redirection</h2>
<div class="outline-text-2" id="text-18">
<p>
Eshell的重定向跟其它shell的工作方式基本是一样的，但是，有一项非常重要的差异
就是Eshell必须模拟可能不存在的伪设备，例如Windows平台上的 <b>/dev/null</b> 其实是 <b>NUL</b>
另外一个值得注意的地方就是：虽然Eshell支持重定向，但是只是支持输出重定向，是
不支持输入重定向的。为了避免跳进输入重定向这个坑，你最好使用管道。重定向到标准输入
标准输出，标准错误都是可以正常工作的，此外，你也可以重定向到多个目标，很不错的特性吧
</p>
</div>
</div>
<div id="outline-container-org3259d3e" class="outline-2">
<h2 id="org3259d3e"><span class="section-number-2">19</span> To Emacs</h2>
<div class="outline-text-2" id="text-19">
<p>
因为Eshell在内部用Elisp重新实现了各种伪设备，所以也就无需跟Unix的设备文件打
交道了，甚至，可以用Elisp实现自己的伪设备。
一个很好的例子就是，你可以把重定向到一个你选择的缓冲区，用下面的命令就能实现：
</p>
<div class="org-src-container">
<pre class="src src-shell">/ $ cat mylog.log &gt;&gt; <span style="color: #2aa1ae; background-color: #292e34;">#</span><span style="color: #2aa1ae; background-color: #292e34;">&lt;buffer *scratch*&gt;</span>
</pre>
</div>
<p>
我之前提到的快捷键 <b>C-c M-b</b> 就是可以把一个选定的缓冲区的名字插入到光标前
此外，你也可以把输出直接重定向到Elisp的符号(不过注意，不要执行错误的设置)
</p>
<div class="org-src-container">
<pre class="src src-shell">/ $ echo foo bar baz &gt; <span style="color: #2aa1ae; background-color: #292e34;">#</span><span style="color: #2aa1ae; background-color: #292e34;">'myvar</span>
/ $ echo $<span style="color: #4f97d7;">(</span><span style="color: #fa8072;">cadr</span> myvar<span style="color: #4f97d7;">)</span>
bar
</pre>
</div>
<p>
如果你将变量 <b>eshell-buffer-shorthand</b> 设置为 <b>t</b> 的话。你就可以使用缓冲区的速记名
例如 <b>#'*scratch</b>'*,但是你就不能直接重定向到Elisp的符号了
</p>
</div>
</div>
<div id="outline-container-org0866531" class="outline-2">
<h2 id="org0866531"><span class="section-number-2">20</span> To Pseudo-Devices</h2>
<div class="outline-text-2" id="text-20">
<p>
Eshell重新实现了以下的伪设备：
</p>
</div>
<div id="outline-container-org96f3706" class="outline-3">
<h3 id="org96f3706"><span class="section-number-3">20.1</span> /dev/eshell</h3>
<div class="outline-text-3" id="text-20-1">
<p>
以交互的方式，把结果输出到Eshell
</p>
</div>
</div>
<div id="outline-container-org588b224" class="outline-3">
<h3 id="org588b224"><span class="section-number-3">20.2</span> /dev/null</h3>
<div class="outline-text-3" id="text-20-2">
<p>
把结果输出到 <b>NULL</b> 设备
</p>
</div>
</div>
<div id="outline-container-orgd853a7c" class="outline-3">
<h3 id="orgd853a7c"><span class="section-number-3">20.3</span> /dev/clip</h3>
<div class="outline-text-3" id="text-20-3">
<p>
把结果输出到剪切板
</p>
</div>
</div>
<div id="outline-container-org040f376" class="outline-3">
<h3 id="org040f376"><span class="section-number-3">20.4</span> /dev/kill</h3>
<div class="outline-text-3" id="text-20-4">
<p>
把结果输出到 <i>kill ring</i>
</p>

<p>
跟通用的shell一样，使用 <b>&gt;</b> 代表覆盖(或者新建);使用 <b>&gt;&gt;</b> 代表追加
</p>
</div>
</div>
<div id="outline-container-org3255d9e" class="outline-3">
<h3 id="org3255d9e"><span class="section-number-3">20.5</span> To custom virtual target</h3>
<div class="outline-text-3" id="text-20-5">
<p>
你通过修改变量 <b>eshell-virtual-targets</b> 创建自己的可视化目标(即存储你想创建的
伪设备的名字的一个列表),以及修改代表重定向行为(即覆盖或追加或插入)的函数 <b>mode</b>
</p>
</div>
</div>
</div>
<div id="outline-container-org2c9f5b0" class="outline-2">
<h2 id="org2c9f5b0"><span class="section-number-2">21</span> TRAMP</h2>
<div class="outline-text-2" id="text-21">
<p>
Eshell可以很好地支持TRAMP,这意味着如果Eshell所在的目录是在远程服务器的话，
像 <b>su</b> <b>sudo</b> <b>whoami</b> 这样的命令会自动作用在远程服务器 
想直接使用TRAMP,你可以像使用 <b>C-x C-f</b> 寻找文件那样输入TRAMP的命令符，然后
你就可以使用TRAMP了。虽然你会觉得Eshell里面使用TRAMP有点奇怪，但是你的确得到了
一个TRAMP的远程shell,不是么？此外，你不应把TRAMP局限在使用远程shell,你可以在本地
使用 <b>sudo</b> 和 <b>su</b> 命令的
有关TRAMP的更详细的用法，我总结在了另外一篇文章，不过如果你迫不及待想了解更多
有关TRAMP的用法，<a href="https://www.gnu.org/software/tramp/">官方手册</a> 是一个很好的选择
</p>
</div>
</div>
<div id="outline-container-orgbb1a292" class="outline-2">
<h2 id="orgbb1a292"><span class="section-number-2">22</span> Startup Scripts</h2>
<div class="outline-text-2" id="text-22">
<p>
跟其它的shell一样，Eshell也支持 <i>login</i> 和 <i>profile</i> 的配置文件。 <i>login</i> 和
<i>profile</i> 配置文件的绝对路径分别保存在变量 <b>eshell-login-script</b> 和 <b>eshell-rc-script</b>
不过默认情况下，上述两个配置文件都保存在 <b>~/.eshell/</b>.顺便说一下，Eshell的配置
文件也是使用 <b>#</b> 来注释变量和语句的
</p>
</div>
</div>
<div id="outline-container-orgfbc8d54" class="outline-2">
<h2 id="orgfbc8d54"><span class="section-number-2">23</span> More Customization</h2>
<div class="outline-text-2" id="text-23">
<p>
如果你想折腾的话，Eshell有成百上千的选项供你选择。如果你想配置Eshell的话，按下
<b>M-x</b> 然后输入 <b>customize-group</b> 回车，然后输入 <b>eshell</b> 回车确认
</p>
</div>
</div>
<div id="outline-container-org35d37b4" class="outline-2">
<h2 id="org35d37b4"><span class="section-number-2">24</span> Conclusion</h2>
<div class="outline-text-2" id="text-24">
<p>
额，我觉得我已经总结了Eshell的大部份用法了，希望你可以在其中发现乐趣。因为与Emacs
的紧密结合，Eshell有了各种各样突出好用的特性，但是你需要理解的是，Eshell的诞生不是
为了全盘取代bash或者其它你喜欢的终端模拟器，它只是希望在Emacs里面就可以完成我们
日常必需的命令行操作。如果你要运行很多交互式的命令，Eshell就可能不是很有用了
因为为了运行你输入的每一条可视化命令，Eshell都会在Emacs里面启动一个新的终端模拟器。
Eshell有TRAMP支持，自定义伪设备，袖珍的elisp REPL和很多非常有用的命令，例如
对你打开的文件或者目录，调用 <b>find-file</b> 或者 <b>dired</b>.正是这种种有用的特性，
让Eshell成为我工具箱里面一个非常可靠的工具。
</p>
</div>
</div>

</div>
</div>
<div>
        <div class="post-meta">
            <span title="post date" class="post-info">2017-02-23</span>
            <span title="last modification date" class="post-info">2019-04-26</span>
            <span title="tags" class="post-info">:N/A:</span>
            <span title="author" class="post-info"><a href="mailto:lujun9972 &lt;at&gt; T430S">samrayleung</a></span>
        </div>
    <script src="https://lujun9972.github.io/emacs-document/media/js/jquery-2.1.3.min.js"></script>
    <script src="https://lujun9972.github.io/emacs-document/media/js/md5.min.js"></script>
        <section>
            <div id="gitalk-container"></div>
            <script type="text/javascript">
             var gitalk = new Gitalk({
                 clientID: 'fdcb5d9da3f4acb4862c',
                 clientSecret: 'dd0a16312a206782cb7669dcec5e96874ab48170',
                 repo: 'lujun9972.github.com',
                 owner: 'lujun9972',
                 admin: ['lujun9972'],
                 id: md5(location.pathname),      // Ensure uniqueness and length less than 50
                 distractionFreeMode: false  // Facebook-like distraction free mode
             })
             gitalk.render('gitalk-container')
            </script>
        </section>
    <script src="https://lujun9972.github.io/emacs-document/media/js/main.js"></script>
    <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 26.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
            Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:lujun9972 &lt;at&gt; T430S">samrayleung</a>
            &nbsp;&nbsp;-&nbsp;&nbsp;
            Powered by <a href="https://github.com/emacs-china/ego" target="_blank">EGO</a><br/>
            <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
            <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
    </div>
            </div>
            <script type="text/javascript"
                    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG">
            </script>
            <script type="text/x-mathjax-config">
             MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });
            </script>
</div>

  </div>
  <!-- https://instant.page/
       Make your site’s pages instant in 1 minute and improve your conversion rate by 1%  -->
  <script src="https://lujun9972.github.io/emacs-document//instant.page/1.1.0" type="module" integrity="sha384-EwBObn5QAxP8f09iemwAJljc+sU+eUXeL9vSBw1eNmVarwhKk2F9vBEpaN9rsrtp"></script>
  </body>
</html>
