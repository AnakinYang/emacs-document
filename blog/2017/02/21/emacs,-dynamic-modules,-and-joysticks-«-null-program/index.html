<!DOCTYPE html>
<html lang="en">
<head>
  <title>Emacs, Dynamic Modules, and Joysticks « null program - EMACS-DOCUMENT</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <meta name="author" content="Travis CI User" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #ds-thread #ds-reset .ds-comment-body p a {color: #ff0;}
   #ds-thread #ds-reset .ds-comment-body p a:hover {color: #0ff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" href="/media/css/main.css" type="text/css"/>
  <link rel="stylesheet" href="/media/css/comment.css" type="text/css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
</head>

  <body><div class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="/">EMACS-DOCUMENT</a></h1>
    <p>=============&gt;随便,谢谢</p>
    <nav class="site-nav">
      <div class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z" fill="#ffff00"/>
          <path d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z" fill="#ffff00"/>
          <path d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z" fill="#ffff00"/>
        </svg>
      </div>
      <ul class="trigger">
        <li><a href="/years/">Years</a></li>
        <li><a href="/authors/">Authors</a></li>
        <li><a href="/tags/">Tags</a></li>
        <li><a href="/about/">About</a></li>
        <li><a href="https://github.com/lujun9972/emacs-document.git">Github</a></li>
        <li><a href="/rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="http://www.google.com/search">
      <input type="text" class="field" name="q" id="s" placeholder="Search">
      <input type="hidden" name="as_sitesearch" value="lujun9972.github.io/emacs-document">
    </form>
  </header>
</div>

<div>
<div class="post">
<h1 class="title">Emacs, Dynamic Modules, and Joysticks « null program</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org26e3189">1. Dynamic Module Types</a></li>
<li><a href="#orgba02a28">2. Module Initialization</a></li>
<li><a href="#org5787701">3. Joystick API</a>
<ul>
<li><a href="#orgca479de">3.1. joymacs-open</a></li>
<li><a href="#org17410d8">3.2. joymacs-close</a></li>
<li><a href="#org6ded8df">3.3. joymacs-read</a></li>
<li><a href="#orgb13505b">3.4. Initialization</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
Two months ago Emacs 25 was released and introduced a <a href="http://diobla.info/blog-archive/modules-tut.html">new dynamic module feature</a>. Emacs can now load shared libraries built against Emacs’
module API, defined in <a href="http://git.savannah.gnu.org/cgit/emacs.git/tree/src/emacs-module.h?h=emacs-25.1">emacs-module.h</a>. What’s interesting about this API is that it doesn’t require linking against Emacs or any sort of
library. Instead, at run time Emacs supplies the module’s initialization function with function pointers for the entire API.
</p>

<p>
As a demonstration, in this article I’ll build an Emacs joystick interface (Linux only) using a dynamic module. It will allow Emacs to
read events from any joystick on the system. All the source code is here:
</p>

<ul class="org-ul">
<li><a href="https://github.com/skeeto/joymacs">https://github.com/skeeto/joymacs</a></li>
</ul>

<p>
It includes a calibration interface (M-x joydemo) within Emacs:
</p>


<div class="figure">
<p><img src="http://nullprogram.com/img/joymacs/joymacs.png" alt="joymacs.png" />
</p>
</div>

<p>
Currently, Emacs’ emacs-module.h header is the entirety of the module documentation. It’s a bit thin and leaves ambiguities that requires
some reading of the Emacs source code. Even reading the source, it’s not clear which behaviors are a reliable part of the interface. For
example, if there’s a pending non-local exit, it’s safe for a function to return NULL since the return value is never inspected (Emacs
25.1), but will this always be the case? While mistakes are unforgiving (a hard crash), the API is mostly intuitive and it’s been pretty
easy to feel my way around it.
</p>

<div id="outline-container-org26e3189" class="outline-2">
<h2 id="org26e3189"><span class="section-number-2">1</span> Dynamic Module Types</h2>
<div class="outline-text-2" id="text-1">
<p>
All Emacs values — integers, floats, cons cells, vectors, strings, etc. — are represented as the polymorphic, pointer-valued type,
emacs<sub>value</sub>. Despite being a pointer, NULL is not a valid value, as convenient as that would be. The API includes functions for creating
and extracting the fundamental types: integers, floats, strings. Almost all other object types can only be accessed by making Lisp
function calls to regular Emacs functions from the module.
</p>

<p>
Modules also introduce a brand new Emacs object type: a user pointer. These are <a href="http://nullprogram.com/blog/2013/12/30/">non-readable</a>, opaque pointer values returned by modules,
typically representing a handle to some resource, be it a memory block, database connection, or a joystick. These objects include a
finalizer function pointer — which, surprisingly, is not permitted to be NULL — and their lifetime is managed by Emacs’ garbage collector.
</p>

<p>
User pointers are a somewhat dangerous feature since there’s little to stop Emacs Lisp code from misusing them. A Lisp program can take a
user pointer from one module and pass it to a function in a different module. Since it’s just a pointer, there’s no way to type check it.
At best, a module could maintain a table of all its live pointers, checking all user pointer arguments against the table before
dereferencing. But I don’t expect this to be normal practice.
</p>
</div>
</div>

<div id="outline-container-orgba02a28" class="outline-2">
<h2 id="orgba02a28"><span class="section-number-2">2</span> Module Initialization</h2>
<div class="outline-text-2" id="text-2">
<p>
After loading the module through the platform’s mechanism, the first thing Emacs does is check for the symbol plugin<sub>is</sub><sub>GPL</sub><sub>compatible</sub>.
While tacky, this is not surprising given the culture around Emacs.
</p>

<p>
Next it calls emacs<sub>module</sub><sub>init</sub>(), passing it the first function pointer. From this, the module can get a Lisp environment and start doing
Emacs things, such as binding module functions to Lisp symbols.
</p>

<p>
Here’s a complete “Hello, world!” example:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">#include</span> <span style="font-style: italic;">"emacs-module.h"</span>

<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">plugin_is_GPL_compatible</span>;

<span style="font-weight: bold; text-decoration: underline;">int</span>
<span style="font-weight: bold;">emacs_module_init</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">emacs_runtime</span> *<span style="font-weight: bold; font-style: italic;">ert</span>)
{
  <span style="font-weight: bold; text-decoration: underline;">emacs_env</span> *<span style="font-weight: bold; font-style: italic;">env</span> = ert-&gt;get_environment(ert);
  <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">message</span> = env-&gt;intern(env, <span style="font-style: italic;">"message"</span>);
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">hi</span>[] = <span style="font-style: italic;">"Hello, world!"</span>;
  <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">string</span> = env-&gt;make_string(env, hi, <span style="font-weight: bold;">sizeof</span>(hi) - 1);
  env-&gt;funcall(env, message, 1, &amp;string);
  <span style="font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
In a real module, it’s common to create function objects for native functions, then fetch the fset symbol and make a Lisp call on it to
bind the newly-created function object to a name. You’ll see this in action later.
</p>
</div>
</div>

<div id="outline-container-org5787701" class="outline-2">
<h2 id="org5787701"><span class="section-number-2">3</span> Joystick API</h2>
<div class="outline-text-2" id="text-3">
<p>
The joystick API will closely resemble <a href="https://www.kernel.org/doc/Documentation/input/joystick-api.txt">Linux’s own joystick API</a>, making for a fairly thin wrapper. It’s so thin that Emacs almost doesn’t
even need a dynamic module. This is because, on Linux, joysticks are just files under <i>dev/input</i>. Want to see the input events on the
first joystick? Just read /dev/input/js0. So Plan 9.
</p>

<p>
Emacs already knows how to read files, but these virtual files are a little too special for that. The header linux/joystick.h defines a
struct js<sub>event</sub>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">js_event</span> {
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">time</span>;  <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">event timestamp in milliseconds</span><span style="font-weight: bold; font-style: italic;"> */</span>
  <span style="font-weight: bold; text-decoration: underline;">int16_t</span> <span style="font-weight: bold; font-style: italic;">value</span>;
  <span style="font-weight: bold; text-decoration: underline;">uint8_t</span> <span style="font-weight: bold; font-style: italic;">type</span>;
  <span style="font-weight: bold; text-decoration: underline;">uint8_t</span> <span style="font-weight: bold; font-style: italic;">number</span>; <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">axis/button number</span><span style="font-weight: bold; font-style: italic;"> */</span>
};
</pre>
</div>

<p>
The idea is to read from the joystick device into this structure. The first several reads are initialization that define the axes and
buttons of the joystick and their initial state. Further events are queued up for the file descriptor. This all means that the file can’t
just be opened each time joystick input is needed. It has to be held open for the duration, and is typically configured non-blocking.
</p>

<p>
The Emacs package will be called joymacs and there will be three functions:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(joymacs-open N)
(joymacs-close JOYSTICK)
(joymacs-read JOYSTICK EVENT-VECTOR)
</pre>
</div>
</div>

<div id="outline-container-orgca479de" class="outline-3">
<h3 id="orgca479de"><span class="section-number-3">3.1</span> joymacs-open</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The joymacs-open function will take an integer, opening the Nth joystick (/dev/input/jsN). It will create a file descriptor for the
joystick device, returning it as a user pointer. Think of it as a sort of “joystick handle.” Now, it could instead return the file
descriptor as an integer, but the user pointer has two significant benefits:
</p>

<ol class="org-ol">
<li>The resource will be garbage collected. If the caller loses track of a file descriptor returned as an integer, the joystick device
will be held open until Emacs shuts down, using up one of Emacs’ file descriptors. By putting it in a user pointer, the garbage
collector will have the module to release the file descriptor if the user loses track of it.</li>

<li>It should be difficult for the user to make a dangerous call. Emacs Lisp can’t create user pointers — they only come from modules —
and so the module is less likely to get passed the wrong thing. In the case of joystick-close, the module will be calling close(2) on
the argument. We definitely don’t want to make that system call on file descriptors owned by Emacs. Further, since user pointers are
mutable, the module can ensure it doesn’t call close(2) twice.</li>
</ol>

<p>
Here’s the implementation for joymacs-open. I’ll over over each part in detail.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">emacs_value</span>
<span style="font-weight: bold;">joymacs_open</span>(<span style="font-weight: bold; text-decoration: underline;">emacs_env</span> *<span style="font-weight: bold; font-style: italic;">env</span>, <span style="font-weight: bold; text-decoration: underline;">ptrdiff_t</span> <span style="font-weight: bold; font-style: italic;">n</span>, <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> *<span style="font-weight: bold; font-style: italic;">args</span>, <span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">ptr</span>)
{
  (<span style="font-weight: bold; text-decoration: underline;">void</span>)ptr;
  (<span style="font-weight: bold; text-decoration: underline;">void</span>)n;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">id</span> = env-&gt;extract_integer(env, args[0]);
  <span style="font-weight: bold;">if</span> (env-&gt;non_local_exit_check(env) != emacs_funcall_exit_return)
    <span style="font-weight: bold;">return</span> nil;
  <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">buf</span>[64];
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">buflen</span> = sprintf(buf, <span style="font-style: italic;">"/dev/input/js%d"</span>, id);
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span> = open(buf, O_RDONLY | O_NONBLOCK);
  <span style="font-weight: bold;">if</span> (fd == -1) {
    <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">signal</span> = env-&gt;intern(env, <span style="font-style: italic;">"file-error"</span>);
    <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">message</span> = env-&gt;make_string(env, buf, buflen);
    env-&gt;non_local_exit_signal(env, signal, message);
    <span style="font-weight: bold;">return</span> nil;
  }
  <span style="font-weight: bold;">return</span> env-&gt;make_user_ptr(env, fin_close, (<span style="font-weight: bold; text-decoration: underline;">void</span> *)(<span style="font-weight: bold; text-decoration: underline;">intptr_t</span>)fd);
}
</pre>
</div>

<p>
The C function name doesn’t matter to Emacs. It’s static because it doesn’t even matter if the function visible to Emacs. It will get the
function pointer later as part of initialization.
</p>

<p>
This is the prototype for all functions callable by Emacs Lisp, regardless of its arity. It has four arguments:
</p>

<ol class="org-ol">
<li>It gets an environment, env, through which to call back into Emacs.</li>

<li>It gets n, the number of arguments. This is guaranteed to be the correct number of arguments, as specified later when creating the
function object, so only variadic functions need to inspect this argument.</li>

<li>The Lisp arguments are passed as an array of values, args. There’s no type declaration when declaring a function object, so these may
be of the wrong type. I’ll go over how to deal with this.</li>

<li>Finally, it gets an arbitrary pointer, supplied at function object creation time. This allows the module to create closures, but will
usually be ignored.</li>
</ol>

<p>
The first thing the function does is extract its integer argument. This is actually an intmax<sub>t</sub>, but I don’t think anyone has that many
USB ports. An int will suffice.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">id</span> = env-&gt;extract_integer(env, args[0]);
<span style="font-weight: bold;">if</span> (env-&gt;non_local_exit_check(env) != emacs_funcall_exit_return)
  <span style="font-weight: bold;">return</span> nil;
</pre>
</div>

<p>
As for not underestimating fools, what if the user passed a value that isn’t an integer? Will the world come crashing down? Fortunately
Emacs checks that in extract<sub>integer</sub> and, if there’s a mismatch, sets a pending error signal in the environment. This is really great
because checking types directly in the module is a real pain the ass. So, before committing to anything further, such as opening a file, I
check for this signal and bail out early if necessary. In Emacs 25.1 it’s safe to return NULL since the return value will be completely
ignored, but I’d rather hedge my bets.
</p>

<p>
By the way, the nil here is a global variable set in initialization. You don’t just get that for free!
</p>

<p>
The next step is opening the joystick device, read-only and non-blocking. The non-blocking is vital because the module would otherwise
hang Emacs later if there are no events (well, except for the read being quickly interrupted by a POSIX signal).
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">buf</span>[64];
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">buflen</span> = sprintf(buf, <span style="font-style: italic;">"/dev/input/js%d"</span>, id);
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span> = open(buf, O_RDONLY | O_NONBLOCK);
</pre>
</div>

<p>
If the joystick fails to open (e.g. it doesn’t exist, or the user lacks permission), manually set an error signal for a non-local exit. I
chose the file-error signal and I’m just using the filename as the signal data.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">if</span> (fd == -1) {
  <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">signal</span> = env-&gt;intern(env, <span style="font-style: italic;">"file-error"</span>);
  <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">message</span> = env-&gt;make_string(env, buf, buflen);
  env-&gt;non_local_exit_signal(env, signal, message);
  <span style="font-weight: bold;">return</span> nil;
 }
</pre>
</div>

<p>
Otherwise create the user pointer. No need to allocate any memory; just stuff it in the pointer itself. If the user mistakenly passes it
to another module, it will sure be in for a surprise when it tries to dereference it.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">return</span> env-&gt;make_user_ptr(env, fin_close, (<span style="font-weight: bold; text-decoration: underline;">void</span> *)(<span style="font-weight: bold; text-decoration: underline;">intptr_t</span>)fd);
</pre>
</div>

<p>
The fin<sub>close</sub>() function is defined as:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span>
<span style="font-weight: bold;">fin_close</span>(<span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">fdptr</span>)
{
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span> = (<span style="font-weight: bold; text-decoration: underline;">intptr_t</span>)fdptr;
  <span style="font-weight: bold;">if</span> (fd != -1)
    close(fd);
}
</pre>
</div>

<p>
The garbage collector will call this function when the user pointer is lost. If the user closes it early with joymacs-close, that function
will set the user pointer to -1, an invalid file descriptor, so that it doesn’t get closed a second time here.
</p>
</div>
</div>

<div id="outline-container-org17410d8" class="outline-3">
<h3 id="org17410d8"><span class="section-number-3">3.2</span> joymacs-close</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Here’s joymacs-close, which is a bit simpler.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">emacs_value</span>
<span style="font-weight: bold;">joymacs_close</span>(<span style="font-weight: bold; text-decoration: underline;">emacs_env</span> *<span style="font-weight: bold; font-style: italic;">env</span>, <span style="font-weight: bold; text-decoration: underline;">ptrdiff_t</span> <span style="font-weight: bold; font-style: italic;">n</span>, <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> *<span style="font-weight: bold; font-style: italic;">args</span>, <span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">ptr</span>)
{
  (<span style="font-weight: bold; text-decoration: underline;">void</span>)ptr;
  (<span style="font-weight: bold; text-decoration: underline;">void</span>)n;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span> = (<span style="font-weight: bold; text-decoration: underline;">intptr_t</span>)env-&gt;get_user_ptr(env, args[0]);
  <span style="font-weight: bold;">if</span> (env-&gt;non_local_exit_check(env) != emacs_funcall_exit_return)
    <span style="font-weight: bold;">return</span> nil;
  <span style="font-weight: bold;">if</span> (fd != -1) {
    close(fd);
    env-&gt;set_user_ptr(env, args[0], (<span style="font-weight: bold; text-decoration: underline;">void</span> *)(<span style="font-weight: bold; text-decoration: underline;">intptr_t</span>)-1);
  }
  <span style="font-weight: bold;">return</span> nil;
}
</pre>
</div>

<p>
Again, it starts by extracting its argument, relying on Emacs to do the check:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span> = (<span style="font-weight: bold; text-decoration: underline;">intptr_t</span>)env-&gt;get_user_ptr(env, args[0]);
<span style="font-weight: bold;">if</span> (env-&gt;non_local_exit_check(env) != emacs_funcall_exit_return)
  <span style="font-weight: bold;">return</span> nil;
</pre>
</div>

<p>
If the user pointer hasn’t been closed yet, then close it and strip out the file descriptor to prevent further closes.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">if</span> (fd != -1) {
  close(fd);
  env-&gt;set_user_ptr(env, args[0], (<span style="font-weight: bold; text-decoration: underline;">void</span> *)(<span style="font-weight: bold; text-decoration: underline;">intptr_t</span>)-1);
 }
</pre>
</div>
</div>
</div>

<div id="outline-container-org6ded8df" class="outline-3">
<h3 id="org6ded8df"><span class="section-number-3">3.3</span> joymacs-read</h3>
<div class="outline-text-3" id="text-3-3">
<p>
The joymacs-read function is doing something a little unusual for an Emacs Lisp function. It takes two arguments: the joystick handle and
a 5-element vector. Instead of returning the event in some representation, it fills the vector with the event details. The are two reasons
for this:
</p>

<ol class="org-ol">
<li>The API has no function for creating vectors … though the module could get the make-symbol vector and call it to create a vector.</li>

<li>The idiom for event pumps is for the caller to supply a buffer to the pump. This has better performance by avoiding lots of
unnecessary allocations, especially since events tend to be message-like objects with a short, well-defined extent.</li>
</ol>

<p>
Here’s the full definition:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">emacs_value</span>
<span style="font-weight: bold;">joymacs_read</span>(<span style="font-weight: bold; text-decoration: underline;">emacs_env</span> *<span style="font-weight: bold; font-style: italic;">env</span>, <span style="font-weight: bold; text-decoration: underline;">ptrdiff_t</span> <span style="font-weight: bold; font-style: italic;">n</span>, <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> *<span style="font-weight: bold; font-style: italic;">args</span>, <span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">ptr</span>)
{
    (<span style="font-weight: bold; text-decoration: underline;">void</span>)n;
    (<span style="font-weight: bold; text-decoration: underline;">void</span>)ptr;
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span> = (<span style="font-weight: bold; text-decoration: underline;">intptr_t</span>)env-&gt;get_user_ptr(env, args[0]);
    <span style="font-weight: bold;">if</span> (env-&gt;non_local_exit_check(env) != emacs_funcall_exit_return)
        <span style="font-weight: bold;">return</span> nil;
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">js_event</span> <span style="font-weight: bold; font-style: italic;">e</span>;
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">r</span> = read(fd, &amp;e, <span style="font-weight: bold;">sizeof</span>(e));
    <span style="font-weight: bold;">if</span> (r == -1 &amp;&amp; errno == EAGAIN) {
        <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">No more events.</span><span style="font-weight: bold; font-style: italic;"> */</span>
        <span style="font-weight: bold;">return</span> nil;
    } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (r == -1) {
        <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">An actual read error (joystick unplugged, etc.).</span><span style="font-weight: bold; font-style: italic;"> */</span>
        <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">signal</span> = env-&gt;intern(env, <span style="font-style: italic;">"file-error"</span>);
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span> *<span style="font-weight: bold; font-style: italic;">error</span> = strerror(errno);
        <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">len</span> = strlen(error);
        <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">message</span> = env-&gt;make_string(env, error, len);
        env-&gt;non_local_exit_signal(env, signal, message);
        <span style="font-weight: bold;">return</span> nil;
    } <span style="font-weight: bold;">else</span> {
        <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">Fill out event vector.</span><span style="font-weight: bold; font-style: italic;"> */</span>
        <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">v</span> = args[1];
        <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">type</span> = e.type &amp; JS_EVENT_BUTTON ? button : axis;
        <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">value</span>;
        <span style="font-weight: bold;">if</span> (type == button)
            value = e.value ? t : nil;
        <span style="font-weight: bold;">else</span>
            value =  env-&gt;make_float(env, e.value / (<span style="font-weight: bold; text-decoration: underline;">double</span>)INT16_MAX);
        env-&gt;vec_set(env, v, 0, env-&gt;make_integer(env, e.time));
        env-&gt;vec_set(env, v, 1, type);
        env-&gt;vec_set(env, v, 2, value);
        env-&gt;vec_set(env, v, 3, env-&gt;make_integer(env, e.number));
        env-&gt;vec_set(env, v, 4, e.type &amp; JS_EVENT_INIT ? t : nil);
        <span style="font-weight: bold;">return</span> args[1];
    }
}
</pre>
</div>

<p>
As before, extract the first argument and check for a signal. Then call read(2) to get an event. If the read fails with EAGAIN, it’s not a
real failure. There are just no more events, so return nil.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">js_event</span> <span style="font-weight: bold; font-style: italic;">e</span>;
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">r</span> = read(fd, &amp;e, <span style="font-weight: bold;">sizeof</span>(e));
<span style="font-weight: bold;">if</span> (r == -1 &amp;&amp; errno == EAGAIN) {
  <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">No more events.</span><span style="font-weight: bold; font-style: italic;"> */</span>
  <span style="font-weight: bold;">return</span> nil;
 }
</pre>
</div>

<p>
If the read failed with something else — perhaps the joystick was unplugged — signal an error. The strerror(3) string is used for the
signal data.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">if</span> (r == -1) {
  <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">An actual read error (joystick unplugged, etc.).</span><span style="font-weight: bold; font-style: italic;"> */</span>
  <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">signal</span> = env-&gt;intern(env, <span style="font-style: italic;">"file-error"</span>);
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span> *<span style="font-weight: bold; font-style: italic;">error</span> = strerror(errno);
  <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">message</span> = env-&gt;make_string(env, error, strlen(error));
  env-&gt;non_local_exit_signal(env, signal, message);
  <span style="font-weight: bold;">return</span> nil;
 }
</pre>
</div>

<p>
Otherwise fill out the event vector. If the second argument isn’t a vector, or if it’s too short, the signal will automatically get raised
by Emacs. The module can keep plowing through the vec<sub>set</sub>() calls safely since it’s not committing to anything.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">Fill out event vector.</span><span style="font-weight: bold; font-style: italic;"> */</span>
<span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">v</span> = args[1];
<span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">type</span> = e.type &amp; JS_EVENT_BUTTON ? button : axis;
<span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">value</span>;
<span style="font-weight: bold;">if</span> (type == button)
  value = e.value ? t : nil;
 <span style="font-weight: bold;">else</span>
   value =  env-&gt;make_float(env, e.value / (<span style="font-weight: bold; text-decoration: underline;">double</span>)INT16_MAX);
env-&gt;vec_set(env, v, 0, env-&gt;make_integer(env, e.time));
env-&gt;vec_set(env, v, 1, type);
env-&gt;vec_set(env, v, 2, value);
env-&gt;vec_set(env, v, 3, env-&gt;make_integer(env, e.number));
env-&gt;vec_set(env, v, 4, e.type &amp; JS_EVENT_INIT ? t : nil);
<span style="font-weight: bold;">return</span> args[1];
</pre>
</div>

<p>
The Linux event struct has four fields and the function fills out five values of the vector. This is because the type field has a bit flag
indicating initialization events. This is split out into an extra t/nil value. It also normalizes axis values and converts button values
into t/nil, which makes more sense for Emacs Lisp. The event itself is returned since it’s a truthy value and it’s convenient for the
caller.
</p>

<p>
The astute programmer might notice that the negative side of the axis could go just below -1.0, since INT16<sub>MIN</sub> has one extra value over
INT16<sub>MAX</sub> (two’s complement). It doesn’t seem to be documented, but the joystick drivers I’ve seen never exactly return INT16<sub>MIN</sub>, so this
is in fact the correct way to normalize it.
</p>
</div>
</div>

<div id="outline-container-orgb13505b" class="outline-3">
<h3 id="orgb13505b"><span class="section-number-3">3.4</span> Initialization</h3>
<div class="outline-text-3" id="text-3-4">
<p>
All that’s left is the initialization function. First declare some global variables to keep track of frequently-used symbols.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">nil</span>;
<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">t</span>;
<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">button</span>;
<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">axis</span>;
</pre>
</div>

<p>
These are interned at the very beginning of initialization. The symbols :button and :axis are given global references so that the garbage
collector doesn’t rip them out from under the module. It’s unclear from the API, but the make<sub>global</sub><sub>ref</sub>() function returns the object
being referenced. I trust that the t and nil symbols will never be garbage collected, so these don’t need global references.
</p>

<div class="org-src-container">
<pre class="src src-c">nil = env-&gt;intern(env, <span style="font-style: italic;">"nil"</span>);
t = env-&gt;intern(env, <span style="font-style: italic;">"t"</span>);
button = env-&gt;make_global_ref(env, env-&gt;intern(env, <span style="font-style: italic;">":button"</span>));
axis = env-&gt;make_global_ref(env, env-&gt;intern(env, <span style="font-style: italic;">":axis"</span>));

<span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">fset</span> = env-&gt;intern(env, <span style="font-style: italic;">"fset"</span>);
</pre>
</div>

<p>
It also grabs <code>fset</code> locally since it will soon be needed.
</p>

<p>
Finally, bind the functions. The second and third arguments to make<sub>function</sub> are the minimum and maximum number of arguments, which <a href="http://nullprogram.com/blog/2014/01/04/">may</a>
<a href="http://nullprogram.com/blog/2014/01/04/">look familiar</a>. The last argument is that closure pointer I mentioned at the beginning.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">args</span>[2];
<span style="font-weight: bold; text-decoration: underline;">args</span>[0] = env-&gt;intern(env, <span style="font-style: italic;">"joymacs-open"</span>);
<span style="font-weight: bold; text-decoration: underline;">args</span>[1] = env-&gt;make_function(env, 1, 1, joymacs_open, doc, 0);
env-&gt;funcall(env, fset, 2, args);
</pre>
</div>

<p>
If the module is to be loaded with require like any other package, it needs to provide: (provide 'joymacs).
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">provide</span> = env-&gt;intern(env, <span style="font-style: italic;">"provide"</span>);
<span style="font-weight: bold; text-decoration: underline;">emacs_value</span> <span style="font-weight: bold; font-style: italic;">joymacs</span> = env-&gt;intern(env, <span style="font-style: italic;">"joymacs"</span>);
env-&gt;funcall(env, provide, 1, &amp;joymacs);
</pre>
</div>

<p>
And that’s it!
</p>

<p>
The source repository now includes a port to Windows (XInput). If you’re on Linux or Windows, have Emacs 25 with modules enabled, and a
joystick is plugged in, then make run in the repository should bring up Emacs running a joystick calibration demonstration. The module
can’t poke at Emacs when events are ready, so instead there’s a timer that polls the module for events.
</p>

<p>
I’d like to someday see an Emacs Lisp game well-suited for a joystick.
</p>
</div>
</div>
</div>

</div>
</div>
<div>
        <div class="post-meta">
            <span title="post date" class="post-info">2019-04-26</span>
            <span title="last modification date" class="post-info">2017-02-21</span>
            <span title="tags" class="post-info">:N/A:</span>
            <span title="author" class="post-info"><a href="mailto:travis &lt;at&gt; travis-job-c7de1c50-88ed-412e-ae70-62694dd7dea5">Travis CI User</a></span>
        </div>
    <script src="/media/js/jquery-2.1.3.min.js"></script>
        <section>
            <h1>Comments</h1>
            <div id="comment-wrap">
                    <a class="disqus_label">使用 Disqus 评论</a>
    </ul>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
         //var disqus_developer = 1;
         var preempt_signal=false;
         var disqus_identifier = "/blog/2019/04/26/emacs,-dynamic-modules,-and-joysticks-«-null-program/";
         var disqus_url = "https://lujun9972.github.io/emacs-document/blog/2019/04/26/emacs,-dynamic-modules,-and-joysticks-«-null-program/";
         var disqus_shortname = 'emacs-document';
         /* * * DON'T EDIT BELOW THIS LINE * * */
         (function() {
             var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
             dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
             (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
             $('#disqus_thread').css('display','none');
         })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    <script>
     /* comments */
     var ego_disqus_thread=$('#disqus_thread');
     var ego_ds_label=$('.ds-thread');
     $('.disqus_label').click(function(){
         ego_disqus_thread.show();
         ego_ds_label.hide();
     });
     $('.ds-label').click(function(){
         ego_disqus_thread.hide();
         ego_ds_label.show();
     });
    </script>
        </section>
    <script src="/media/js/main.js"></script>
        <script type="text/javascript">
         var _gaq = _gaq || [];
         _gaq.push(['_setAccount', '7bac4fd0247f69c27887e0d4e3aee41e']);
         _gaq.push(['_trackPageview']);
         (function() {
             var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
             ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
             var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
         })();
        </script>
    <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 27.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
            Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:travis &lt;at&gt; travis-job-c7de1c50-88ed-412e-ae70-62694dd7dea5">Travis CI User</a>
            &nbsp;&nbsp;-&nbsp;&nbsp;
            Powered by <a href="https://github.com/emacs-china/ego" target="_blank">EGO</a><br/>
            <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
            <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
    </div>
            </div>
            <script type="text/javascript"
                    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG">
            </script>
            <script type="text/x-mathjax-config">
             MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });
            </script>
</div>

  </div>
  <!-- https://instant.page/
       Make your site’s pages instant in 1 minute and improve your conversion rate by 1%  -->
  <script src="//instant.page/1.1.0" type="module" integrity="sha384-EwBObn5QAxP8f09iemwAJljc+sU+eUXeL9vSBw1eNmVarwhKk2F9vBEpaN9rsrtp"></script>
  </body>
</html>
