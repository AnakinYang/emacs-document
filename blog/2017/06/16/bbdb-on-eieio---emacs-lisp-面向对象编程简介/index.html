<!DOCTYPE html>
<html lang="en">
<head>
  <title>BBDB on EIEIO - Emacs Lisp 面向对象编程简介 - EMACS-DOCUMENT</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <meta name="author" content="LdBeth" />
  <!-- <link rel="stylesheet" href="https://lujun9972.github.io/emacs-document/media/css/main.css" type="text/css"/>
       <link rel="stylesheet" href="https://lujun9972.github.io/emacs-document/media/css/comment.css" type="text/css"/> -->
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/dark.css'>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
</head>

  <body><div class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="https://lujun9972.github.io/emacs-document/">EMACS-DOCUMENT</a></h1>
    <p>=============&gt;集思广益</p>
    <nav class="site-nav">
      <ul class="trigger">
        <li><a href="https://lujun9972.github.io/emacs-document/years/">Years</a></li>
        <li><a href="https://lujun9972.github.io/emacs-document/authors/">Authors</a></li>
        <li><a href="https://lujun9972.github.io/emacs-document/tags/">Tags</a></li>
        <li><a href="https://lujun9972.github.io/emacs-document/about/">About</a></li>
        <li><a href="https://github.com/lujun9972/emacs-document">Github</a></li>
        <li><a href="https://lujun9972.github.io/emacs-document/rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="https://www.bing.com/search">
      <input type="text" class="field" name="q" id="s" placeholder="Search">
      <input type="hidden" name="as_sitesearch" value="lujun9972.github.io/emacs-document">
    </form>
  </header>
</div>

<div>
<div class="post">
<h1 class="title">BBDB on EIEIO - Emacs Lisp 面向对象编程简介</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org725c692">1. 为什么重写？</a></li>
<li><a href="#org5083d93">2. 基本知识</a></li>
<li><a href="#org75029a8">3. 类和广义函数</a></li>
<li><a href="#orga1e2671">4. 传递多个消息</a></li>
<li><a href="#orgc8eace4">5. 方法组成</a></li>
<li><a href="#orgfed1d49">6. 修饰符</a></li>
<li><a href="#org69642a8">7. 现有问题</a></li>
</ul>
</div>
</div>
<p>
BBDB on EIEIO – An Introduction to Object-Oriented Emacs Lisp
</p>

<p>
这是 EBDB，即 EIEIO 重构 BBDB 的简要介绍。
</p>

<blockquote>
<p>
这是什么意思？
</p>
</blockquote>

<p>
BBDB，即 <a href="http://savannah.nongnu.org/projects/bbdb/">insidious Big Brother DataBase</a>，Emacs 的主流信息管理／地址簿扩展包。
<a href="https://www.gnu.org/software/emacs/manual/html_mono/eieio.html">EIEIO</a> 则很显然是 “Enhanced Implementation of Emacs Interpreted Objects” 的缩写，
也就是 Emacs Lisp 版本的 Common Lisp <a href="https://www.gnu.org/software/emacs/manual/html_mono/eieio.html">CLOS</a>, Common Lisp Object System。因此 EBDB
就是 “Enhanced implementation of emacs interpreted objects/common lisp object
system version of the insidious big Brother DataBase“。
</p>

<div id="outline-container-org725c692" class="outline-2">
<h2 id="org725c692"><span class="section-number-2">1</span> 为什么重写？</h2>
<div class="outline-text-2" id="text-1">
<p>
为什么要这样呢？有两个原因：首先是面向对象系统很适合数据库，BBDB 能用子类做更多
扩展；其次是为了练习使用 EIEIO。
</p>
</div>
</div>

<div id="outline-container-org5083d93" class="outline-2">
<h2 id="org5083d93"><span class="section-number-2">2</span> 基本知识</h2>
<div class="outline-text-2" id="text-2">
<blockquote>
<p>
译者注：下面的例子中，类 = class，方法 = method，消息传递／分发 = dispatch，多重分发 = multiple dispatch。
</p>
</blockquote>

<p>
EBDB 中有三个主类：
</p>

<ol class="org-ol">
<li>数据库（Database），用于保存记录</li>
<li>记录项目（Records），代表人或组织</li>
<li>字段（Fields），代表记载的数据，如 E-mail 地址或电话号码。</li>
</ol>

<p>
每个类都包含众多实例，以及可供第三方扩展的空间。主要思想就是将主要框架尽可能用类
进行抽象：那些类本身已经代表了几乎所有的行为，并从用户的配置中接受基本消息。相当
标准的面向对象项目。不过，CLOS/EIEIO 在底层和其它的面向对象系统完全不同。
</p>
</div>
</div>

<div id="outline-container-org75029a8" class="outline-2">
<h2 id="org75029a8"><span class="section-number-2">3</span> 类和广义函数</h2>
<div class="outline-text-2" id="text-3">
<p>
作为一个自以为是的 Lisp 粉，我目前只能给出一个蹩脚的例子：传递多个消息的通用方
法。我想 <a href="http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html">Peter Seibel</a> (Pratical Common Lisp) 对 Lisp 面向对象编程的解释已经很
好了，不过如果你懒得读它，我可以简要解释一下：Lisp 的面向对象把方法作为最顶层
的对象（我很好奇它是不是从别的语言里借鉴了一些思想）（译者：Lisp 的确从
Smalltalk 借鉴了面向对象思想）。它们不再从属于类，而是像普通的函数一样。用
Python 你或许会写：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">ThingOne</span><span style="color: #4f97d7;">()</span>:

    <span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">self</span><span style="color: #4f97d7;">)</span>:
        <span style="color: #4f97d7; font-weight: bold;">print</span><span style="color: #4f97d7;">(</span><span style="color: #2d9574;">"calling thing one foo on %s"</span> % <span style="color: #4f97d7; font-weight: bold;">self</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">ThingTwo</span><span style="color: #4f97d7;">()</span>:

    <span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">self</span><span style="color: #4f97d7;">)</span>:
        <span style="color: #4f97d7; font-weight: bold;">print</span><span style="color: #4f97d7;">(</span><span style="color: #2d9574;">"calling thing two foo on %s"</span> % <span style="color: #4f97d7; font-weight: bold;">self</span><span style="color: #4f97d7;">)</span>

ThingOne<span style="color: #4f97d7;">()</span>.foo<span style="color: #4f97d7;">()</span>
ThingTwo<span style="color: #4f97d7;">()</span>.foo<span style="color: #4f97d7;">()</span>
</pre>
</div>

<p>
在 Lisp 中你会把等价的实现写成：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">defclass</span> <span style="color: #ce537a; font-weight: bold;">thing-one</span> <span style="color: #bc6ec5;">()</span>
  nil<span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">defclass</span> <span style="color: #ce537a; font-weight: bold;">thing-two</span> <span style="color: #bc6ec5;">()</span>
  nil<span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>obj thing-one<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>message <span style="color: #2d9574;">"calling thing one foo on %s"</span> obj<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>obj thing-two<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>message <span style="color: #2d9574;">"calling thing two foo on %s"</span> obj<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span>foo <span style="color: #bc6ec5;">(</span>make-instance 'thing-one<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>foo <span style="color: #bc6ec5;">(</span>make-instance 'thing-two<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
注意，两者之间唯一的差别就是 <code>cl-defmethod</code> 的定义是顶层的。它和类的唯一关心
在于它需要将一个类作为第一个参数。
</p>

<p>
这暗示着方法是和类相分离的。广义函数不止基于所指定的类，也基于参数的种类来传
递消息。它们甚至可以在没有指定类的情况下使用：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">type-test</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>arg string<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>message <span style="color: #2d9574;">"I was called with string argument %s"</span> arg<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">type-test</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>arg integer<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>message <span style="color: #2d9574;">"I was called with integer argument %d"</span> arg<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">type-test</span> <span style="color: #bc6ec5;">(</span>arg<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>message <span style="color: #2d9574;">"I don't know what %s is"</span> arg<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
最后一个是个“捕捉全部”的方法定义。在“常规”的 Emacs Lisp 中，你会用一个
<code>cond</code> 来实现类似的事：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">defun</span> <span style="color: #bc6ec5; font-weight: bold;">type-test</span> <span style="color: #bc6ec5;">(</span>arg<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">cond</span> <span style="color: #2d9574;">(</span><span style="color: #67b11d;">(</span>stringp arg<span style="color: #67b11d;">)</span>
         <span style="color: #67b11d;">(</span>message <span style="color: #2d9574;">"I was called with string argument %s"</span> arg<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
        <span style="color: #2d9574;">(</span><span style="color: #67b11d;">(</span>integerp arg<span style="color: #67b11d;">)</span>
         <span style="color: #67b11d;">(</span>message <span style="color: #2d9574;">"I was called with integer argument %d"</span> arg<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
        <span style="color: #2d9574;">(</span>t <span style="color: #67b11d;">(</span>message <span style="color: #2d9574;">"I don't know what %s is"</span> arg<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
完全等价，和面向对象方法唯一的区别在于你可以在任何地方进行定义一个方法。
</p>
</div>
</div>

<div id="outline-container-orga1e2671" class="outline-2">
<h2 id="orga1e2671"><span class="section-number-2">4</span> 传递多个消息</h2>
<div class="outline-text-2" id="text-4">
<p>
所以：方法是顶层的东西，能根据参数给出具体的定义，也能接受多个参数。结果就是你
能得到基于建立在多个对象上的类来决定行为的方法，也就是“多重分发“，看起来就像
这样：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">bar</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>obj1 thing-one<span style="color: #2d9574;">)</span>
                   <span style="color: #2d9574;">(</span>obj2 thing-two<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>message <span style="color: #2d9574;">"bar called with thing-one %s and thing-two %s"</span> obj1 obj2<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
方法能通过检验一定数量的参数所属的类，数据类型，或者其它的技巧来发送消息。特化
程度高的参数特化符能覆盖特化程度低的特化符。
</p>

<p>
EBDB 在所有地方都用“多重分发”，比如，在编辑一个项目里的字段的时候。当用户按
下 <code>e</code> 来开始编辑的时候，最终导致如下方法被调用（当然，是简化过的）：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">ebdb-record-change-field</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>record ebdb-record<span style="color: #2d9574;">)</span>
                                        <span style="color: #2d9574;">(</span>old-field ebdb-field<span style="color: #2d9574;">)</span>
                                        <span style="color: #ce537a; font-weight: bold;">&amp;optional</span> new-field<span style="color: #bc6ec5;">)</span>
  <span style="color: #2aa1ae;">"Change the value of FIELD belonging to RECORD."</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">let*</span> <span style="color: #2d9574;">(</span><span style="color: #67b11d;">(</span>fieldclass <span style="color: #b1951d;">(</span>eieio-object-class old-field<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span>
         <span style="color: #67b11d;">(</span>new-field <span style="color: #b1951d;">(</span><span style="color: #4f97d7; font-weight: bold;">or</span> new-field <span style="color: #4f97d7;">(</span>ebdb-read fieldclass nil old-field<span style="color: #4f97d7;">)</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span>ebdb-record-delete-field record old-field<span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span>ebdb-record-insert-field record new-field<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
由于 <code>ebdb-record</code> 和 <code>ebdb-field</code> 都是底层基本类，这个调用对数据库的所有内容
都起作用。新的字段被读取，旧的字段作为默认值，新字段代替旧字段。这个代码不懂任
何记录或字段，只在产生新字段的时候调用 <code>ebdb-read</code> ，然后用
<code>ebdb-record-insert-field</code> 加入记录。
</p>

<p>
当然实际操作是更加复杂的。
</p>

<p>
比如，个人记录会有“职位”字段在组织记录里。职位包括一个标签，一个电子邮件地址，
以及一定数量的其它字段。在这个数据库中，职位保存在个人记录的插槽里。但是当你想
看一个组织的信息时，你或许也会想看有多少人在那里有职位，对吧？所以在显示组织的
时候，哈希表被用来逆向查找，并把职位作为组织的一个子项目来展示。
</p>

<p>
当职位字段在组织记录中显示的时候，用户或许会想编辑它们。从实际上讲职位字段并不
属于组织，所以这时候需要用一些特殊技巧了：我们需要写一个特例来处理这样的情况。
这其实很简单，加个方法的事儿嘛：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">ebdb-record-change-field</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>org ebdb-record-organization<span style="color: #2d9574;">)</span>
                                        <span style="color: #2d9574;">(</span>old-field ebdb-field-role<span style="color: #2d9574;">)</span>
                                        <span style="color: #ce537a; font-weight: bold;">&amp;optional</span> new-field<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">let</span> <span style="color: #2d9574;">(</span><span style="color: #67b11d;">(</span>person <span style="color: #b1951d;">(</span>ebdb-gethash <span style="color: #4f97d7;">(</span>slot-value old-field 'record-uuid<span style="color: #4f97d7;">)</span> 'uuid<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span>cl-call-next-method person old-field new-field<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
我们用更加具体的记录和字段子类来做特化参数符，所以这个方法只在编辑组织记录里的
职位字段的时候起作用。这个方法查找职位记录实际从属的个人记录，从组织切换到个人
记录，然后用 <code>cl-call-next-method</code> （Python super 的 Lisp 等价）来把参数传递给
通用方法。
</p>

<p>
我对这能成功起作用感到吃惊。调用方法顶部的代码把组织当作要编辑的记录：这改变了
运行的钩子（Hook），然后在编辑完成后刷新显示。而底部的代码认为个人是要修改的记
录：插槽变了，相应的数据库也更改了。
</p>
</div>
</div>

<div id="outline-container-orgc8eace4" class="outline-2">
<h2 id="orgc8eace4"><span class="section-number-2">5</span> 方法组成</h2>
<div class="outline-text-2" id="text-5">
<p>
调用一摞从子类到父类的方法是常见的过程，而且 EBDB 确实也经常用
<code>ebdb-record-field-slot-query</code> 来这样做。比如，这里就有一个简化过的
<code>ebdb-record-field-slot-query</code> 方法，用于分辨一个字段在哪个插槽里。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">ebdb-record-field-slot-query</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>class <span style="color: #67b11d;">(</span>subclass ebdb-record-person<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
                                            <span style="color: #ce537a; font-weight: bold;">&amp;optional</span> query alist<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>cl-call-next-method
   class
   query
   <span style="color: #2d9574;">(</span>append
    '<span style="color: #67b11d;">(</span><span style="color: #b1951d;">(</span>aka . ebdb-field-name-complex<span style="color: #b1951d;">)</span>
      <span style="color: #b1951d;">(</span>relations . ebdb-field-relation<span style="color: #b1951d;">)</span>
      <span style="color: #b1951d;">(</span>organizations . ebdb-field-role<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span>
    alist<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">ebdb-record-field-slot-query</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>class <span style="color: #67b11d;">(</span>subclass ebdb-record-entity<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
                                            <span style="color: #ce537a; font-weight: bold;">&amp;optional</span> query alist<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>cl-call-next-method
   class
   query
   <span style="color: #2d9574;">(</span>append
    `<span style="color: #67b11d;">(</span><span style="color: #b1951d;">(</span>mail . ebdb-field-mail<span style="color: #b1951d;">)</span>
      <span style="color: #b1951d;">(</span>phone . ebdb-field-phone<span style="color: #b1951d;">)</span>
      <span style="color: #b1951d;">(</span>address . ebdb-field-address<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span>
    alist<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">ebdb-record-field-slot-query</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>class <span style="color: #67b11d;">(</span>subclass ebdb-record<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
                                            <span style="color: #ce537a; font-weight: bold;">&amp;optional</span> query alist<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">let</span> <span style="color: #2d9574;">(</span><span style="color: #67b11d;">(</span>alist <span style="color: #b1951d;">(</span>append
                '<span style="color: #4f97d7;">(</span><span style="color: #bc6ec5;">(</span>notes . ebdb-field-notes<span style="color: #bc6ec5;">)</span>
                  <span style="color: #bc6ec5;">(</span>image . ebdb-field-image<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
                alist<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">pcase</span> query
      <span style="color: #67b11d;">(</span>`<span style="color: #b1951d;">(</span>nil . ,class<span style="color: #b1951d;">)</span>
       <span style="color: #b1951d;">(</span><span style="color: #4f97d7; font-weight: bold;">or</span> <span style="color: #4f97d7;">(</span>rassq class alist<span style="color: #4f97d7;">)</span>
           <span style="color: #4f97d7;">(</span><span style="color: #dc752f; background-color: #292b2e;">signal</span> 'ebdb-unacceptable-field <span style="color: #bc6ec5;">(</span>list class<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span>
      <span style="color: #67b11d;">(</span>`<span style="color: #b1951d;">(</span>,slot . nil<span style="color: #b1951d;">)</span>
       <span style="color: #b1951d;">(</span><span style="color: #4f97d7; font-weight: bold;">or</span> <span style="color: #4f97d7;">(</span>assq slot alist<span style="color: #4f97d7;">)</span>
           <span style="color: #4f97d7;">(</span><span style="color: #dc752f; background-color: #292b2e;">signal</span> 'ebdb-unacceptable-field <span style="color: #bc6ec5;">(</span>list slot<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span>
      <span style="color: #67b11d;">(</span>_ alist<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
这个方法以具体到通用的方式来调度： <code>ebdb-record-person</code> 属于
<code>ebdb-record-entity</code> ，而后者属于 <code>ebdb-record</code> 。每个子类的方法都把属于自己的
字段加入参数列表里，然后把参数传递到父类，直到最底层实际调用查询方法的部分：它
返回一个字段类属于哪个插槽或者能被哪个插槽接受，或者（如果 query 设置为空）返
回一个记录能接受的插槽和字段类的列表。
</p>

<p>
同样这展示了 EIEIO 是如何利用子类特化符提供类级别的方法。
</p>
</div>
</div>

<div id="outline-container-orgfed1d49" class="outline-2">
<h2 id="orgfed1d49"><span class="section-number-2">6</span> 修饰符</h2>
<div class="outline-text-2" id="text-6">
<p>
通用方法最复杂的部分就是修饰符了。除了主要方法以外，EIEIO 也提供了可以在主方法
前后运行或者替代主方法的补充方法。你可以用 <code>:before, :after, :around</code> 这些修饰
标签来声明补充方法。缺省的默认标签则是 <code>:primary</code> 主要方法。
</p>

<p>
调用方法的时候，先是 <code>:around</code> 的“前一半”运行，然后是 <code>:before</code> ，接着是
<code>:primary</code> ，最后就是剩下的 <code>:around</code> 部分。
</p>

<p>
<code>:around</code> 和 <code>:primary</code> 方法主体中能用 <code>cl-call-next-method</code> 来决定下一个调用
的方法。
</p>

<p>
不懂？没关系，上例子。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">defclass</span> <span style="color: #ce537a; font-weight: bold;">parent</span> <span style="color: #bc6ec5;">()</span>
  nil<span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">defclass</span> <span style="color: #ce537a; font-weight: bold;">child</span> <span style="color: #bc6ec5;">(</span>parent<span style="color: #bc6ec5;">)</span>
  nil<span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span> <span style="color: #4f97d7;">:around</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>obj child<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
              <span style="color: #bc6ec5;">(</span>message <span style="color: #2d9574;">"one"</span><span style="color: #bc6ec5;">)</span>
              <span style="color: #bc6ec5;">(</span>cl-call-next-method<span style="color: #bc6ec5;">)</span>
              <span style="color: #bc6ec5;">(</span>message <span style="color: #2d9574;">"eleven"</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span> <span style="color: #4f97d7;">:around</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>obj parent<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
              <span style="color: #bc6ec5;">(</span>message <span style="color: #2d9574;">"two"</span><span style="color: #bc6ec5;">)</span>
              <span style="color: #bc6ec5;">(</span>cl-call-next-method<span style="color: #bc6ec5;">)</span>
              <span style="color: #bc6ec5;">(</span>message <span style="color: #2d9574;">"ten"</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span> <span style="color: #4f97d7;">:before</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>obj child<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
              <span style="color: #bc6ec5;">(</span>message <span style="color: #2d9574;">"three"</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span> <span style="color: #4f97d7;">:before</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>obj parent<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
              <span style="color: #bc6ec5;">(</span>message <span style="color: #2d9574;">"four"</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>obj child<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>message <span style="color: #2d9574;">"five"</span><span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>cl-call-next-method<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>message <span style="color: #2d9574;">"seven"</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>obj parent<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>message <span style="color: #2d9574;">"six"</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span> <span style="color: #4f97d7;">:after</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>obj child<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
              <span style="color: #bc6ec5;">(</span>message <span style="color: #2d9574;">"nine"</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span> <span style="color: #4f97d7;">:after</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>obj parent<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
              <span style="color: #bc6ec5;">(</span>message <span style="color: #2d9574;">"eight"</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span>foo <span style="color: #bc6ec5;">(</span>make-instance 'child<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
大量使用方法修饰符是能让你了解具体发生了什么的一个很好的方法。但是需要注意的几
点有：
</p>

<ol class="org-ol">
<li>在 <code>:before :after</code> 方法中不能用 <code>cl-call-next-method</code> 。这代表它们总是会以
具体到抽象的顺序运行，独立于其它代码。</li>
<li>因此， <code>:before :after</code> 方法是无法和其它方法交互的。所以它们用来做通用设置
或销毁，比如一个 <code>:before</code> 方法出现错误时，之后的所有方法都不会生效。以及如
果一个 <code>:primary</code> 方法出现问题， <code>:after</code> 方法也不会运行。</li>
<li><code>cl-call-next-method</code> 可以用来改变调用的方法。可以传递参数给调用的方法，也
可以对返回的值进行处理。默认条件下传递所有参数。如果要改变传递的参数，所有
参数需要做显式声明。你可以在 <code>ebdb-record-field-slot-query</code> 中看到具体的用
法。</li>
<li>在 <code>:around</code> 之后接着运行的是 <code>:before :primary :after</code> ， <code>:around</code> 中必须
有 <code>cl-call-next-method</code> 。</li>
<li><code>:primary</code> 方法中可以用 <code>cl-call-next-method</code> 来调用下一个 <code>:primary</code> 方法，
否则覆盖更加抽象的方法。</li>
</ol>

<p>
在实践中我发现太多的 <code>:around</code> 方法是很烦人的，所以我尽量避免使用它们，并把它
们留给用户作为可以自定义的部分。
</p>

<p>
我有提到 <code>:extra</code> 方法吗？没有。
</p>

<p>
<code>:extra</code> 修饰符是用来把多个方法塞进一个特化符中（不然它们会互相覆盖到只剩一个
方法），每个 <code>:extra</code> 方法用文档字符串作区分，它们在 <code>:primary</code> 方法之前运行，
在里面用 <code>cl-call-next-method</code> 会依次调用 <code>:extra</code> 方法栈。
</p>

<p>
这使得实现一个国际化的 EBDB 变得非常容易。
</p>

<p>
BBDB 对多国语言习惯的支持不是很好，默认的习惯有一些来自北美的偏见。我希望 EBDB
能提供让开发者根据当地语言习惯写出针对的扩展，并根据用户的偏好来加载。比如，如
果知道一个电话号码的国家区号，就应该可以根据那个国家／地区的规范来显示电话号码。
</p>

<p>
于是我们就有了 <code>ebdb-i18n</code> 库，它专门用来扩展和具体国家／地区有关的库。鉴于
EBDB 仍在开发中，我目前只根据自己需要开发了中文为主的部分。
</p>

<p>
在 BBDB 中，中文名字总是以【名】【空格】【姓】，比如“锦涛 胡”，而不是【姓】
【名】，“胡锦涛”，如果你指定了名字格式，或许会得到“胡, 锦涛”，这稍微好上一
点，但是并不是完全正确的。（其他人也为此作出了<a href="https://github.com/tumashu/bbdb-china">解决办法：bbdb-china</a>）
</p>

<p>
加载 <code>ebdb-i18n</code> 会得到如下方法：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">ebdb-string</span> <span style="color: #4f97d7;">:extra</span> <span style="color: #2aa1ae;">"i18n"</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>name ebdb-field-name-complex<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
              <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">let*</span> <span style="color: #2d9574;">(</span><span style="color: #67b11d;">(</span>str <span style="color: #b1951d;">(</span>cl-call-next-method name<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span>
                     <span style="color: #67b11d;">(</span>script <span style="color: #b1951d;">(</span>aref char-script-table <span style="color: #4f97d7;">(</span>aref str <span style="color: #a45bad;">0</span><span style="color: #4f97d7;">)</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
                <span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">unless</span> <span style="color: #67b11d;">(</span>memq script ebdb-i18n-ignorable-scripts<span style="color: #67b11d;">)</span>
                  <span style="color: #67b11d;">(</span><span style="color: #4f97d7; font-weight: bold;">condition-case</span> nil
                      <span style="color: #b1951d;">(</span><span style="color: #4f97d7; font-weight: bold;">setq</span> str <span style="color: #4f97d7;">(</span>ebdb-string-i18n name script<span style="color: #4f97d7;">)</span><span style="color: #b1951d;">)</span>
                    <span style="color: #b1951d;">(</span>cl-no-applicable-method nil<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
                str<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<blockquote>
<p>
This method shadows the primary method. The first thing it does
is to call that :primary method, using cl-call-next-method, so it can examine
the results. It looks at the first character of the name, looks up the script
the character is written in, and attempts to call ebdb-string-i18n with the
name field and the script symbol as arguments. If no country-specific
libraries have been loaded, there will be no method that can catch these
particular arguments, in which case the original string is returned. 
</p>
</blockquote>

<p>
这个方法覆盖了主要方法。它先用 <code>cl-call-next-method</code> 调用主方法来得到结果。它
查看结果的第一个字母并推测出语言，并把参数传递给下面的 <code>ebdb-string-i18n</code> 。如
果没有针对这个语言的库被使用，那么返回的就是原来的字符串。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">cl-defmethod</span> <span style="color: #bc6ec5; font-weight: bold;">ebdb-string-i18n</span> <span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span>field ebdb-field-name-complex<span style="color: #2d9574;">)</span>
                                <span style="color: #2d9574;">(</span>_script <span style="color: #67b11d;">(</span>eql han<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">with-slots</span> <span style="color: #2d9574;">(</span>surname given-names<span style="color: #2d9574;">)</span> field
    <span style="color: #2d9574;">(</span>format <span style="color: #2d9574;">"%s%s"</span> surname <span style="color: #67b11d;">(</span>car given-names<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<blockquote>
<p>
Chinese characters register as the ’han script. So we specialize on the symbol
’han (using (_script (eql han))), and if it matches, format the name the way
it’s usually formatted in China.
</p>

<p>
If :extra methods didn’t exist, the internationalized ebdb-string method would
clobber the primary method completely. We’d have to replicate that primary
method here, or continually check some variable and funcall different
functions, or even subclass the name field class with a new
“internationalized” version. None of those options are as elegant as the
:extra trick.
</p>

<p>
The ebdb-chn.el library defines many other internationalized methods, notably
some that memoize Chinese characters as romanized “pinyin”, so you can search
for contacts with Chinese names without having to switch input methods. Very
nice.
</p>

<p>
Other internationalized methods allow for dispatch on the country code of
phone numbers, or the symbol names of countries (as per <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3">ISO 3166-1 alpha 3</a>).
</p>
</blockquote>

<p>
中文字被识别为 'han 字符，所以我们用 <code>(_script (eql han))</code> 来检查，如果符合，
就用中文的方法显示名字。
</p>

<p>
如果没有 <code>:extra</code> 方法，这个用于国际化字符串的方法会完全覆盖主要方法，要实现同
样的效果就要增加不少复杂性。
</p>

<p>
<code>ebdb-chn.el</code> 定义了不少其它多语言化的方法，比如汉字被记录为拼音，之后用户可以
直接用拼音来检索。
</p>

<p>
以及还有一些针对国际区号和国家名称缩写（<a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3">ISO 3166-1 alpha 3</a>）的方法。
</p>
</div>
</div>

<div id="outline-container-org69642a8" class="outline-2">
<h2 id="org69642a8"><span class="section-number-2">7</span> 现有问题</h2>
<div class="outline-text-2" id="text-7">
<blockquote>
<p>
Apart from bird’s-nests of :around methods, I’ve found two other ways to make
yourself miserable with generic methods. One is combinatorial explosion: if
you have a method that dispatches on three arguments, and each argument has
three potential values, you may be writing 27 different method definitions.
Obviously one tries to avoid this, but sometimes it creeps up on you. EBDB’s
formatting routines come close to drowning in this way – I suspect the whole
formatting system is overengineered.
</p>

<p>
The system’s other weakness is a byproduct of its strength: you don’t know
where code is defined. The same flexibility that allows you to alter
fundamental object behavior by defining new methods outside the codebase means
that you don’t necessarily know where those definitions are.
</p>

<p>
The original BBDB code “did polymorphism” the way that most Elisp code does
polymorphism: with great big cond branches. This has the disadvantage that
every function needs to be aware of every type of object it might encounter.
But it has the advantage that everything is right there where you can see it
(and it almost certainly goes faster).
</p>

<p>
There’s not much to be done about this, it’s a trade-off that has to be
accepted. Emacs’ self-documenting features do an okay job of showing you all
the implementations of a particular method, but that’s all the help you get.
Otherwise you need to keep your code under control, not pile the methods up
too high, and always know where your towel is.
</p>

<p>
I think it’s worth it.
</p>
</blockquote>
<p>
除了 <code>:around</code> 方法导致的困惑，我发现还有两个糟糕的地方，一个是组合爆炸：如果
你有一个对三个参数传递消息的方法， 每个参数可能有三种类型，你可能就需要写 27
个不同的方法。当然这是可以稍微避免的。但是 EBDB 的格式化功能的结构就出现了这样
的情况&#x2013;我怀疑可能有点设计过度了。
</p>

<p>
以及面向对象系统带来的副作用：你不知道代码的定义到底在哪里。不过你可能不需要了
解定义在哪里就能改变方法的行为。
</p>

<p>
原本的 BBDB 代码和传统的 ELisp 代码一样，通过大量的条件分支来处理多种情况。这
导致了每个函数都要考虑到可能接收到的参数类型，但是你可以清楚地知道发生了什么
（以及这样能提升运行速度）。
</p>

<p>
这方面能做的改进不多，毕竟这是两者间的平衡。Emacs 的文档功能能正确定位具体方法
的定义，但也只能做的这么多。另外你也需要对自己的代码进行控制，不要滥用面向对象
方法。
</p>

<p>
我觉得这样是值得的。
</p>
</div>
</div>

</div>
</div>
<div>
        <div class="post-meta">
            <span title="post date" class="post-info">2019-04-27</span>
            <span title="last modification date" class="post-info">2017-06-16</span>
            <span title="tags" class="post-info">:N/A:</span>
            <span title="author" class="post-info"><a href="mailto:lujun9972 &lt;at&gt; T430S">LdBeth</a></span>
        </div>
    <script src="https://lujun9972.github.io/emacs-document/media/js/jquery-2.1.3.min.js"></script>
    <script src="https://lujun9972.github.io/emacs-document/media/js/md5.min.js"></script>
        <section>
            <div id="gitalk-container"></div>
            <script type="text/javascript">
             var gitalk = new Gitalk({
                 clientID: 'fdcb5d9da3f4acb4862c',
                 clientSecret: 'dd0a16312a206782cb7669dcec5e96874ab48170',
                 repo: 'lujun9972.github.com',
                 owner: 'lujun9972',
                 admin: ['lujun9972'],
                 id: md5(location.pathname),      // Ensure uniqueness and length less than 50
                 distractionFreeMode: false  // Facebook-like distraction free mode
             })
             gitalk.render('gitalk-container')
            </script>
        </section>
    <script src="https://lujun9972.github.io/emacs-document/media/js/main.js"></script>
    <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 26.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
            Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:lujun9972 &lt;at&gt; T430S">LdBeth</a>
            &nbsp;&nbsp;-&nbsp;&nbsp;
            Powered by <a href="https://github.com/emacs-china/ego" target="_blank">EGO</a><br/>
            <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
            <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
    </div>
            </div>
            <script type="text/javascript"
                    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG">
            </script>
            <script type="text/x-mathjax-config">
             MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });
            </script>
</div>

  </div>
  <!-- https://instant.page/
       Make your site’s pages instant in 1 minute and improve your conversion rate by 1%  -->
  <script src="https://lujun9972.github.io/emacs-document//instant.page/1.1.0" type="module" integrity="sha384-EwBObn5QAxP8f09iemwAJljc+sU+eUXeL9vSBw1eNmVarwhKk2F9vBEpaN9rsrtp"></script>
  </body>
</html>
