<!DOCTYPE html>
<html lang="en">
<head>
  <title>From Vim to Emacs+Evil chaotic migration guide - EMACS-DOCUMENT</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <meta name="author" content="lujun9972" />
  <meta name="keywords" content="raw" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #ds-thread #ds-reset .ds-comment-body p a {color: #ff0;}
   #ds-thread #ds-reset .ds-comment-body p a:hover {color: #0ff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" href="https://lujun9972.github.io/emacs-document/media/css/main.css" type="text/css"/>
  <link rel="stylesheet" href="https://lujun9972.github.io/emacs-document/media/css/comment.css" type="text/css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
</head>

  <body><div class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="https://lujun9972.github.io/emacs-document/">EMACS-DOCUMENT</a></h1>
    <p>=============&gt;集思广益</p>
    <nav class="site-nav">
      <div class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z" fill="#ffff00"/>
          <path d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z" fill="#ffff00"/>
          <path d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z" fill="#ffff00"/>
        </svg>
      </div>
      <ul class="trigger">
        <li><a href="https://lujun9972.github.io/emacs-document/years/">Years</a></li>
        <li><a href="https://lujun9972.github.io/emacs-document/authors/">Authors</a></li>
        <li><a href="https://lujun9972.github.io/emacs-document/tags/">Tags</a></li>
        <li><a href="https://lujun9972.github.io/emacs-document/about/">About</a></li>
        <li><a href="https://github.com/lujun9972/emacs-document">Github</a></li>
        <li><a href="https://lujun9972.github.io/emacs-document/rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="http://www.google.com/search">
      <input type="text" class="field" name="q" id="s" placeholder="Search">
      <input type="hidden" name="as_sitesearch" value="lujun9972.github.io/emacs-document">
    </form>
  </header>
</div>

<div>
<div class="post">
<h1 class="title">From Vim to Emacs+Evil chaotic migration guide</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#a-good-windows-version">A good Windows version</a></li>
<li><a href="#basic-emacs-survival-keys">Basic Emacs survival keys</a></li>
<li><a href="#package-management">Package management</a></li>
<li><a href="#evil-vim-emulation">Evil (Vim emulation)</a></li>
<li><a href="#themes">Themes</a></li>
<li><a href="#terminal-colors">Terminal Colors</a></li>
<li><a href="#change-cursor-color-depending-on-mode">Change cursor color depending on mode</a></li>
<li><a href="#tabs">Tabs</a></li>
<li><a href="#leader-key">Leader key</a></li>
<li><a href="#sessions-mksession-in-vim">Sessions (:mksession in Vim)</a></li>
<li><a href="#accents">Accents</a></li>
<li><a href="#after-macro-definition">“After” macro definition</a></li>
<li><a href="#vim-like-search-highlighting">Vim-like search highlighting</a></li>
<li><a href="#helm-unitectrlp-style-fuzzy-filebufferanything-searcher-on-steroids">Helm: Unite/CtrlP style fuzzy file/buffer/anything searcher on steroids</a></li>
<li><a href="#vims-marks-gt-evils-marks-emacs-bookmarks">Vim's Marks =&gt; Evil's Marks + Emacs' Bookmarks</a></li>
<li><a href="#folding-and-narrowing">Folding... and narrowing!</a></li>
<li><a href="#project-management">Project Management</a></li>
<li><a href="#spell-checking">Spell checking</a></li>
<li><a href="#relative-line-numbers">Relative line numbers</a></li>
<li><a href="#easymotion-gt-evil-ace-jump">Easymotion =&gt; Evil Ace Jump</a></li>
<li><a href="#smooth-scrolling">Smooth scrolling</a></li>
<li><a href="#powerline">Powerline</a></li>
<li><a href="#syntactic-checking-on-the-fly-with-flycheck">Syntactic checking on the fly with Flycheck</a></li>
<li><a href="#jk-for-browsing-wrapped-lines">j/k for browsing wrapped lines</a></li>
<li><a href="#escape-escapes-things">escape... escapes things</a></li>
<li><a href="#start-maximized-please">Start maximized, please</a></li>
<li><a href="#c-kc-j-for-page-downup">c-k/c-j for page down/up</a></li>
<li><a href="#coding-style-and-spaces-instead-of-tabs">Coding Style and spaces instead of tabs</a></li>
<li><a href="#auto-indent-with-the-return-key">Auto-indent with the Return key</a></li>
<li><a href="#show-matching-paren">Show matching paren</a></li>
<li><a href="#fill-column-auto-line-breaking-and-column-limit-mark">Fill column, auto line breaking and column limit mark</a></li>
<li><a href="#silver-searcher-ag">Silver Searcher (ag)</a></li>
<li><a href="#spanish-keyboard-remaps">Spanish keyboard remaps</a></li>
<li><a href="#dont-create-backup-files">Don't create backup files</a></li>
<li><a href="#dont-move-back-the-cursor-one-position-when-exiting-insert-mode">Don't move back the cursor one position when exiting insert mode</a></li>
<li><a href="#remember-the-cursor-position-of-files-when-reopening-them">Remember the cursor position of files when reopening them</a></li>
<li><a href="#disable-scroll-bars">Disable scroll bars</a></li>
<li><a href="#graphical-gdb">“Graphical” GDB</a></li>
<li><a href="#color-identifiers-mode-and-color-delimiters">Color Identifiers Mode and Color Delimiters</a></li>
<li><a href="#diminish-to-clean-clutter-from-the-modeline">Diminish to clean clutter from the modeline</a></li>
<li><a href="#select-last-yanked-text">Select last yanked text</a></li>
<li><a href="#other-emacs-alternatives-for-popular-vim-plugins">Other Emacs alternatives for popular Vim plugins</a></li>
<li><a href="#other-random-thoughts-about-emacs-evil-and-vim">Other random thoughts about Emacs, Evil and Vim</a></li>
</ul>
</div>
</div>
<p>
I've been using Vim for 18 years, and for me it was the only option for serious
text work (like programming or writing) because I'm totally addicted to modal text
editing to the point that I feel crippled when I've to edit text in a non-modal
editor. You may argue that programming is not about how fast you write and you
would be right, but if you can imagine somebody programming on an on screen
keyboard on a tablet, you know how modal editor users feel about non modal
edition.
</p>

<p>
But as many Vimmers, I was always curious about Emacs (the enemy in the editor
flamewars!), it's operating-system-in-a-window and the Lisp virtual machines
concepts but the non-modal editing and the low quality of the existing modal
editing modes compared with Vim made me keep a sane distance from it.
</p>

<p>
But then, Evil-mode happened. Evil mode is being developed as a perfect Vim
emulation for Emacs. Some of its developers have publicly stated that Vim is the
model and if something works differently than in Vim it should be marked as a bug.
I've been hearing very good things about Evil-mode, and when some of my old
Vimmers contacts made the switch I knew the mode should be very good.
</p>

<p>
So two weeks ago I installed Emacs and Evil and started to configure everything to
my liking. My first objective was to have an editing environment as efficient as
the one I've in Vim, with the same plugins and shortcuts. I didn't expected to
really reach that point in a long time, because I heard than Emacs has less
plugins than Vim and I expected to have a hard time creating my dotfiles using
Elisp. After two weeks of intense investigation, googling, Elisp accelerated
learning, reading of other people's dotfiles and tinkering I can say that I was
very wrong. Not only I've an environment where I didn't lost almost anything to my
highly-tuned Vim, but I also got gains in some other areas (and I still haven't
started to play with the famous Org mode or Gnus).
</p>

<p>
This article is a pretty chaotic recollection of bits about how I turned Emacs into
my Vim, and then how I improved over it. Most of the items will be bits of Elisp
code for the config file or info about plugins. My hope is that this article will
be useful to other Vim power users trying Emacs+Evil because I would have loved to
find an article like this when I was starting.
</p>

<p>
This article has been written with the help of lot of random people whose configs,
articles an answers I had the luck to land after some internet search, mostly from
StackOverflow, GitHub, and random forums. To keep the article clean, I don't
always cite the source of the snippets but you could easily find most of them just
googling the code.
</p>

<p>
You can also check my <a href="http://github.com/juanjux/emacs-dotfiles">Emacs' dotfiles</a> if you're interested, but remember that
these are newbie dotfiles so I'm probably doing something stupid on them. As
you'll see, my config is split between several files. I advise you to don't do
this from the start, but to dump everything into your .emacs file because it is
easier to experiment and change a lot when you're starting (and if you're a little
like me you'll be playing a lot with your config) and once you've more or less
settled on a config, split it into categories. Oh, and keep Vim at hand to fix
your Emacs config the several times you'll broke it.
</p>

<div id="outline-container-org114e322" class="outline-2">
<h2 id="a-good-windows-version">A good Windows version</h2>
<div class="outline-text-2" id="text-a-good-windows-version">
<p>
I've to use Windows at work and I was having a lot of problems with the official
version of Emacs for Windows (slowness, unstability, huge memory usage spikes...).
Reddit's user tuhdo read about my woes and suggested two versions of third party
packages of Windows Emacs. I've tested both and I can say that <a href="http://emacsbinw64.sourceforge.net/">this one</a> is
definitively the best and solves all my problems.
</p>
</div>
</div>

<div id="outline-container-org6a86927" class="outline-2">
<h2 id="basic-emacs-survival-keys">Basic Emacs survival keys</h2>
<div class="outline-text-2" id="text-basic-emacs-survival-keys">
<p>
If you're a Vim user after installing Evil you'll be using Vim-style commands most
of the time, but to install Evil first and for some modes where Evil doesn't work
(like the package manager) you'll need some basic cheatsheet of Emacs commands.
</p>

<ul class="org-ul">
<li>C-g (that is Control and g at the same time) to cancel prompts. Later we'll
remap the escape key to do the same which anyone coming from Vim will need to
retain its sanity.</li>
<li>C-x k to kill (close) a buffer. Automatically opened windows are
usually closeable with “q”.</li>
<li>C-x o (that's an “o” not a zero) to rotate between window</li>
<li>C-x 2 to create an horizontal split (window)</li>
<li>C-x 3 to create a vertical split</li>
<li>M-x (M = Alt on PC) shows the “minibuffer” where you can call Emacs functions.
Later I'll show how to improve it a lot.</li>
<li>To toggle long lines wrapping (like set wrap/nowrap in Vim), do M-x
visual-line-mode RET.</li>
<li>C-y: yank/paste. The only way to paste on the modeline even when you're using
Evil.</li>
</ul>
</div>
</div>

<div id="outline-container-org7dc25d1" class="outline-2">
<h2 id="package-management">Package management</h2>
<div class="outline-text-2" id="text-package-management">
<p>
The integrated plugin (package in emacspeak) manager is pretty good. It lists,
downloads, updates and install the packages in a breeze. I've tested almost all of
Vim's plugin managers and neither of them is close to this. You start it with <code>M-x list-packages</code> (enter to install, d to delete, x to execute deletions).
</p>

<p>
To add more sources to the package managers and to have a function that will load
packages and install them if missing (useful if you move your config between
computers) put this on your config file:
</p>

<pre class="example">
;; packages
(setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
 ("org" . "http://orgmode.org/elpa/")
 ("marmalade" . "http://marmalade-repo.org/packages/")
 ("melpa-stable" . "http://melpa-stable.milkbox.net/packages/")))
(package-initialize)

(defun require-package (package)
 (setq-default highlight-tabs t)
 "Install given PACKAGE."
 (unless (package-installed-p package)
 (unless (assoc package package-archive-contents)
 (package-refresh-contents))
 (package-install package)))
</pre>

<p>
Note: as Phil suggested in the comments, the non-stable Melpa repository is risky
to have for newbies since it pulls directly from git master, I've used
melpa-stable in the config example, if you want to use Melpa just remove the
“-stable” from both the name and URL in the config.
</p>
</div>
</div>

<div id="outline-container-org78c328a" class="outline-2">
<h2 id="evil-vim-emulation">Evil (Vim emulation)</h2>
<div class="outline-text-2" id="text-evil-vim-emulation">
<p>
It's fucking impressive. I don't miss any text command, operator, motion or
work flow from Vim. Marks, paragraph reformatting, visual mode, visual block,
macros, registers, text objects, splits (vertical, horizontal, :normal, folding,
etc)... it has almost everything.
</p>

<p>
Of course Vim plugins doesn't work, but there are Emacs or Evil alternatives for
most of them.
</p>
</div>
</div>

<div id="outline-container-org073cc8b" class="outline-2">
<h2 id="themes">Themes</h2>
<div class="outline-text-2" id="text-themes">
<p>
You can use M-x load-theme RET to check the available themes (you can install more
with the package manager). Once you have chosen one theme, put in .emacs:
<code>(load-theme 'misterioso t)</code>.
</p>
</div>
</div>

<div id="outline-container-org733989c" class="outline-2">
<h2 id="terminal-colors">Terminal Colors</h2>
<div class="outline-text-2" id="text-terminal-colors">
<p>
By default, most themes look like shit on terminal Emacs (emacs -nw if you don't
want the window to open). On Vim some themes too, but in Emacs this happens with
almost all of them. This can improve a lot installing the color-theme-approximate
package with makes the same thing as CSApprox in Vim: translate colors to their
console equivalents. Once installed add this to your .emacs:
<code>(color-theme-approximate-on)</code>. If it doesn't work try to put the line lower in
the .emacs file (it happened to me). If everything still look like shit check that
you have the correct TERM environment variable set (hint: is different inside
screen or tmux).
</p>
</div>
</div>

<div id="outline-container-orgc27c18f" class="outline-2">
<h2 id="change-cursor-color-depending-on-mode">Change cursor color depending on mode</h2>
<div class="outline-text-2" id="text-change-cursor-color-depending-on-mode">
<p>
This is something that I liked to have in Vim. Fortunately, you can also have it
in Emacs. Unfortunately, I've been unable to get in working on non-GUI emacs:
</p>

<pre class="example">
(setq evil-emacs-state-cursor '("red" box))
(setq evil-normal-state-cursor '("green" box))
(setq evil-visual-state-cursor '("orange" box))
(setq evil-insert-state-cursor '("red" bar))
(setq evil-replace-state-cursor '("red" bar))
(setq evil-operator-state-cursor '("red" hollow))
</pre>
</div>
</div>

<div id="outline-container-org9a730be" class="outline-2">
<h2 id="tabs">Tabs</h2>
<div class="outline-text-2" id="text-tabs">
<p>
If you install the evil-tabs package and enable it with <code>(global-evil-tabs-mode t)</code> you'll have <code>:tabnew</code>, <code>gt</code> and friends with numbered tabs by default. Showing
the tab number is a very useful feature when you can change to a tab with <code>#gt</code>
like in Vim (with <code>#</code> being a number from 0 to 9), but unfortunately this package
doesn't support <code>#gt</code> but I worked it around with my awesome Elisp skills (close
to zero):
</p>

<pre class="example">
(define-key evil-normal-state-map (kbd "C-0") (lambda() (interactive) (elscreen-goto 0)))
(define-key evil-normal-state-map (kbd "C- ") (lambda() (interactive) (elscreen-goto 0)))
(define-key evil-normal-state-map (kbd "C-1") (lambda() (interactive) (elscreen-goto 1)))
(define-key evil-normal-state-map (kbd "C-2") (lambda() (interactive) (elscreen-goto 2)))
(define-key evil-normal-state-map (kbd "C-3") (lambda() (interactive) (elscreen-goto 3)))
(define-key evil-normal-state-map (kbd "C-4") (lambda() (interactive) (elscreen-goto 4)))
(define-key evil-normal-state-map (kbd "C-5") (lambda() (interactive) (elscreen-goto 5)))
(define-key evil-normal-state-map (kbd "C-6") (lambda() (interactive) (elscreen-goto 6)))
(define-key evil-normal-state-map (kbd "C-7") (lambda() (interactive) (elscreen-goto 7)))
(define-key evil-normal-state-map (kbd "C-8") (lambda() (interactive) (elscreen-goto 8)))
(define-key evil-normal-state-map (kbd "C-9") (lambda() (interactive) (elscreen-goto 9)))
(define-key evil-insert-state-map (kbd "C-0") (lambda() (interactive) (elscreen-goto 0)))
(define-key evil-insert-state-map (kbd "C- ") (lambda() (interactive) (elscreen-goto 0)))
(define-key evil-insert-state-map (kbd "C-1") (lambda() (interactive) (elscreen-goto 1)))
(define-key evil-insert-state-map (kbd "C-2") (lambda() (interactive) (elscreen-goto 2)))
(define-key evil-insert-state-map (kbd "C-3") (lambda() (interactive) (elscreen-goto 3)))
(define-key evil-insert-state-map (kbd "C-4") (lambda() (interactive) (elscreen-goto 4)))
(define-key evil-insert-state-map (kbd "C-5") (lambda() (interactive) (elscreen-goto 5)))
(define-key evil-insert-state-map (kbd "C-6") (lambda() (interactive) (elscreen-goto 6)))
(define-key evil-insert-state-map (kbd "C-7") (lambda() (interactive) (elscreen-goto 7)))
(define-key evil-insert-state-map (kbd "C-8") (lambda() (interactive) (elscreen-goto 8)))
(define-key evil-insert-state-map (kbd "C-9") (lambda() (interactive) (elscreen-goto 9)))
</pre>

<p>
Somebody with better Elisp skills please help me with a less kludgy solution, but
this works (and it's in fact one key press less than <code>#gt</code>).
</p>
</div>
</div>

<div id="outline-container-org4d13545" class="outline-2">
<h2 id="leader-key">Leader key</h2>
<div class="outline-text-2" id="text-leader-key">
<p>
In order to define an use a <code>&lt;leader&gt;</code> prefix for your personal shortcuts you have
to install the package evil-leader and put lines like these on your .emacs (I use
comma as a leader key):
</p>

<pre class="example">
(global-evil-leader-mode)
(evil-leader/set-leader ",")
</pre>

<p>
Later, I found that the key didn't work on some modes (like when editing
the .emacs file in emacs-lisp-mode), but the package FAQ solved the problem, you
have to add this before the <code>global-evil-leader-mode</code> setting:
</p>

<pre class="example">
(setq evil-leader/in-all-states 1)
</pre>
</div>
</div>

<div id="outline-container-org74a0738" class="outline-2">
<h2 id="sessions-mksession-in-vim">Sessions (:mksession in Vim)</h2>
<div class="outline-text-2" id="text-sessions-mksession-in-vim">
<p>
Emacs have the commands <code>M-x desktop-save</code> and <code>desktop-read</code>. To have it
automatically saved/restored put into the .emacs: <code>(desktop-save-mode 1)</code>. If you
want to start emacs without auto loading the session (if you configured it), the
command is <code>emacs --no-desktop</code>. But Emacs sessions doesn't know about elscreens
(which evil-tabs use for creating Vim-like tabs) so if you want to save and
restore full sessions including tabs copy these functions into your config file
and assign them some shortcut:
</p>

<pre class="example">
;; Save session including tabs
;; http://stackoverflow.com/questions/22445670/save-and-restore-elscreen-tabs-and-split-frames
(defun session-save ()
 "Store the elscreen tab configuration."
 (interactive)
 (if (desktop-save emacs-configuration-directory)
 (with-temp-file elscreen-tab-configuration-store-filename
 (insert (prin1-to-string (elscreen-get-screen-to-name-alist))))))

;; Load session including tabs
(defun session-load ()
 "Restore the elscreen tab configuration."
 (interactive)
 (if (desktop-read)
 (let ((screens (reverse
 (read
 (with-temp-buffer
 (insert-file-contents elscreen-tab-configuration-store-filename)
 (buffer-string))))))
 (while screens
 (setq screen (car (car screens)))
 (setq buffers (split-string (cdr (car screens)) ":"))
 (if (eq screen 0)
 (switch-to-buffer (car buffers))
 (elscreen-find-and-goto-by-buffer (car buffers) t t))
 (while (cdr buffers)
 (switch-to-buffer-other-window (car (cdr buffers)))
 (setq buffers (cdr buffers)))
 (setq screens (cdr screens))))))
</pre>
</div>
</div>

<div id="outline-container-org560d614" class="outline-2">
<h2 id="accents">Accents</h2>
<div class="outline-text-2" id="text-accents">
<p>
Accents didn't work for me on GUI mode, only in text mode. That was fixed adding
<code>(require 'iso-transl)</code> to my .emacs.
</p>
</div>
</div>

<div id="outline-container-org958b870" class="outline-2">
<h2 id="after-macro-definition">“After” macro definition</h2>
<div class="outline-text-2" id="text-after-macro-definition">
<p>
I have an “after” macro defined that I copied from someone config file (can't remember who - sorry). This is
useful to specifiy code to be executed after some plugin has loaded.
</p>

<p>
The definition is on my config file as:
</p>

<pre class="example">
;; "after" macro definition
(if (fboundp 'with-eval-after-load)
 (defmacro after (feature &amp;rest body)
 "After FEATURE is loaded, evaluate BODY."
 (declare (indent defun))
 `(with-eval-after-load ,feature ,@body))
 (defmacro after (feature &amp;rest body)
 "After FEATURE is loaded, evaluate BODY."
 (declare (indent defun))
 `(eval-after-load ,feature
 '(progn ,@body))))))
</pre>
</div>
</div>

<div id="outline-container-orgd7b7d77" class="outline-2">
<h2 id="vim-like-search-highlighting">Vim-like search highlighting</h2>
<div class="outline-text-2" id="text-vim-like-search-highlighting">
<p>
I prefer how Vim's highlight search and left the highlighted terms until you make
another search or clean the highlighted terms. I tough this would be easy to get
but it turned it wasn't so easy (for me). At the end I made my first Emacs
extension (and the first time I've programmed in Lisp since the university a long
time ago...) so all turned well. <a href="https://github.com/juanjux/evil-search-highlight-persist">The extension</a> is already on Melpa has the
very brief name of <code>evil-search-highlight-persist</code>. You can enable it with:
</p>

<pre class="example">
(require 'evil-search-highlight-persist)
(global-evil-search-highlight-persist t)
</pre>

<p>
To map a shortcut (leader-space) to clear the highlights I have:
</p>

<pre class="example">
(evil-leader/set-key "SPC" 'evil-search-highlight-persist-remove-all)
</pre>

<p>
I must note that another good way to search in Emacs is to use <code>occur</code> or
<code>helm-occur</code>. This will show the search results on a list (on a split window with
occur) and you'll be able to jump easily to any match.
</p>
</div>
</div>

<div id="outline-container-org746cd91" class="outline-2">
<h2 id="helm-unitectrlp-style-fuzzy-filebufferanything-searcher-on-steroids">Helm: Unite/CtrlP style fuzzy file/buffer/anything searcher on steroids</h2>
<div class="outline-text-2" id="text-helm-unitectrlp-style-fuzzy-filebufferanything-searcher-on-steroids">
<p>
Helm does the same thing as Unite/CtrlP on Vim and does it really well. You can
also enable Helm to manage the command buffer, which is pretty awesome with:
<code>(helm-mode 1)</code> in the .emacs file. I also configured a shortcut in normal mode,
<code>SPACE SPACE</code> which is the same I was using with Vim. This can be done with:
<code>(define-key evil-normal-state-map " " 'helm-mini)</code>.
</p>

<p>
But Helm can be really configurable and you can include or exclude modules in the
helm interface show with the shortcut associated to your config, for example I've:
</p>

<pre class="example">
;; helm settings (TAB in helm window for actions over selected items,
;; C-SPC to select items)
(require 'helm-config)
(require 'helm-misc)
(require 'helm-projectile)
(require 'helm-locate)
(setq helm-quick-update t)
(setq helm-bookmark-show-location t)
(setq helm-buffers-fuzzy-matching t)

(after 'projectile
 (package 'helm-projectile))
(global-set-key (kbd "M-x") 'helm-M-x)

(defun helm-my-buffers ()
 (interactive)
 (let ((helm-ff-transformer-show-only-basename nil))
 (helm-other-buffer '(helm-c-source-buffers-list
 helm-c-source-elscreen
 helm-c-source-projectile-files-list
 helm-c-source-ctags
 helm-c-source-recentf
 helm-c-source-locate)
 "*helm-my-buffers*")))
</pre>

<p>
Here, I define a “helm-my-buffers” function that when called (assign a shortcut to
it!) will show Helm interface but searching (fuzzy, real time as you write,
unordered) in open buffers, recent files, project files (see below for more on
that), tags inside the files, tabs and results from the Linux command <code>locate</code>
that searches quickly from a database of all the files in the file system. How
awesome is that?
</p>

<p>
But this is only the tip of the iceberg of Helm power. There are <code>sources</code> for
searching the symbols (functions, classes, globals, etc) in the current buffer
(<code>helm-imenu</code>), bookmarks (including Chrome/Firefox bookmarks), HTML colors
(showing the color, name, and hexadecimal code), apt packages and more.
</p>

<p>
If you check the sources of the <code>helm-my-buffers</code> function above you can see that
I'm also using <code>helm-c-source-projectile-files-list</code>. This will use another
installable third party package called Projectile that will search for a
git/hg/svn file in the current directory and its parents and extract the current
project files. Linking it will Helm makes it super easy to open any file in your
current project (providing you've it under version control) without having the
browse the filesystem, even for files that you have never opened (and thus are not
in Emacs' recent files list).
</p>

<p>
Another good combination of Helm with a nice Emacs feature (this time included by
default) is helm-imenu. iMenu is a pretty smart minor mode that extract
“locations” inside a buffer. For code in a programming language this will be
typically the classes, methods and other symbols. Calling helm-imenu instead of
the default imenu will make it very easy to jump quickly to a location inside the
buffer just writing a couple of letters.
</p>

<p>
Another great feature of Helm is the chance to replace the default “M-x” menu
interface. M-x is what you use to issue Emacs commands, a little like “:” in Vim
(but only a little, ex mode in Vim or Evil is another kind of animal). One great
thing about Emacs is that it has commands and modes for a lot of things, and with
Helm M-x you don't have to learn them all. For example if I don't remember how to
show white space characters I just press M-x and start to write <code>whitesp</code>... and
Helm will show me as first result <code>whitespace-mode</code> which is exactly what I want
(it also showed <code>whitespace-cleanup</code> that clears all the trailing whitespace and
that is how I discovered it). Want to check the commands related to spelling? <code>M-x spell</code>. How to list errors in the code with flycheck? <code>M-x fly errors</code>. How to
sort the lines of a selection? <code>M-x sort</code>. This is really convenient and as an
Emacs newbie I get a lot of things done just searching in Helm-M-x without having
to search on Google. You can map Helm-M-x to M-x with:
</p>

<pre class="example">
(global-set-key (kbd "M-x") 'helm-M-x)
</pre>

<p>
There is another package that also helps when learning to use a specific mode,
it's called “Discover My Major” (<code>discover-my-major</code> in Melpa). Invoking the
command with the same name will show all the functions enabled by the current
major mode. It's great to discover what every mode can do.
</p>

<p>
There is another package that also helps when learning to use a specific mode,
it's called “Discover My Major” (<code>discover-my-major</code> in Melpa). Invoking the
command with the same name will show all the functions enabled by the current
major mode. It's great to discover what every mode can do.
</p>

<p>
Edit: thanks to tuhdo in the comments who told me how to show the full path of
the files in the helm-recentf sources).
</p>
</div>
</div>

<div id="outline-container-orgddbf508" class="outline-2">
<h2 id="vims-marks-gt-evils-marks-emacs-bookmarks">Vim's Marks =&gt; Evil's Marks + Emacs' Bookmarks</h2>
<div class="outline-text-2" id="text-vims-marks-gt-evils-marks-emacs-bookmarks">
<p>
Evil has marks just like Vim: <code>m</code> to jump to a mark, <code>m-letter</code> to set a mark,
<code>m-uppercase_letter</code> to set a mark that works between buffers. But while marks are
pretty useful for example to quickly jump between two or three positions inside
some files when you're coding, Emacs also has the concept of “bookmarks” that are
like inter-file marks that you can set with a name (instead of a letter) and that
with the elisp bit below in your config file can be saved between sessions. I'm
using <code>helm-bookmarks</code> to see and set them, which I've mapped to <code>SPC-b</code>. To delete
bookmarks, press <code>TAB</code> inside the helm sub-window to see the list of actions and
choose “Delete Bookmark(s)”.
</p>

<pre class="example">
;; save bookmarks
(setq bookmark-default-file "~/.emacs.d/bookmarks"
 bookmark-save-flag 1) ;; save after every change
</pre>
</div>
</div>

<div id="outline-container-org4c5ca00" class="outline-2">
<h2 id="folding-and-narrowing">Folding... and narrowing!</h2>
<div class="outline-text-2" id="text-folding-and-narrowing">
<p>
Folding with Evil works as expected, using the same operators that in Vim (with
the added benefit that if you're using Helm-M-x you can do <code>M-x RET fold</code> to
search the folding commands in case you forgot the Vim-style operator). Emacs also
support an interesting feature called “narrowing”. Narrowing will hide everything else
in the file except the narrowed function or region. This is pretty useful when you
want to make global replaces or run some macro but don't want to affect the other
parts of the buffer. I don't use it much so I haven't assigned any shortcut, I
just use the commands <code>narrow-to-region</code> and <code>narrow-to-defun</code>. Once you have
finished working on the narrowed region, you can display the rest of the buffer
again with the <code>widen</code> command.
</p>
</div>
</div>

<div id="outline-container-orgfed2479" class="outline-2">
<h2 id="project-management">Project Management</h2>
<div class="outline-text-2" id="text-project-management">
<p>
I've already mentioned Projectile that combined with Helm makes searching for
project files very convenient, but there are other options. One of them is
project-explorer, which is pretty much like Vim “project” script: when you enable
it it will show a side split (sorry, window) with your project files. With Helm +
Helm-Projectile + the file explorer it's rarely needed but from time to time it's
nice to have a tree view of a source code project (more if the code isn't yours).
The Windows can be opened with the command “project-explorer-open” (I didn't
assign any shortcut to it). One thing to note if you're using Evil is that the
shortcuts like TAB to toggle a folder subtree only work if you're in insert mode.
</p>

<pre class="example">
(package 'project-explorer)
(after 'project-explorer
 (setq pe/cache-directory "~/.emacs.d/cache/project_explorer")
 (setq pe/omit-regex (concat pe/omit-regex "\\|single_emails")))
</pre>

<p>
Emacs use a tags file format with a syntax that is different from the “default”
ctags called “etags”. Generating etags is easy since Exuberant-Ctags already know
how to generate them (just add a <code>-e</code> switch). Emacs distributions usually came
with an etags binary (I'm using ctags because there is a patched version with
support for the <a href="http://dlang.org">D language</a> but Emacs's etag binary doesn't support it).
Once generated Emacs will ask you where the tags file is the first time you use
any tag command (like <code>find-tag</code> or <code>evil-jump-to-tag</code> to jump to the specified
tag) and once loaded it will remember it (at least for the current session, I
still need to find how to make it remember the path between sessions).
</p>

<p>
I've defined this <code>create-tags</code> function on my .emacs to regenerate the tags files
(it will ask for a directory and then use that directory as root from where to
scan and place to store the <code>tags</code> file):
</p>

<pre class="example">
;; etags
(cond ((eq system-type 'windows-nt)
 (setq path-to-ctags "C:/installs/gnuglobal/bin/ctags.exe")))
 (cond ((eq system-type 'gnu/linux)
 (setq path-to-ctags "/usr/local/bin/ctags")))

(defun create-tags (dir-name)
 "Create tags file."
 (interactive "DDirectory: ")
 ;; (message
 ;; (format "%s -f %s/tags -eR %s"
 path-to-ctags (directory-file-name dir-name) (directory-file-name
 dir-name)))
 (shell-command
 (format "%s -f %s/tags -eR %s" path-to-ctags
 (directory-file-name dir-name) (directory-file-name dir-name)))
 )
</pre>

<p>
With third party packages there is also support for normal ctags files and GNU
Global, but I find the etags support more than convenient for my needs
</p>
</div>
</div>

<div id="outline-container-orgd647016" class="outline-2">
<h2 id="spell-checking">Spell checking</h2>
<div class="outline-text-2" id="text-spell-checking">
<p>
No need to install anything if you have ispell on your system, just do:
<code>:ispell-buffer</code> to start a spell check of the current buffer (alternatives are
show above and shortcuts below) and <code>:ispell-change-dictionary</code> to use another
dictionary (to check another language). If you prefer spell checking on the fly
with underlines under misspelled words use <code>:flyspell-mode</code> and to see
alternatives to a misspelled word press <code>M-$</code> (<code>Alt-$</code> on most PCs) with the
cursor over the word.
</p>
</div>
</div>

<div id="outline-container-org5e8be46" class="outline-2">
<h2 id="relative-line-numbers">Relative line numbers</h2>
<div class="outline-text-2" id="text-relative-line-numbers">
<p>
Install the package “relative-line-numbers” and enable it globally on
your config file with:
</p>

<pre class="example">
(add-hook 'prog-mode-hook 'relative-line-numbers-mode t)
(add-hook 'prog-mode-hook 'line-number-mode t)
(add-hook 'prog-mode-hook 'column-number-mode t)
</pre>
</div>
</div>

<div id="outline-container-org3a48d3e" class="outline-2">
<h2 id="easymotion-gt-evil-ace-jump">Easymotion =&gt; Evil Ace Jump</h2>
<div class="outline-text-2" id="text-easymotion-gt-evil-ace-jump">
<p>
The functionality provided by the awesome Easymotion plugin on Vim is actually
integrated by default on Evil since it incorporates a package called Ace Jump
that does mostly the same. It's less powerful than Easymotion (some jumps like
backwards-only / forward-only / end-of-word and others are missing) and I prefer
how Easymotion shows directly two chars when a jump is going to require them
(instead of showing one and after pressing it, the other which is what Ace-Jump
does) but the important modes (bidirectional jump to word and to char) that were
the ones I was mostly using are provided.
</p>

<p>
Unlike Easymotion, jump to word asks for a letter, but that can be easily disabled
with: <code>(setq ace-jump-word-mode-use-query-char nil)</code>. The author makes the case
that without asking for a char you're probably entering more key presses most of
the time. This is probably true, but when I want to jump to a random word inside
the buffer my brain-eye connection has already identified the word but I've to
stop and look/think for the first char, so in the end for me is actually faster to
get jump shortcuts to all the words without having to provide the leading
character.
</p>

<p>
I mapped the word/line/char to e/l/x with:
</p>

<pre class="example">
(evil-leader/set-key "e" 'evil-ace-jump-word-mode) ; ,e for Ace Jump (word)
(evil-leader/set-key "l" 'evil-ace-jump-line-mode) ; ,l for Ace Jump (line)
(evil-leader/set-key "x" 'evil-ace-jump-char-mode) ; ,x for Ace Jump (char)
</pre>
</div>
</div>

<div id="outline-container-org7189525" class="outline-2">
<h2 id="smooth-scrolling">Smooth scrolling</h2>
<div class="outline-text-2" id="text-smooth-scrolling">
<p>
One annoying thing that most Vim users will find in Emacs is the jumpy
scrolling. To have Emacs scroll like Vim (that is, line by line and leaving some
lines before starting to scroll) the solution is to install the package
<code>smooth-scrolling</code> and add this to your config:
</p>

<pre class="example">
(setq scroll-margin 5
scroll-conservatively 9999
scroll-step 1)
</pre>

<p>
It's not perfect because sometimes when you're close to the start of end of the
file it still jumps.
</p>
</div>
</div>

<div id="outline-container-org3f4afbc" class="outline-2">
<h2 id="powerline">Powerline</h2>
<div class="outline-text-2" id="text-powerline">
<p>
Super-easy, just install the powerline-evil package and put this in your config:
</p>

<pre class="example">
(require 'powerline)
(powerline-evil-vim-color-theme)
(display-time-mode t)
</pre>
</div>
</div>

<div id="outline-container-org933da88" class="outline-2">
<h2 id="syntactic-checking-on-the-fly-with-flycheck">Syntactic checking on the fly with Flycheck</h2>
<div class="outline-text-2" id="text-syntactic-checking-on-the-fly-with-flycheck">
<p>
One of the best Vim plugins if you're a programmer is Syntastic that runs a
syntactic check auto detecting a huge variety of linters every time you
save. Emacs also have a similar package called “Flycheck”. It is even better
because it runs in parallel while you work so you don't have to wait for it to
finish its checks like happens with Vim. Another related package is
<code>flycheck-pos-tip</code> that shows errors on a tooltip (if you're on GUI Emacs,
obviously) instead of the minibuffer. My full flycheck config is:
</p>

<pre class="example">
;; flycheck
(package 'flycheck)
(add-hook 'after-init-hook #'global-flycheck-mode)

(after 'flycheck
 (setq flycheck-check-syntax-automatically '(save mode-enabled))
 (setq flycheck-checkers (delq 'emacs-lisp-checkdoc flycheck-checkers))
 (setq flycheck-checkers (delq 'html-tidy flycheck-checkers))
 (setq flycheck-standard-error-navigation nil))

(global-flycheck-mode t)

;; flycheck errors on a tooltip (doesnt work on console)
(when (display-graphic-p (selected-frame))
 (eval-after-load 'flycheck
 '(custom-set-variables
 '(flycheck-display-errors-function #'flycheck-pos-tip-error-messages))))
</pre>
</div>
</div>

<div id="outline-container-orgb4ed205" class="outline-2">
<h2 id="jk-for-browsing-wrapped-lines">j/k for browsing wrapped lines</h2>
<div class="outline-text-2" id="text-jk-for-browsing-wrapped-lines">
<p>
Evil has the same problem as Vim when browsing with j/k long wrapped lines; it
jumps the entire “real” line instead of the visual line. The solution is also
easy:
</p>

<pre class="example">
(define-key evil-normal-state-map (kbd "j") 'evil-next-visual-line)
(define-key evil-normal-state-map (kbd "k") 'evil-previous-visual-line)
</pre>
</div>
</div>

<div id="outline-container-org1f13f08" class="outline-2">
<h2 id="escape-escapes-things">escape... escapes things</h2>
<div class="outline-text-2" id="text-escape-escapes-things">
<p>
One very annoying thing with Emacs is that when you are in the <code>M-x</code> buffer (the
one were you call Emacs functions) you've to use <code>C-g</code> to exit it. If you use
<code>escape</code> as most Vim users would tend to do by default you need to hit the key
like a million times (it's more like 3, but it's extremely frustrating
anyway). This code on my .emacs that I copied from <a href="https://github.com/davvil/.emacs.d/blob/master/init.el">davvil init.el on Github</a>
fixed it:
</p>

<pre class="example">
;; esc quits
(defun minibuffer-keyboard-quit ()
 "Abort recursive edit.
In Delete Selection mode, if the mark is active, just deactivate it;
then it takes a second \\[keyboard-quit] to abort the minibuffer."
 (interactive)
 (if (and delete-selection-mode transient-mark-mode mark-active)
 (setq deactivate-mark t)
 (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
 (abort-recursive-edit)))
(define-key evil-normal-state-map [escape] 'keyboard-quit)
(define-key evil-visual-state-map [escape] 'keyboard-quit)
(define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
(global-set-key [escape] 'evil-exit-emacs-state)
</pre>
</div>
</div>

<div id="outline-container-org21e9619" class="outline-2">
<h2 id="start-maximized-please">Start maximized, please</h2>
<div class="outline-text-2" id="text-start-maximized-please">
<p>
Another minor annoyance was that Emacs (GUI) didn't start maximized by default, but
this is easy to fix:
</p>

<pre class="example">
(custom-set-variables
 '(initial-frame-alist (quote ((fullscreen . maximized))))) ;; start maximized
</pre>
</div>
</div>

<div id="outline-container-org144cc4d" class="outline-2">
<h2 id="c-kc-j-for-page-downup">c-k/c-j for page down/up</h2>
<div class="outline-text-2" id="text-c-kc-j-for-page-downup">
<p>
One thing that surprised me considering how complete Evil is, is the lack of Vim's
Control-d/Control-u for page down/up. Probably because C-u is pretty important in
Emacs (it's the shortcut to give a numeric parameter to other commands, I think).
I've in fact these mapped on my .vimrc to c-k/c-j (because I think they're more
consistent with Vim's j/k movement keys) so that's how I mapped them in Emacs:
</p>

<pre class="example">
(define-key evil-normal-state-map (kbd "C-k") (lambda ()
 (interactive)
 (evil-scroll-up nil)))
(define-key evil-normal-state-map (kbd "C-j") (lambda ()
 (interactive)
 (evil-scroll-down nil)))
</pre>
</div>
</div>

<div id="outline-container-orga1665ba" class="outline-2">
<h2 id="coding-style-and-spaces-instead-of-tabs">Coding Style and spaces instead of tabs</h2>
<div class="outline-text-2" id="text-coding-style-and-spaces-instead-of-tabs">
<p>
Emacs by default do the really evil thing of using tab characters for
indentation. To do the right thing and use spaces with 4 spaces per tab:
<code>(setq-default tab-width 4 indent-tabs-mode nil)</code>. Also, I prefer the “bsd” style
on my code on C-like languages (C, C++, Java, D...) but with 4 spaces tabs
instead of 8 so I also added: <code>(setq-default c-basic-offset 4 c-default-style "bsd")</code>.
</p>

<p>
There is also a nice package called “dtrt-indent” that can automatically determine
the indentation settings used on the file that you're currently editting and adapt
Emacs's settings to them. It's great when you're editing external files not
created by you or that for some reason follow different indentation rules that the
ones you've in your config file.
</p>

<pre class="example">
(package 'dtrt-indent)
(dtrt-indent-mode 1)
</pre>
</div>
</div>

<div id="outline-container-org64934d4" class="outline-2">
<h2 id="auto-indent-with-the-return-key">Auto-indent with the Return key</h2>
<div class="outline-text-2" id="text-auto-indent-with-the-return-key">
<p>
By default Emacs doesn't indent new lines until you press the TAB key. That is not
good. But it can be changed easily enough to do the Vim thing, adjusting
indentation on every new line automatically with:
</p>

<pre class="example">
(define-key global-map (kbd "RET") 'newline-and-indent)
</pre>
</div>
</div>

<div id="outline-container-orgc1c88d7" class="outline-2">
<h2 id="show-matching-paren">Show matching paren</h2>
<div class="outline-text-2" id="text-show-matching-paren">
<p>
If you want to show the matching parenthesis, brace or bracket automatically, add
this option: <code>(show-paren-mode t)</code>. You can also install the Autopairs package to
automatically add the matching parens/braces/etc after adding the opening one.
I've mixed feelings about it because while very convenient (specially with Lisp!)
it can be also very annoying when you want to surround something with parents and
it adds a useless “)” after the opening one, I should use “Surround” on these
cases, but half of the time I forget it. To enable autopairs put this on your
config file after installing the package:
</p>

<pre class="example">
(require 'autopair)
(autopair-global-mode)
</pre>
</div>
</div>

<div id="outline-container-orgae0bd1b" class="outline-2">
<h2 id="fill-column-auto-line-breaking-and-column-limit-mark">Fill column, auto line breaking and column limit mark</h2>
<div class="outline-text-2" id="text-fill-column-auto-line-breaking-and-column-limit-mark">
<p>
To visually mark the configured fill-column for the mode (like the <code>colorcolumn</code>
option in Vim) install the package <code>fill-column-indicator</code>, then you'll enable it
on every mode where you want to display it with <code>fci-mode</code> (see below).
</p>

<p>
To configure auto line breaking when the line exceed 82 chars for text and
markdown files, with fill indicator line:
</p>

<pre class="example">
(add-hook 'text-mode-hook (lambda ()
 (turn-on-auto-fill)
 (fci-mode)
 (set-fill-column 82)))
(add-hook 'markdown-mode-hook (lambda ()
 (turn-on-auto-fill)
 (fci-mode)
 (set-fill-column 82)))
</pre>

<p>
To set the non-auto-line limit for Python a C-mode (and D) to 94:
</p>

<pre class="example">
(add-hook 'python-mode-hook (lambda ()
 (fci-mode)
 (set-fill-column 94)))
(add-hook 'c-mode-hook (lambda ()
 (fci-mode)
 (set-fill-column 94)))

(add-hook 'd-mode-hook (lambda ()
 (fci-mode)
 (set-fill-column 94)))
</pre>
</div>
</div>

<div id="outline-container-org8ed9588" class="outline-2">
<h2 id="silver-searcher-ag">Silver Searcher (ag)</h2>
<div class="outline-text-2" id="text-silver-searcher-ag">
<p>
If you don't know it, the Silver Searcher is like Ack but a lot faster. The “ag”
package will allow you to make searches with it without leaving Emacs and show
the results in a quickfix-style windows where you can select results and jump to
them: M-x ag RET [search] RET [directory] RET.
</p>
</div>
</div>

<div id="outline-container-org0144f9c" class="outline-2">
<h2 id="spanish-keyboard-remaps">Spanish keyboard remaps</h2>
<div class="outline-text-2" id="text-spanish-keyboard-remaps">
<p>
I use Spanish keyboards. Yes, I know, Vim is much better with an English keyboard,
but I'm 36 and have been using the Spanish layouts since I was 8, which means that
my brain is too hardwired to it. But with a few remaps I made my Vim experience
much better. These were <code>-</code> (minus sign) in normal mode as <code>/</code> (to search), <code>= as
=escape</code> in insert mode (I want to try the kj thing) and <code>= as =:</code>. When you
remap keys in Emacs you have to know the name of the function that the shortcut
key will point to. Fortunately using <code>C-h k</code> (Control-h, release, k) will tell you
the name of the function associated with the next key you press, so getting the
name of the functions for these remaps is easy. The <code>/</code> and <code>:</code> remaps were easy:
</p>

<pre class="example">
(define-key evil-normal-state-map "-" 'evil-search-forward)
(define-key evil-normal-state-map " " 'evil-ex)
(define-key evil-insert-state-map " " 'evil-normal-state)
</pre>
</div>
</div>

<div id="outline-container-org8c671f4" class="outline-2">
<h2 id="dont-create-backup-files">Don't create backup files</h2>
<div class="outline-text-2" id="text-dont-create-backup-files">
<p>
I use version control and I'm a compulsive saver, so I don't need backup
files. I've these disabled on Vim and I've also disabled them on Emacs:
</p>

<pre class="example">
(setq make-backup-files nil)
</pre>
</div>
</div>

<div id="outline-container-orgf2b2175" class="outline-2">
<h2 id="dont-move-back-the-cursor-one-position-when-exiting-insert-mode">Don't move back the cursor one position when exiting insert mode</h2>
<div class="outline-text-2" id="text-dont-move-back-the-cursor-one-position-when-exiting-insert-mode">
<p>
This is something that I hated in Vim so I had it disabled with the following
lines on my .vimrc:
</p>

<pre class="example">
autocmd InsertEnter * let CursorColumnI = col('.')
autocmd CursorMovedI * let CursorColumnI = col('.')
autocmd InsertLeave * if col('.') != CursorColumnI | call cursor(0, col('.')+1) | endif
</pre>

<p>
To get the same behaviour in Evil you just have to set one option:
</p>

<pre class="example">
(setq evil-move-cursor-back nil)
</pre>
</div>
</div>

<div id="outline-container-org951bf92" class="outline-2">
<h2 id="remember-the-cursor-position-of-files-when-reopening-them">Remember the cursor position of files when reopening them</h2>
<div class="outline-text-2" id="text-remember-the-cursor-position-of-files-when-reopening-them">
<p>
Pretty easy:
</p>

<pre class="example">
(setq save-place-file "~/.emacs.d/saveplace")
(setq-default save-place t)
(require 'saveplace)
</pre>
</div>
</div>

<div id="outline-container-org8bc902c" class="outline-2">
<h2 id="disable-scroll-bars">Disable scroll bars</h2>
<div class="outline-text-2" id="text-disable-scroll-bars">
<p>
By default Emacs put a scroll bar on every window (split) which IMO is incredibly
ugly. I already have the % of my position on the file in Powerline so I don't need
any scroll bars: <code>(scroll-bar-mode -1)</code>.
</p>
</div>
</div>

<div id="outline-container-orgf34c6ec" class="outline-2">
<h2 id="graphical-gdb">“Graphical” GDB</h2>
<div class="outline-text-2" id="text-graphical-gdb">
<p>
Emacs GDB mode (enabled with M-x gdb RET binary_path) is pretty cool because it
create several windows in the style of typical IDE debuggers, but that's not
enabled by default, to enable it: <code>(setq gdb-many-windows t)</code>.
</p>

<p>
Once you're in GDB mode with the binary loaded you can change to the source code
windows (use <code>C-x o</code> to switch between splits or just mouse clicks, Vim-style
<code>C-w</code> key bindings doesn't work in gdb mode), load the source code file you want
to set breakpoints on and set a break point with M-x gud-break. Then you can run
the program with “run” (r) on the gdb window and once in the break point advance with
next (n) or step (s). Local vars and registers are show in one window, breakpoints
and the stack frame in another one.
</p>
</div>
</div>

<div id="outline-container-org4d86cdd" class="outline-2">
<h2 id="color-identifiers-mode-and-color-delimiters">Color Identifiers Mode and Color Delimiters</h2>
<div class="outline-text-2" id="text-color-identifiers-mode-and-color-delimiters">
<p>
The plugin <code>colors-identifiers-mode</code> colorize every variable in a different color.
I've mixed feelings about it because the code looks like a fruit salad, but it
makes really easy to visually identify where variables are used. I'm using it for
now. Setup is:
</p>

<pre class="example">
(package 'color-identifiers-mode)
(global-color-identifiers-mode)
</pre>

<p>
Another firm step into the total fruitsalarization of your Emacs is the Rainbow
Delimiters package that will color nested delimiters on a different color so you
can check easily which of them are pairs without having to move the cursor over
them. When you have lots of nested parenthesis this helps a lot to see the pairs
without having to move the cursor over them.
</p>

<pre class="example">
(package 'rainbow-delimiters)
(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
</pre>
</div>
</div>

<div id="outline-container-orga940e51" class="outline-2">
<h2 id="diminish-to-clean-clutter-from-the-modeline">Diminish to clean clutter from the modeline</h2>
<div class="outline-text-2" id="text-diminish-to-clean-clutter-from-the-modeline">
<p>
Diminish will remove the minor mode indicators from the mode line (or powerline).
Example config:
</p>

<pre class="example">
(require 'diminish)
(diminish 'visual-line-mode)
(after 'autopair (diminish 'autopair-mode))
(after 'undo-tree (diminish 'undo-tree-mode))
(after 'auto-complete (diminish 'auto-complete-mode))
(after 'projectile (diminish 'projectile-mode))
(after 'yasnippet (diminish 'yas-minor-mode))
(after 'guide-key (diminish 'guide-key-mode))
(after 'eldoc (diminish 'eldoc-mode))
(after 'smartparens (diminish 'smartparens-mode))
(after 'company (diminish 'company-mode))
(after 'elisp-slime-nav (diminish 'elisp-slime-nav-mode))
(after 'git-gutter+ (diminish 'git-gutter+-mode))
(after 'magit (diminish 'magit-auto-revert-mode))
(after 'hs-minor-mode (diminish 'hs-minor-mode))
(after 'color-identifiers-mode (diminish 'color-identifiers-mode))
</pre>
</div>
</div>

<div id="outline-container-orge587c62" class="outline-2">
<h2 id="select-last-yanked-text">Select last yanked text</h2>
<div class="outline-text-2" id="text-select-last-yanked-text">
<p>
This is a pretty useful shotcut I've on my .vimrc that selects the last pasted (yanked) text:
</p>

<pre class="example">
nnoremap &lt;leader&gt;V `[v`]
</pre>

<p>
Thanks to the comment by delexi I know that the function in Emacs is called
<code>exchange-point-and-mark=which defaults to =C-x C-x</code> but I've remapped to
leader-V with:
</p>

<pre class="example">
(evil-leader/set-key "V" 'exchange-point-and-mark)
</pre>
</div>
</div>

<div id="outline-container-org18ec1ce" class="outline-2">
<h2 id="other-emacs-alternatives-for-popular-vim-plugins">Other Emacs alternatives for popular Vim plugins</h2>
<div class="outline-text-2" id="text-other-emacs-alternatives-for-popular-vim-plugins">
<ul class="org-ul">
<li>Powerline =&gt; Powerline-Evil</li>
<li>Emmet =&gt; emmet-mode. I mapped “m” to “emmet-expand-line” because the
default C-j shortcut is already defined in Evil.</li>
<li>Surround =&gt; evil-surround (same operators)</li>
<li>Tabular.vim =&gt; M-x align-regexp RET regexp RET (with a visual selection)</li>
<li>Rename =&gt; M-x dired-jump, R to rename the file, RET to reopen.</li>
<li>jDaddy =&gt; I only really used it to prettify json objects, this can be done with
the functions defined <a href="http://irreal.org/blog/?p=354#comment-79015">by James P.</a>.</li>
<li>Autocomplete and company mode works much like YouCompleteMe on Vim: they give an
improved completion when you're programming. I don't know the difference between
both, Company is newer, I think, but the ac-dcd package for completing the D
language is for Autocomplete so that's what I'm using.</li>
<li>Vimdiff <code>&gt; M-x ediff-files or ediff-buffers. Pretty similar. Press =?</code> for help.
If you use Helm (just use it) when you're in a helm file list you can press TAB
and in the actions list you can select one to marking the file for ediff; much
quicker than browsing by hand to the files to compare.</li>
<li>netrw/nerdtree =&gt; M-x dired (included) or M-x dired+ (installable).</li>
</ul>
</div>
</div>

<div id="outline-container-orgfe38271" class="outline-2">
<h2 id="other-random-thoughts-about-emacs-evil-and-vim">Other random thoughts about Emacs, Evil and Vim</h2>
<div class="outline-text-2" id="text-other-random-thoughts-about-emacs-evil-and-vim">
<ul class="org-ul">
<li>Copy and paste with the system clipboard works without having to paste from the
<code>"+</code> or <code>"*</code> register. It's still saved on those registers, but also in the
default register so if you paste after copying from any other desktop program
and then paste without specifying any register it will pull that register. Nice.</li>
<li>Evil doesn't have <code>:pu=/</code>:put= (paste below current line).</li>
<li>Some windows with Evil (like <code>:registers</code>) use Emacs key binding of
<code>q</code> to exit instead of Vim <code>esc</code>.</li>
<li>The toolbar is actually useful for a newbie like me. Check it. To use the
toolbar without the mouse you've the <code>F10</code> key binding.</li>
<li>Paralellization is very nice to have. I love to have my syntax checked without
pauses, but...</li>
<li>Not everything is perfectly paralellized. For example, when the package
manager is loading the information from a package on a split (and sometimes it
takes its time), all the interface hangs. One nice feature of Emacs is that you
can almost always cancel any long running process with Control-G.</li>
</ul>
</div>
</div>

</div>
</div>
<div>
        <div class="post-meta">
            <span title="post date" class="post-info">2018-10-25</span>
            <span title="last modification date" class="post-info">2018-10-25</span>
            <span title="tags" class="post-info">:<a href="https://lujun9972.github.io/emacs-document/tags/raw">raw</a>:</span>
            <span title="author" class="post-info"><a href="mailto:lujun9972 &lt;at&gt; T430S">lujun9972</a></span>
        </div>
    <script src="https://lujun9972.github.io/emacs-document/media/js/jquery-2.1.3.min.js"></script>
        <section>
            <h1>Comments</h1>
            <div id="comment-wrap">
                    <a class="disqus_label">使用 Disqus 评论</a>
    </ul>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
         //var disqus_developer = 1;
         var preempt_signal=false;
         var disqus_identifier = "/blog/2018/10/25/from-vim-to-emacs+evil-chaotic-migration-guide/";
         var disqus_url = "https://lujun9972.github.io/emacs-document/blog/2018/10/25/from-vim-to-emacs+evil-chaotic-migration-guide/";
         var disqus_shortname = 'emacs-document';
         /* * * DON'T EDIT BELOW THIS LINE * * */
         (function() {
             var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
             dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
             (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
             $('#disqus_thread').css('display','none');
         })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    <script>
     /* comments */
     var ego_disqus_thread=$('#disqus_thread');
     var ego_ds_label=$('.ds-thread');
     $('.disqus_label').click(function(){
         ego_disqus_thread.show();
         ego_ds_label.hide();
     });
     $('.ds-label').click(function(){
         ego_disqus_thread.hide();
         ego_ds_label.show();
     });
    </script>
        </section>
    <script src="https://lujun9972.github.io/emacs-document/media/js/main.js"></script>
    <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 26.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
            Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:lujun9972 &lt;at&gt; T430S">lujun9972</a>
            &nbsp;&nbsp;-&nbsp;&nbsp;
            Powered by <a href="https://github.com/emacs-china/ego" target="_blank">EGO</a><br/>
            <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
            <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
    </div>
            </div>
            <script type="text/javascript"
                    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG">
            </script>
            <script type="text/x-mathjax-config">
             MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });
            </script>
</div>

  </div>
  <!-- https://instant.page/
       Make your site’s pages instant in 1 minute and improve your conversion rate by 1%  -->
  <script src="https://lujun9972.github.io/emacs-document//instant.page/1.1.0" type="module" integrity="sha384-EwBObn5QAxP8f09iemwAJljc+sU+eUXeL9vSBw1eNmVarwhKk2F9vBEpaN9rsrtp"></script>
  </body>
</html>
