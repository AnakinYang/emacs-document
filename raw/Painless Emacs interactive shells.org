#+TITLE: Painless Emacs interactive shells
#+URL: https://www.eigenbahn.com/2020/01/21/painless-emacs-interactive-shells
#+AUTHOR: lujun9972
#+TAGS: raw
#+DATE: [2020年 02月 10日 星期一 09:54:39 HKT]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:nil
[[https://www.eigenbahn.com/assets/img/drake-prf-shell.png]]


* Recap
   :PROPERTIES:
   :CUSTOM_ID: recap
   :END:

On the [[/2020/01/19/painless-emacs-shell-commands][previous post]], we discussed how to make more explicit functions to call single shell command.

Now, let's get into more juicy stuff with interactive shells.

* Emacs Interactive Shells API
   :PROPERTIES:
   :CUSTOM_ID: emacs-interactive-shells-api
   :END:

For spawning shell, the main command is: *shell* =(& buffer)=.

Like for single shell commands, there is some hidden vars we can manipulate to change the behavior.

Here are the important vars we want to manipulate.

var default-directorylocation from which to launch shellexplicit-shell-file-name / shell-file-nameshell interpreter exec (e.g. bash ...)explicit-<INTERPRETER>-argsstartup arguments for invoking the shell interactively (e.g. =-i=)

Note that =shell-command-switch= is not listed of no use for interactive shells.

Instead, we have the new var =explicit-<INTEPRETER>-args= that allows passing a list of commands to the shell before it becomes interactive.

You might have spotted it, but in the previous post function =eval-with-shell-interpreter= already handled this use-case.

* Reusing our Wrappers
   :PROPERTIES:
   :CUSTOM_ID: reusing-our-wrappers
   :END:

Hence, we can reuse the wrapper =with-shell-interpreter= that we defined previously.

There is just a small annoyance: by default command =shell= will prompt for user to specify interpreter path.

This is cumbersome to have to precise it every time.

We might prefer to just have it default to =shell-file-name= for local shells and =default-remote-shell-interpreter= for remote ones.

If we want to change location, it would be more practical to create a command that explicitly defines the :interpreter.

To disable =shell= prompting for interpreter path, we have to call it with the default prefix argument (i.e. =C-u M-x shell=).

To reproduce this behavior programmatically, we'd have to let bind =current-prefix-arg= to ='(4)=.

This gives, for example:

#+BEGIN_EXAMPLE
  (defun my/zsh-local ()
   (interractive)
   (with-shell-interpreter
   :path "~"
   :interpreter "zsh"
   :form
   (let (current-prefix-arg '(4))
   (shell))))

  (defun my/bash-on-raspi ()
   (interractive)
   (with-shell-interpreter
   :path "/ssh:pi@raspi:/~"
   :interpreter "bash"
   :form
   (let (current-prefix-arg '(4))
   (shell))))
#+END_EXAMPLE

* Another wrapper
   :PROPERTIES:
   :CUSTOM_ID: another-wrapper
   :END:

That's still quite cumbersome.

So let's create another derived helper to prevent repetition.

Click to toggle

#+BEGIN_EXAMPLE
  ;; ------------------------------------------------------------------------
  ;; MAIN

  (cl-defun prf-shell (&key path interpreter interpreter-args command-switch)
   "Create a shell at given PATH, using given INTERPRETER binary."
   (interactive)

   (with-shell-interpreter
   :form
   (let* ((path (or path default-directory))
   (is-remote (file-remote-p path))
   (interpreter (or interpreter
   (if is-remote
   with-shell-interpreter-default-remote
   shell-file-name)))
   (interpreter (prf/tramp/path/normalize interpreter))
   (shell-buffer-basename (prf-shell--generate-buffer-name is-remote interpreter path))
   (shell-buffer-name (generate-new-buffer-name shell-buffer-name))
   (current-prefix-arg '(4))
   (comint-process-echoes t))
   (shell shell-buffer-name))
   :path path
   :interpreter interpreter
   :interpreter-args interpreter-args))

  ;; ------------------------------------------------------------------------
  ;; HELPERS: BUFFER NAME

  (defun prf-shell--generate-buffer-name (is-remote interpreter path)
   (if is-remote
   (prf-shell--generate-buffer-name-remote interpreter path)
   (prf-shell--generate-buffer-name-local interpreter path)))

  (defun prf-shell--generate-buffer-name-local (&optional interpreter _path)
   (if interpreter
   (prf-with-interpreter--get-interpreter-name interpreter)
   "shell"))

  (defun prf-shell--generate-buffer-name-remote (intepreter path)
   (let ((vec (tramp-dissect-file-name path)))
   (prf-shell--generate-buffer-name-remote-from-vec vec)))

  (defun prf-shell--generate-buffer-name-remote-from-vec (vec)
   (let (user host)
   (concat
   (tramp-file-name-user vec) "@" (tramp-file-name-host vec))))
#+END_EXAMPLE

Please note that we force =comint-process-echoes= to =t= to ensure that directory tracking works properly.

Directory tracking (ditrack for short) is the Emacs capability to keep track of current directory when doing a =cd=.

Also, we embarked functions to help make shell buffer names more explicit.

Our rewritten commands become:

#+BEGIN_EXAMPLE
  (defun my/zsh-local ()
   (interractive)
   (prf-shell :path "~" :interpreter "zsh"))

  (defun my/bash-on-raspi ()
   (interractive)
   (prf-shell :path "/ssh:pi@raspi:/~" :interpreter "bash"))
#+END_EXAMPLE

The code for =prf-shell= can be found in package [[https://github.com/p3r7/prf-shell][prf-shell]].

\\

Tagged [[/tag/emacs][#emacs]].

Please enable JavaScript to view the comments powered by Disqus.
