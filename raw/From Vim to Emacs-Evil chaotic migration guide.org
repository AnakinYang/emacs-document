#+TITLE: From Vim to Emacs+Evil chaotic migration guide
#+URL: https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/
#+AUTHOR: lujun9972
#+TAGS: raw
#+DATE: [2018年 10月 25日 星期四 12:02:17 HKT]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t n:nil ::t |:t ^:nil -:nil f:t *:t <:nil

I've been using Vim for 18 years, and for me it was the only option for serious
我已经使用Vim 18年了，对我来说这是唯一的选择
text work (like programming or writing) because I'm totally addicted to modal text
文本工作(像编程或写作)，因为我完全沉迷于模态文本
editing to the point that I feel crippled when I've to edit text in a non-modal
当我不得不以非模态的方式编辑文本时，我感觉自己陷入了困境
editor. You may argue that programming is not about how fast you write and you
编辑器。你可能会说，编程不在于你写得多快，也不在于你自己
would be right, but if you can imagine somebody programming on an on screen
这是对的，但你能想象有人在屏幕上编程吗
keyboard on a tablet, you know how modal editor users feel about non modal
平板电脑上的键盘，你知道模态编辑器用户对非模态的感觉
edition.
版。

But as many Vimmers, I was always curious about Emacs (the enemy in the editor
但是和许多Vimmers一样，我总是对Emacs(编辑器中的敌人)感到好奇
flamewars!), it's operating-system-in-a-window and the Lisp virtual machines
)，它是一个窗口中的操作系统和Lisp虚拟机
concepts but the non-modal editing and the low quality of the existing modal
概念，但非模态编辑和低质量的现有模态
editing modes compared with Vim made me keep a sane distance from it.
与Vim相比，编辑模式让我与它保持了一定的距离。

But then, Evil-mode happened. Evil mode is being developed as a perfect Vim
但接着，邪恶模式发生了。邪恶模式被发展成一个完美的活力
emulation for Emacs. Some of its developers have publicly stated that Vim is the
模拟Emacs。它的一些开发人员已经公开声明，Vim是
model and if something works differently than in Vim it should be marked as a bug.
如果某些东西的工作方式与Vim不同，那么它应该被标记为bug。
I've been hearing very good things about Evil-mode, and when some of my old
我听到了很多关于邪恶模式的好东西，当我的一些老
Vimmers contacts made the switch I knew the mode should be very good.
Vimmers接点使开关，我知道模式应该很好。

So two weeks ago I installed Emacs and Evil and started to configure everything to
因此，两周前我安装了Emacs和Evil，并开始将一切配置为
my liking. My first objective was to have an editing environment as efficient as
我的喜欢。我的第一个目标是有一个高效的编辑环境
the one I've in Vim, with the same plugins and shortcuts. I didn't expected to
我在Vim中使用的插件和快捷方式是一样的。我没想到会这样
really reach that point in a long time, because I heard than Emacs has less
在很长一段时间内真的达到了那个点，因为我听说比Emacs要少
plugins than Vim and I expected to have a hard time creating my dotfiles using
插件比Vim和我预计有一个困难的时间创建我的点文件使用
Elisp. After two weeks of intense investigation, googling, Elisp accelerated
Elisp。经过两周的深入调查、谷歌搜索，Elisp的速度加快了
learning, reading of other people's dotfiles and tinkering I can say that I was
学习，阅读别人的网络文档，我可以说我是在修修补补
very wrong. Not only I've an environment where I didn't lost almost anything to my
非常错误的。我不仅拥有一个几乎不会失去任何东西的环境
highly-tuned Vim, but I also got gains in some other areas (and I still haven't
高度调整的Vim，但我也得到了一些其他领域的收益(我仍然没有
started to play with the famous Org mode or Gnus).
开始使用著名的Org模式或Gnus)。

This article is a pretty chaotic recollection of bits about how I turned Emacs into
这篇文章是关于我如何将Emacs转换成的一个相当混乱的回忆
my Vim, and then how I improved over it. Most of the items will be bits of Elisp
我的生命，然后我如何改进它。大多数项目将是尖塔位
code for the config file or info about plugins. My hope is that this article will
配置文件或插件信息的代码。我希望这篇文章可以
be useful to other Vim power users trying Emacs+Evil because I would have loved to
对其他尝试Emacs+Evil的Vim高级用户很有用，因为我很想这么做
find an article like this when I was starting.
在我刚开始的时候，找一篇这样的文章。

This article has been written with the help of lot of random people whose configs,
这篇文章是在很多人的帮助下写的，
articles an answers I had the luck to land after some internet search, mostly from
文章和答案，我有运气降落后，一些互联网搜索，大多来自
StackOverflow, GitHub, and random forums. To keep the article clean, I don't
StackOverflow, GitHub，和随机论坛。为了保持文章干净，我没有
always cite the source of the snippets but you could easily find most of them just
总是引用片段的来源，但你可以很容易找到其中的大部分
googling the code.
google的代码。

You can also check my [[http://github.com/juanjux/emacs-dotfiles][Emacs' dotfiles]] if you're interested, but remember that
如果你有兴趣，也可以查看我的[[http://github.com/juan/emacs-dotfiles][Emacs' dotfiles]]，但是要记住
these are newbie dotfiles so I'm probably doing something stupid on them. As
这些是新手的网络文件，所以我可能在做一些愚蠢的事情。作为
you'll see, my config is split between several files. I advise you to don't do
你会看到，我的配置被分成几个文件。我劝你不要这样做
this from the start, but to dump everything into your .emacs file because it is
从一开始就是这样，但是要把所有东西都转储到.emacs文件中，因为它就是这样
easier to experiment and change a lot when you're starting (and if you're a little
当你开始做的时候，更容易去尝试和改变
like me you'll be playing a lot with your config) and once you've more or less
和我一样，你会用你的配置玩很多)，一旦你或多或少
settled on a config, split it into categories. Oh, and keep Vim at hand to fix
设定一个配置，把它分成不同的类别。噢，还有Vim随时可以修理
your Emacs config the several times you'll broke it.
你的Emacs配置有几次你会破坏它。

* A good Windows version
一个好的Windows版本
:PROPERTIES:
属性:
:CUSTOM_ID: a-good-windows-version
:CUSTOM_ID a-good-windows-version
:END:
结束:

I've to use Windows at work and I was having a lot of problems with the official
我必须在工作时使用Windows，我和官方有很多问题
version of Emacs for Windows (slowness, unstability, huge memory usage spikes...).
适用于Windows的Emacs版本(缓慢、不稳定、巨大的内存使用峰值……)。
Reddit's user tuhdo read about my woes and suggested two versions of third party
Reddit的用户tuhdo读到我的伤心事后，建议我使用第三方的两个版本
packages of Windows Emacs. I've tested both and I can say that [[http://emacsbinw64.sourceforge.net/][this one]] is
Windows Emacs包。我已经测试了这两个，我可以说[[http://emacsbinw64.sourceforge.net/][这个]]是
definitively the best and solves all my problems.
绝对是最好的，能解决我所有的问题。

* Basic Emacs survival keys
基本的Emacs生存键
:PROPERTIES:
属性:
:CUSTOM_ID: basic-emacs-survival-keys
:CUSTOM_ID basic-emacs-survival-keys
:END:
结束:

If you're a Vim user after installing Evil you'll be using Vim-style commands most
如果您是安装Evil之后的Vim用户，那么您将使用最多的是vi风格的命令
of the time, but to install Evil first and for some modes where Evil doesn't work
但要先安装邪恶，并在某些模式下邪恶不能工作
(like the package manager) you'll need some basic cheatsheet of Emacs commands.
(与包管理器一样)您将需要一些基本的Emacs命令备忘单。

- C-g (that is Control and g at the same time) to cancel prompts. Later we'll
- C-g(同时是Control和g)取消提示。以后我们会
remap the escape key to do the same which anyone coming from Vim will need to
重新映射escape键来做任何来自Vim的人都需要做的事情
retain its sanity.
保持其完整性。
- C-x k to kill (close) a buffer. Automatically opened windows are
- C-x k杀死(关闭)一个缓冲区。自动打开的窗口有
usually closeable with “q”.
通常用“q”来关闭。
- C-x o (that's an “o” not a zero) to rotate between window
- C-x o(这是一个“o”不是一个零)之间的窗口旋转
- C-x 2 to create an horizontal split (window)
- C-x 2创建一个水平分割(窗口)
- C-x 3 to create a vertical split
- C-x 3创建一个垂直分裂
- M-x (M = Alt on PC) shows the “minibuffer” where you can call Emacs functions.
- M-x (M = Alt在PC上)显示“minibuffer”，你可以调用Emacs函数。
Later I'll show how to improve it a lot.
稍后我将展示如何改进它。
- To toggle long lines wrapping (like set wrap/nowrap in Vim), do M-x
-要切换长行换行(比如在Vim中设置换行/nowrap)，执行M-x
visual-line-mode RET.
visual-line-mode仓促。
- C-y: yank/paste. The only way to paste on the modeline even when you're using
- bxcy:猛拉/粘贴。这是在使用modeline时粘贴到modeline的惟一方法
Evil.
邪恶的。

* Package management
*包管理
:PROPERTIES:
属性:
:CUSTOM_ID: package-management
:CUSTOM_ID:包管理
:END:
结束:

The integrated plugin (package in emacspeak) manager is pretty good. It lists,
集成的插件(emacspeak中的包)管理器非常好。它列出了,
downloads, updates and install the packages in a breeze. I've tested almost all of
轻松下载、更新和安装包。我几乎测试了所有的
Vim's plugin managers and neither of them is close to this. You start it with =M-x list-packages= (enter to install, d to delete, x to execute deletions).
Vim的插件管理器，他们都不接近这一点。从=M-x list-packages=(输入安装，d删除，x执行删除)开始。

To add more sources to the package managers and to have a function that will load
向包管理器添加更多的源代码，并提供将加载的函数
packages and install them if missing (useful if you move your config between
包和安装他们如果失踪(有用如果你移动你的配置之间
computers) put this on your config file:
把这个放到你的配置文件里:

#+BEGIN_EXAMPLE
;; packages
(setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
("org" . "http://orgmode.org/elpa/")
("marmalade" . "http://marmalade-repo.org/packages/")
("melpa-stable" . "http://melpa-stable.milkbox.net/packages/")))
(package-initialize)

(defun require-package (package)
(setq-default highlight-tabs t)
"Install given PACKAGE."
(unless (package-installed-p package)
(unless (assoc package package-archive-contents)
(package-refresh-contents))
(package-install package)))
#+END_EXAMPLE

Note: as Phil suggested in the comments, the non-stable Melpa repository is risky
注意:正如Phil在评论中指出的，不稳定的Melpa存储库是有风险的
to have for newbies since it pulls directly from git master, I've used
对于新手来说，因为它直接从git master中获取，所以我使用过
melpa-stable in the config example, if you want to use Melpa just remove the
在配置的例子中，如果你想使用Melpa，只要删除
“-stable” from both the name and URL in the config.
配置中的名称和URL中的“-stable”。

* Evil (Vim emulation)
*邪恶(Vim仿真)
:PROPERTIES:
属性:
:CUSTOM_ID: evil-vim-emulation
:CUSTOM_ID evil-vim-emulation
:END:
结束:

It's fucking impressive. I don't miss any text command, operator, motion or
这是他妈的让人印象深刻。我不怀念任何文本命令，操作符，运动或
work flow from Vim. Marks, paragraph reformatting, visual mode, visual block,
工作流程从Vim。标记，段落重新格式化，可视模式，可视块，
macros, registers, text objects, splits (vertical, horizontal, :normal, folding,
宏，寄存器，文本对象，分割(垂直，水平，正常，折叠，
etc)... it has almost everything.
等)……它几乎什么都有。

Of course Vim plugins doesn't work, but there are Emacs or Evil alternatives for
当然，Vim插件不能工作，但是有Emacs或者邪恶的替代品
most of them.
他们中的大多数。

* Themes
*主题
:PROPERTIES:
属性:
:CUSTOM_ID: themes
:CUSTOM_ID:主题
:END:
结束:

You can use M-x load-theme RET to check the available themes (you can install more
可以使用M-x load-theme RET检查可用的主题(可以安装更多主题)
with the package manager). Once you have chosen one theme, put in .emacs:
与包管理器)。一旦你选择了一个主题，输入。emacs:
=(load-theme 'misterioso t)=.
= (load-theme '神秘的t) =。

* Terminal Colors
*终端颜色
:PROPERTIES:
属性:
:CUSTOM_ID: terminal-colors
:CUSTOM_ID terminal-colors
:END:
结束:

By default, most themes look like shit on terminal Emacs (emacs -nw if you don't
默认情况下，大多数主题在终端Emacs上看起来很糟糕(如果不这样的话，Emacs -nw)
want the window to open). On Vim some themes too, but in Emacs this happens with
想让窗户打开)。在Vim中也有一些主题，但是在Emacs中就有
almost all of them. This can improve a lot installing the color-theme-approximate
几乎全部。这可以大大提高安装的色彩-主题-近似值
package with makes the same thing as CSApprox in Vim: translate colors to their
package with在Vim中与CSApprox做同样的事情:将颜色转换为它们的颜色
console equivalents. Once installed add this to your .emacs:
控制台的等价物。安装后，将其添加到您的.emacs:
=(color-theme-approximate-on)=. If it doesn't work try to put the line lower in
= (color-theme-approximate-on) =。如果不行，试着把线放低一点
the .emacs file (it happened to me). If everything still look like shit check that
emacs文件(发生在我身上)。如果一切看起来还是那么糟糕，检查一下
you have the correct TERM environment variable set (hint: is different inside
您已经设置了正确的术语环境变量(提示:内部是不同的
screen or tmux).
屏幕或tmux)。

* Change cursor color depending on mode
*根据模式改变光标颜色
:PROPERTIES:
属性:
:CUSTOM_ID: change-cursor-color-depending-on-mode
:CUSTOM_ID change-cursor-color-depending-on-mode
:END:
结束:

This is something that I liked to have in Vim. Fortunately, you can also have it
这是我喜欢在Vim中拥有的东西。幸运的是，你也可以拥有它
in Emacs. Unfortunately, I've been unable to get in working on non-GUI emacs:
在Emacs。不幸的是，我一直无法在工作的非gui emacs:

#+BEGIN_EXAMPLE
(setq evil-emacs-state-cursor '("red" box))
(setq evil-normal-state-cursor '("green" box))
(setq evil-visual-state-cursor '("orange" box))
(setq evil-insert-state-cursor '("red" bar))
(setq evil-replace-state-cursor '("red" bar))
(setq evil-operator-state-cursor '("red" hollow))
#+END_EXAMPLE

* Tabs
*选项卡
:PROPERTIES:
属性:
:CUSTOM_ID: tabs
:CUSTOM_ID:标签
:END:
结束:

If you install the evil-tabs package and enable it with =(global-evil-tabs-mode t)= you'll have =:tabnew=, =gt= and friends with numbered tabs by default. Showing
如果您安装了evil-tabs包，并使用=(global-evil-tab -制表符模式t)=启用它，您将拥有=:tabnew=、=gt=和默认情况下带有编号制表符的friends。显示
the tab number is a very useful feature when you can change to a tab with =#gt=
当您可以使用=#gt=切换到选项卡时，选项卡号是一个非常有用的特性
like in Vim (with =#= being a number from 0 to 9), but unfortunately this package
就像在Vim中一样(=#=是一个从0到9的数字)，但不幸的是这个包
doesn't support =#gt= but I worked it around with my awesome Elisp skills (close
不支持=#gt=，但我用我可怕的Elisp技能解决了它
to zero):
为零):

#+BEGIN_EXAMPLE
(define-key evil-normal-state-map (kbd "C-0") (lambda() (interactive) (elscreen-goto 0)))
(define-key evil-normal-state-map (kbd "C- ") (lambda() (interactive) (elscreen-goto 0)))
(define-key evil-normal-state-map (kbd "C-1") (lambda() (interactive) (elscreen-goto 1)))
(define-key evil-normal-state-map (kbd "C-2") (lambda() (interactive) (elscreen-goto 2)))
(define-key evil-normal-state-map (kbd "C-3") (lambda() (interactive) (elscreen-goto 3)))
(define-key evil-normal-state-map (kbd "C-4") (lambda() (interactive) (elscreen-goto 4)))
(define-key evil-normal-state-map (kbd "C-5") (lambda() (interactive) (elscreen-goto 5)))
(define-key evil-normal-state-map (kbd "C-6") (lambda() (interactive) (elscreen-goto 6)))
(define-key evil-normal-state-map (kbd "C-7") (lambda() (interactive) (elscreen-goto 7)))
(define-key evil-normal-state-map (kbd "C-8") (lambda() (interactive) (elscreen-goto 8)))
(define-key evil-normal-state-map (kbd "C-9") (lambda() (interactive) (elscreen-goto 9)))
(define-key evil-insert-state-map (kbd "C-0") (lambda() (interactive) (elscreen-goto 0)))
(define-key evil-insert-state-map (kbd "C- ") (lambda() (interactive) (elscreen-goto 0)))
(define-key evil-insert-state-map (kbd "C-1") (lambda() (interactive) (elscreen-goto 1)))
(define-key evil-insert-state-map (kbd "C-2") (lambda() (interactive) (elscreen-goto 2)))
(define-key evil-insert-state-map (kbd "C-3") (lambda() (interactive) (elscreen-goto 3)))
(define-key evil-insert-state-map (kbd "C-4") (lambda() (interactive) (elscreen-goto 4)))
(define-key evil-insert-state-map (kbd "C-5") (lambda() (interactive) (elscreen-goto 5)))
(define-key evil-insert-state-map (kbd "C-6") (lambda() (interactive) (elscreen-goto 6)))
(define-key evil-insert-state-map (kbd "C-7") (lambda() (interactive) (elscreen-goto 7)))
(define-key evil-insert-state-map (kbd "C-8") (lambda() (interactive) (elscreen-goto 8)))
(define-key evil-insert-state-map (kbd "C-9") (lambda() (interactive) (elscreen-goto 9)))
#+END_EXAMPLE

Somebody with better Elisp skills please help me with a less kludgy solution, but
有更好的Elisp技能的人请帮助我一个不那么笨拙的解决方案，但是
this works (and it's in fact one key press less than =#gt=).
这是可行的(事实上，它是一个键按小于=#gt=)。

* Leader key
*领导的关键
:PROPERTIES:
属性:
:CUSTOM_ID: leader-key
:CUSTOM_ID leader-key
:END:
结束:

In order to define an use a =<leader>= prefix for your personal shortcuts you have
为了定义一个使用=<leader>=前缀你的个人快捷方式
to install the package evil-leader and put lines like these on your .emacs (I use
安装evil-leader包并在.emacs(我使用
comma as a leader key):
逗号作为主键):

#+BEGIN_EXAMPLE
(global-evil-leader-mode)
(evil-leader/set-leader ",")
#+END_EXAMPLE

Later, I found that the key didn't work on some modes (like when editing
后来，我发现这个键在某些模式下不起作用(比如编辑时)
the .emacs file in emacs-lisp-mode), but the package FAQ solved the problem, you
emacs文件在emacs-lisp模式下)，但是软件包FAQ解决了这个问题
have to add this before the =global-evil-leader-mode= setting:
必须在=global-evil-leader-mode=设置之前添加:

#+BEGIN_EXAMPLE
(setq evil-leader/in-all-states 1)
#+END_EXAMPLE

* Sessions (:mksession in Vim)
*会话(:Vim中的mksession)
:PROPERTIES:
属性:
:CUSTOM_ID: sessions-mksession-in-vim
:CUSTOM_ID sessions-mksession-in-vim
:END:
结束:

Emacs have the commands =M-x desktop-save= and =desktop-read=. To have it
Emacs命令=M-x desktop-save=和=desktop-read=。它
automatically saved/restored put into the .emacs: =(desktop-save-mode 1)=. If you
自动保存/恢复后放入.emacs: =(桌面保存模式1)=。如果你
want to start emacs without auto loading the session (if you configured it), the
要在不自动加载会话的情况下启动emacs(如果您配置了它)，则
command is =emacs --no-desktop=. But Emacs sessions doesn't know about elscreens
命令is =emacs——no-desktop=。但是Emacs会话并不知道elscreen
(which evil-tabs use for creating Vim-like tabs) so if you want to save and
(evil-tabs用于创建类vm的制表符)
restore full sessions including tabs copy these functions into your config file
恢复完整的会话，包括标签复制这些功能到你的配置文件
and assign them some shortcut:
给他们分配一些捷径:

#+BEGIN_EXAMPLE
;; Save session including tabs
;; http://stackoverflow.com/questions/22445670/save-and-restore-elscreen-tabs-and-split-frames
(defun session-save ()
"Store the elscreen tab configuration."
(interactive)
(if (desktop-save emacs-configuration-directory)
(with-temp-file elscreen-tab-configuration-store-filename
(insert (prin1-to-string (elscreen-get-screen-to-name-alist))))))

;; Load session including tabs
(defun session-load ()
"Restore the elscreen tab configuration."
(interactive)
(if (desktop-read)
(let ((screens (reverse
(read
(with-temp-buffer
(insert-file-contents elscreen-tab-configuration-store-filename)
(buffer-string))))))
(while screens
(setq screen (car (car screens)))
(setq buffers (split-string (cdr (car screens)) ":"))
(if (eq screen 0)
(switch-to-buffer (car buffers))
(elscreen-find-and-goto-by-buffer (car buffers) t t))
(while (cdr buffers)
(switch-to-buffer-other-window (car (cdr buffers)))
(setq buffers (cdr buffers)))
(setq screens (cdr screens))))))
#+END_EXAMPLE

* Accents
*口音
:PROPERTIES:
属性:
:CUSTOM_ID: accents
:CUSTOM_ID:口音
:END:
结束:

Accents didn't work for me on GUI mode, only in text mode. That was fixed adding
重音符号在GUI模式下不起作用，只在文本模式下起作用。这是固定的加法
=(require 'iso-transl)= to my .emacs.
=(require 'iso-transl)=到我的。emacs。

* “After” macro definition
*“后”宏定义
:PROPERTIES:
属性:
:CUSTOM_ID: after-macro-definition
:CUSTOM_ID after-macro-definition
:END:
结束:

I have an “after” macro defined that I copied from someone config file (can't remember who - sorry). This is
我有一个“后”宏定义，我从别人的配置文件复制(不记得是谁-对不起)。这是
useful to specifiy code to be executed after some plugin has loaded.
特别有用的代码后执行一些插件加载。

The definition is on my config file as:
定义在我的配置文件中如下:

#+BEGIN_EXAMPLE
;; "after" macro definition
(if (fboundp 'with-eval-after-load)
(defmacro after (feature &rest body)
"After FEATURE is loaded, evaluate BODY."
(declare (indent defun))
`(with-eval-after-load ,feature ,@body))
(defmacro after (feature &rest body)
"After FEATURE is loaded, evaluate BODY."
(declare (indent defun))
`(eval-after-load ,feature
'(progn ,@body))))))
#+END_EXAMPLE

* Vim-like search highlighting
*类似vm的搜索突出显示
:PROPERTIES:
属性:
:CUSTOM_ID: vim-like-search-highlighting
:CUSTOM_ID vim-like-search-highlighting
:END:
结束:

I prefer how Vim's highlight search and left the highlighted terms until you make
我更喜欢Vim的高亮显示搜索，并留下高亮显示的术语，直到您作出
another search or clean the highlighted terms. I tough this would be easy to get
再次搜索或清除高亮显示的术语。我想这很容易得到
but it turned it wasn't so easy (for me). At the end I made my first Emacs
但事实证明，(对我来说)这并不容易。最后，我制作了我的第一个Emacs
extension (and the first time I've programmed in Lisp since the university a long
这是我从大学以来第一次用Lisp编程
time ago...) so all turned well. [[https://github.com/juanjux/evil-search-highlight-persist][The extension]] is already on Melpa has the
所以一切都变好了。[[https://github.com/juan/evil -search- high- persist][扩展]]已经在Melpa已经
very brief name of =evil-search-highlight-persist=. You can enable it with:
非常简短的名称=evil-search- high- persist=。你可以用以下方法启用:

#+BEGIN_EXAMPLE
(require 'evil-search-highlight-persist)
(global-evil-search-highlight-persist t)
#+END_EXAMPLE

To map a shortcut (leader-space) to clear the highlights I have:
地图捷径(领导空间)，以清除我的亮点:

#+BEGIN_EXAMPLE
(evil-leader/set-key "SPC" 'evil-search-highlight-persist-remove-all)
#+END_EXAMPLE

I must note that another good way to search in Emacs is to use =occur= or
我必须指出，在Emacs中搜索的另一个好方法是使用= occurs = or
=helm-occur=. This will show the search results on a list (on a split window with
= helm-occur =。这将显示搜索结果在一个列表(在一个分裂窗口与
occur) and you'll be able to jump easily to any match.
发生)，你将能够很容易地跳转到任何比赛。

* Helm: Unite/CtrlP style fuzzy file/buffer/anything searcher on steroids
*头盔:统一/CtrlP风格的模糊文件/缓冲区/任何搜索类固醇
:PROPERTIES:
属性:
:CUSTOM_ID: helm-unitectrlp-style-fuzzy-filebufferanything-searcher-on-steroids
:CUSTOM_ID helm-unitectrlp-style-fuzzy-filebufferanything-searcher-on-steroids
:END:
结束:

Helm does the same thing as Unite/CtrlP on Vim and does it really well. You can
Helm在Vim上做的和Unite/CtrlP一样，而且做得非常好。你可以
also enable Helm to manage the command buffer, which is pretty awesome with:
还启用赫尔姆管理命令缓冲区，这是非常可怕的:
=(helm-mode 1)= in the .emacs file. I also configured a shortcut in normal mode,
=(helm-mode 1)=在.emacs文件中。我还在普通模式下配置了一个快捷方式，
=SPACE SPACE= which is the same I was using with Vim. This can be done with:
=SPACE =和我在Vim中使用的相同。这可以做到:
=(define-key evil-normal-state-map " " 'helm-mini)=.
=(define-key evil-normal-state-map " " 'helm-mini)=。

But Helm can be really configurable and you can include or exclude modules in the
但是Helm是可配置的你可以在。中包含或排除模块
helm interface show with the shortcut associated to your config, for example I've:
helm界面显示与你的配置相关的快捷方式，例如我有:

#+BEGIN_EXAMPLE
;; helm settings (TAB in helm window for actions over selected items,
;; C-SPC to select items)
(require 'helm-config)
(require 'helm-misc)
(require 'helm-projectile)
(require 'helm-locate)
(setq helm-quick-update t)
(setq helm-bookmark-show-location t)
(setq helm-buffers-fuzzy-matching t)

(after 'projectile
(package 'helm-projectile))
(global-set-key (kbd "M-x") 'helm-M-x)

(defun helm-my-buffers ()
(interactive)
(let ((helm-ff-transformer-show-only-basename nil))
(helm-other-buffer '(helm-c-source-buffers-list
helm-c-source-elscreen
helm-c-source-projectile-files-list
helm-c-source-ctags
helm-c-source-recentf
helm-c-source-locate)
"*helm-my-buffers*")))
#+END_EXAMPLE

Here, I define a “helm-my-buffers” function that when called (assign a shortcut to
在这里，我定义了一个“helm-my-buffers”函数，当调用该函数时(为其分配一个快捷方式)
it!) will show Helm interface but searching (fuzzy, real time as you write,
将显示头盔界面，但搜索(模糊，实时你写，
unordered) in open buffers, recent files, project files (see below for more on
在打开的缓冲区，最近的文件，项目文件(见下面的更多
that), tags inside the files, tabs and results from the Linux command =locate=
，文件、选项卡中的标记和Linux命令的结果=locate=
that searches quickly from a database of all the files in the file system. How
它可以从文件系统中所有文件的数据库中快速搜索。如何
awesome is that?
这是可怕的呢?

But this is only the tip of the iceberg of Helm power. There are =sources= for
但这只是掌舵能力的冰山一角。有=来源=
searching the symbols (functions, classes, globals, etc) in the current buffer
在当前缓冲区中搜索符号(函数、类、全局变量等)
(=helm-imenu=), bookmarks (including Chrome/Firefox bookmarks), HTML colors
(=helm-imenu=)，书签(包括Chrome/Firefox书签)，HTML颜色
(showing the color, name, and hexadecimal code), apt packages and more.
(显示颜色、名称和十六进制代码)、apt包等等。

If you check the sources of the =helm-my-buffers= function above you can see that
如果检查上面的=helm-my-buffers=函数的源代码，就可以看到这一点
I'm also using =helm-c-source-projectile-files-list=. This will use another
我还使用了=helm-c-source-project -files-list=。这将使用另一个
installable third party package called Projectile that will search for a
可安装的第三方包称为射弹，将搜索一个
git/hg/svn file in the current directory and its parents and extract the current
说明:git/hg/svn文件在当前目录及其父目录下，并提取当前。-
project files. Linking it will Helm makes it super easy to open any file in your
项目文件。链接它将头盔使它超级容易打开任何文件在您的
current project (providing you've it under version control) without having the
当前项目(如果您已将其置于版本控制之下)没有
browse the filesystem, even for files that you have never opened (and thus are not
浏览文件系统，即使是您从未打开过的文件(因此也没有打开)
in Emacs' recent files list).
在Emacs的最近文件列表中)。

Another good combination of Helm with a nice Emacs feature (this time included by
Helm与一个很好的Emacs特性的另一个很好的组合(这次包括由
default) is helm-imenu. iMenu is a pretty smart minor mode that extract
helm-imenu默认)。iMenu是一款非常聪明的小众模式提取器
“locations” inside a buffer. For code in a programming language this will be
缓冲区中的“位置”。对于编程语言中的代码，这将是
typically the classes, methods and other symbols. Calling helm-imenu instead of
通常是类、方法和其他符号。而不是叫helm-imenu
the default imenu will make it very easy to jump quickly to a location inside the
默认的imenu将使它很容易快速跳转到一个位置内
buffer just writing a couple of letters.
缓冲器只是写几个字母。

Another great feature of Helm is the chance to replace the default “M-x” menu
Helm的另一个重要特性是可以替换默认的“M-x”菜单
interface. M-x is what you use to issue Emacs commands, a little like “:” in Vim
接口。M-x是用来发出Emacs命令的，有点像Vim中的“:”
(but only a little, ex mode in Vim or Evil is another kind of animal). One great
(但只有一点点，前模式在Vim或邪恶是另一种动物)。一个巨大的
thing about Emacs is that it has commands and modes for a lot of things, and with
关于Emacs，它有很多命令和模式
Helm M-x you don't have to learn them all. For example if I don't remember how to
你不必全学。例如，如果我不记得怎么做
show white space characters I just press M-x and start to write =whitesp=... and
显示空白字符我只要按M-x并开始写=whitesp=…和
Helm will show me as first result =whitespace-mode= which is exactly what I want
Helm将显示为first result =whitespace-mode=这正是我想要的
(it also showed =whitespace-cleanup= that clears all the trailing whitespace and
(它还显示=whitespace-cleanup=清除所有尾随的空白和
that is how I discovered it). Want to check the commands related to spelling? =M-x spell=. How to list errors in the code with flycheck? =M-x fly errors=. How to
我就是这样发现它的)。想要检查与拼写相关的命令吗?= m x =。如何用flycheck列出代码中的错误?= = m x飞错误。如何
sort the lines of a selection? =M-x sort=. This is really convenient and as an
对选择的行进行排序?= m x =。这真的很方便
Emacs newbie I get a lot of things done just searching in Helm-M-x without having
我做了很多事情，只是在Helm-M-x搜索没有
to search on Google. You can map Helm-M-x to M-x with:
在谷歌上搜索。您可以映射Helm-M-x到M-x与:

#+BEGIN_EXAMPLE
(global-set-key (kbd "M-x") 'helm-M-x)
#+END_EXAMPLE

There is another package that also helps when learning to use a specific mode,
当学习使用一种特定的模式时，还有另一个程序包也有帮助，
it's called “Discover My Major” (=discover-my-major= in Melpa). Invoking the
它叫做“发现我的专业”(= discovery - My - Major = in Melpa)。调用
command with the same name will show all the functions enabled by the current
同名的命令将显示当前命令所启用的所有函数
major mode. It's great to discover what every mode can do.
主要模式。发现每种模式都能做什么是很好的。

There is another package that also helps when learning to use a specific mode,
当学习使用一种特定的模式时，还有另一个程序包也有帮助，
it's called “Discover My Major” (=discover-my-major= in Melpa). Invoking the
它叫做“发现我的专业”(= discovery - My - Major = in Melpa)。调用
command with the same name will show all the functions enabled by the current
同名的命令将显示当前命令所启用的所有函数
major mode. It's great to discover what every mode can do.
主要模式。发现每种模式都能做什么是很好的。

Edit: thanks to tuhdo in the comments who told me how to show the full path of
编辑:感谢tuhdo在评论中告诉我如何显示完整的路径
the files in the helm-recentf sources).
helm-recentf源中的文件)。

* Vim's Marks => Evil's Marks + Emacs' Bookmarks
* Vim's Marks => Evil's Marks + Emacs' Bookmarks
:PROPERTIES:
属性:
:CUSTOM_ID: vims-marks-gt-evils-marks-emacs-bookmarks
:CUSTOM_ID vims-marks-gt-evils-marks-emacs-bookmarks
:END:
结束:

Evil has marks just like Vim: =m= to jump to a mark, =m-letter= to set a mark,
邪恶有标记，就像Vim: =m=跳到一个标记，=m-字母=设置一个标记，
=m-uppercase_letter= to set a mark that works between buffers. But while marks are
=m-uppercase_letter=设置缓冲区之间工作的标记。但是当标记是
pretty useful for example to quickly jump between two or three positions inside
非常有用，例如，在两个或三个位置之间快速跳转
some files when you're coding, Emacs also has the concept of “bookmarks” that are
在编写代码时，Emacs也有“书签”的概念
like inter-file marks that you can set with a name (instead of a letter) and that
比如文件间的标记，你可以用名字(而不是字母)来设置
with the elisp bit below in your config file can be saved between sessions. I'm
使用下面配置文件中的elisp位可以在会话之间保存。我
using =helm-bookmarks= to see and set them, which I've mapped to =SPC-b=. To delete
使用=helm-bookmarks=查看和设置它们，我已经将它们映射到=SPC-b=。删除
bookmarks, press =TAB= inside the helm sub-window to see the list of actions and
书签，按=TAB=在helm子窗口内查看操作和列表
choose “Delete Bookmark(s)”.
选择“删除书签(s)”。

#+BEGIN_EXAMPLE
;; save bookmarks
(setq bookmark-default-file "~/.emacs.d/bookmarks"
bookmark-save-flag 1) ;; save after every change
#+END_EXAMPLE

* Folding... and narrowing!
*折叠……和缩小!
:PROPERTIES:
属性:
:CUSTOM_ID: folding-and-narrowing
:CUSTOM_ID folding-and-narrowing
:END:
结束:

Folding with Evil works as expected, using the same operators that in Vim (with
与预期一样，使用与Vim相同的操作符(with
the added benefit that if you're using Helm-M-x you can do =M-x RET fold= to
如果您使用的是Helm-M-x，那么附加的好处是您可以做=M-x RET fold= to
search the folding commands in case you forgot the Vim-style operator). Emacs also
搜索折叠命令，以防忘记了vi样式的操作符)。Emacs也
support an interesting feature called “narrowing”. Narrowing will hide everything else
支持一个有趣的特性，称为“窄化”。缩小将隐藏所有其他内容
in the file except the narrowed function or region. This is pretty useful when you
在文件中除缩小的函数或区域外。这是非常有用的
want to make global replaces or run some macro but don't want to affect the other
想要使全局替换或运行一些宏，但不想影响另一个
parts of the buffer. I don't use it much so I haven't assigned any shortcut, I
缓冲的一部分。我不经常使用它，所以我没有分配任何捷径，我
just use the commands =narrow-to-region= and =narrow-to-defun=. Once you have
只需使用命令=narrow-to-region=和=narrow-to-defun=。一旦你有了
finished working on the narrowed region, you can display the rest of the buffer
完成对缩小区域的处理后，可以显示缓冲区的其余部分
again with the =widen= command.
再次使用=加宽=命令。

* Project Management
*项目管理
:PROPERTIES:
属性:
:CUSTOM_ID: project-management
:CUSTOM_ID:项目管理
:END:
结束:

I've already mentioned Projectile that combined with Helm makes searching for
我已经提到了与Helm相结合的射弹
project files very convenient, but there are other options. One of them is
项目文件非常方便，但还有其他选项。其中之一是
project-explorer, which is pretty much like Vim “project” script: when you enable
project-explorer，它很像Vim“项目”脚本:当您启用它时
it it will show a side split (sorry, window) with your project files. With Helm +
它将显示一个侧边分裂(抱歉，窗口)与您的项目文件。执掌+
Helm-Projectile + the file explorer it's rarely needed but from time to time it's
很少需要它，但有时它是
nice to have a tree view of a source code project (more if the code isn't yours).
很高兴有一个源代码项目的树视图(如果代码不是你的，那就更多了)。
The Windows can be opened with the command “project-explorer-open” (I didn't
窗口可以用“project-explorer-open”命令打开(我没有打开)
assign any shortcut to it). One thing to note if you're using Evil is that the
分配任何快捷方式)。需要注意的是，如果你使用的是Evil
shortcuts like TAB to toggle a folder subtree only work if you're in insert mode.
只有在插入模式下，TAB之类的快捷键才能切换文件夹子树。

#+BEGIN_EXAMPLE
(package 'project-explorer)
(after 'project-explorer
(setq pe/cache-directory "~/.emacs.d/cache/project_explorer")
(setq pe/omit-regex (concat pe/omit-regex "\|single_emails")))
#+END_EXAMPLE

Emacs use a tags file format with a syntax that is different from the “default”
Emacs使用不同于“默认”语法的标记文件格式
ctags called “etags”. Generating etags is easy since Exuberant-Ctags already know
ctags称为“etag”。生成etags很容易，因为繁茂的ctags已经知道
how to generate them (just add a =-e= switch). Emacs distributions usually came
如何生成它们(只需添加一个=-e= switch)。Emacs发行版通常会出现
with an etags binary (I'm using ctags because there is a patched version with
一个etags二进制(我使用ctags，因为有一个补丁版本与
support for the [[http://dlang.org][D language]] but Emacs's etag binary doesn't support it).
支持[[http://dlang.org][D语言]]，但是Emacs的etag二进制文件不支持它)。
Once generated Emacs will ask you where the tags file is the first time you use
一旦生成Emacs，它将询问您第一次使用标记文件的位置
any tag command (like =find-tag= or =evil-jump-to-tag= to jump to the specified
任何标签命令(如=find-tag=或=evil-jump-to-tag=跳转到指定的
tag) and once loaded it will remember it (at least for the current session, I
一旦加载，它将记住它(至少对于当前会话，I
still need to find how to make it remember the path between sessions).
仍然需要找到如何使它记住会话之间的路径)。

I've defined this =create-tags= function on my .emacs to regenerate the tags files
我在.emacs上定义了这个=create-tags=函数来重新生成标记文件
(it will ask for a directory and then use that directory as root from where to
(它将请求一个目录，然后使用该目录作为根目录
scan and place to store the =tags= file):
扫描并存放=tags=文件):

#+BEGIN_EXAMPLE
;; etags
(cond ((eq system-type 'windows-nt)
(setq path-to-ctags "C:/installs/gnuglobal/bin/ctags.exe")))
(cond ((eq system-type 'gnu/linux)
(setq path-to-ctags "/usr/local/bin/ctags")))

(defun create-tags (dir-name)
"Create tags file."
(interactive "DDirectory: ")
;; (message
;; (format "%s -f %s/tags -eR %s"
path-to-ctags (directory-file-name dir-name) (directory-file-name
dir-name)))
(shell-command
(format "%s -f %s/tags -eR %s" path-to-ctags
(directory-file-name dir-name) (directory-file-name dir-name)))
)
#+END_EXAMPLE

With third party packages there is also support for normal ctags files and GNU
第三方包也支持普通的ctags文件和GNU
Global, but I find the etags support more than convenient for my needs
但我发现etags支持超过方便我的需要

* Spell checking
*拼写检查
:PROPERTIES:
属性:
:CUSTOM_ID: spell-checking
:CUSTOM_ID:拼写检查
:END:
结束:

No need to install anything if you have ispell on your system, just do:
如果你的系统上有ispell，不需要安装任何东西，只要:
=:ispell-buffer= to start a spell check of the current buffer (alternatives are
=:ispel -buffer=启动当前缓冲区的拼写检查(可选方法有
show above and shortcuts below) and =:ispell-change-dictionary= to use another
和=:ispel -change-dictionary=使用另一个
dictionary (to check another language). If you prefer spell checking on the fly
查字典(查另一种语言)。如果你更喜欢动态拼写检查
with underlines under misspelled words use =:flyspell-mode= and to see
在拼错的单词下面加上下划线，使用=:flyspell-mode=和to see
alternatives to a misspelled word press =M-$= (=Alt-$= on most PCs) with the
替换一个拼写错误的单词press =M-$= (=Alt-$=在大多数pc上)
cursor over the word.
把光标移到这个词上。

* Relative line numbers
*相对行号
:PROPERTIES:
属性:
:CUSTOM_ID: relative-line-numbers
:CUSTOM_ID relative-line-numbers
:END:
结束:

Install the package “relative-line-numbers” and enable it globally on
安装包“相对行号”并全局启用它
your config file with:
你的配置文件:

#+BEGIN_EXAMPLE
(add-hook 'prog-mode-hook 'relative-line-numbers-mode t)
(add-hook 'prog-mode-hook 'line-number-mode t)
(add-hook 'prog-mode-hook 'column-number-mode t)
#+END_EXAMPLE

* Easymotion => Evil Ace Jump
* Easymotion =>邪恶王牌跳跃
:PROPERTIES:
属性:
:CUSTOM_ID: easymotion-gt-evil-ace-jump
:CUSTOM_ID easymotion-gt-evil-ace-jump
:END:
结束:

The functionality provided by the awesome Easymotion plugin on Vim is actually
Vim上的Easymotion插件提供的功能实际上是
integrated by default on Evil since it incorporates a package called Ace Jump
在Evil上默认集成，因为它包含了一个叫做Ace Jump的包
that does mostly the same. It's less powerful than Easymotion (some jumps like
基本上是一样的。它没有Easymotion强大(一些跳跃像
backwards-only / forward-only / end-of-word and others are missing) and I prefer
只向后/只向前/字尾和其他都没有)和我更喜欢
how Easymotion shows directly two chars when a jump is going to require them
当一个跳转需要两个字符时，Easymotion如何直接显示它们
(instead of showing one and after pressing it, the other which is what Ace-Jump
(而不是显示一个和按下它后，另一个是什么-跳
does) but the important modes (bidirectional jump to word and to char) that were
但是重要的模式(双向跳转到word和char)是吗
the ones I was mostly using are provided.
我主要使用的是提供的。

Unlike Easymotion, jump to word asks for a letter, but that can be easily disabled
与Easymotion不同，跳转到word请求一个字母，但这很容易被禁用
with: =(setq ace-jump-word-mode-use-query-char nil)=. The author makes the case
=(设置ac -jump-word-mode-use-query-char nil)=。作者提出了理由
that without asking for a char you're probably entering more key presses most of
在不要求char类型的情况下，你可能会输入更多的键
the time. This is probably true, but when I want to jump to a random word inside
时间。这可能是对的，但是当我想要跳到一个随机的单词里面
the buffer my brain-eye connection has already identified the word but I've to
我的脑-眼连接已经识别出了这个词，但我必须这么做
stop and look/think for the first char, so in the end for me is actually faster to
停下来，寻找/思考第一个字符，所以最后对我来说实际上更快
get jump shortcuts to all the words without having to provide the leading
获得所有单词的跳转快捷方式，而不必提供引导
character.
的性格。

I mapped the word/line/char to e/l/x with:
我将单词/line/char映射到e/l/x:

#+BEGIN_EXAMPLE
(evil-leader/set-key "e" 'evil-ace-jump-word-mode) ; ,e for Ace Jump (word)
(evil-leader/set-key "l" 'evil-ace-jump-line-mode) ; ,l for Ace Jump (line)
(evil-leader/set-key "x" 'evil-ace-jump-char-mode) ; ,x for Ace Jump (char)
#+END_EXAMPLE

* Smooth scrolling
*平滑滚动
:PROPERTIES:
属性:
:CUSTOM_ID: smooth-scrolling
:CUSTOM_ID:平滑滚动
:END:
结束:

One annoying thing that most Vim users will find in Emacs is the jumpy
大多数Vim用户在Emacs中发现的一个恼人的问题是jumpy
scrolling. To have Emacs scroll like Vim (that is, line by line and leaving some
滚动。让Emacs像Vim那样滚动(也就是说，一行一行地滚动，并留下一些内容)
lines before starting to scroll) the solution is to install the package
在开始滚动之前的行)解决方案是安装包
=smooth-scrolling= and add this to your config:
=平滑滚动=并添加到你的配置:

#+BEGIN_EXAMPLE
(setq scroll-margin 5
scroll-conservatively 9999
scroll-step 1)
#+END_EXAMPLE

It's not perfect because sometimes when you're close to the start of end of the
它不是完美的，因为有时当你接近结尾的开始
file it still jumps.
文件仍然会跳转。

* Powerline
*电力线
:PROPERTIES:
属性:
:CUSTOM_ID: powerline
:CUSTOM_ID:电力线
:END:
结束:

Super-easy, just install the powerline-evil package and put this in your config:
超级简单，只要安装电力线邪恶包，并把这个放在你的配置:

#+BEGIN_EXAMPLE
(require 'powerline)
(powerline-evil-vim-color-theme)
(display-time-mode t)
#+END_EXAMPLE

* Syntactic checking on the fly with Flycheck
*语法检查在飞行与Flycheck
:PROPERTIES:
属性:
:CUSTOM_ID: syntactic-checking-on-the-fly-with-flycheck
:CUSTOM_ID syntactic-checking-on-the-fly-with-flycheck
:END:
结束:

One of the best Vim plugins if you're a programmer is Syntastic that runs a
一个最好的Vim插件，如果你是一个程序员是Syntastic运行的
syntactic check auto detecting a huge variety of linters every time you
语法检查，自动检测的大量l每次你
save. Emacs also have a similar package called “Flycheck”. It is even better
保存。Emacs也有一个类似的包，称为“Flycheck”。甚至更好
because it runs in parallel while you work so you don't have to wait for it to
因为它在你工作的时候是并行运行的，所以你不必等待它
finish its checks like happens with Vim. Another related package is
像对待Vim一样完成它的检查。另一个相关的包是
=flycheck-pos-tip= that shows errors on a tooltip (if you're on GUI Emacs,
=flycheck-pos-tip=在工具提示上显示错误(如果您使用的是GUI Emacs，
obviously) instead of the minibuffer. My full flycheck config is:
而不是minibuffer。我的全部flycheck配置是:

#+BEGIN_EXAMPLE
;; flycheck
(package 'flycheck)
(add-hook 'after-init-hook #'global-flycheck-mode)

(after 'flycheck
(setq flycheck-check-syntax-automatically '(save mode-enabled))
(setq flycheck-checkers (delq 'emacs-lisp-checkdoc flycheck-checkers))
(setq flycheck-checkers (delq 'html-tidy flycheck-checkers))
(setq flycheck-standard-error-navigation nil))

(global-flycheck-mode t)

;; flycheck errors on a tooltip (doesnt work on console)
(when (display-graphic-p (selected-frame))
(eval-after-load 'flycheck
'(custom-set-variables
'(flycheck-display-errors-function #'flycheck-pos-tip-error-messages))))
#+END_EXAMPLE

* j/k for browsing wrapped lines
* j/k用于浏览换行
:PROPERTIES:
属性:
:CUSTOM_ID: jk-for-browsing-wrapped-lines
:CUSTOM_ID jk-for-browsing-wrapped-lines
:END:
结束:

Evil has the same problem as Vim when browsing with j/k long wrapped lines; it
邪恶有相同的问题Vim时，j/k长包装线浏览;它
jumps the entire “real” line instead of the visual line. The solution is also
跳过整个“实线”而不是视觉线。解决方案也是
easy:
容易:

#+BEGIN_EXAMPLE
(define-key evil-normal-state-map (kbd "j") 'evil-next-visual-line)
(define-key evil-normal-state-map (kbd "k") 'evil-previous-visual-line)
#+END_EXAMPLE

* escape... escapes things
*逃脱……逃脱的事情
:PROPERTIES:
属性:
:CUSTOM_ID: escape-escapes-things
:CUSTOM_ID escape-escapes-things
:END:
结束:

One very annoying thing with Emacs is that when you are in the =M-x= buffer (the
Emacs的一个非常恼人的问题是，当您在=M-x= buffer
one were you call Emacs functions) you've to use =C-g= to exit it. If you use
一个是你调用Emacs函数)你必须使用=C-g=来退出它。如果你使用
=escape= as most Vim users would tend to do by default you need to hit the key
=escape=正如大多数Vim用户在默认情况下所做的那样，您需要按下键
like a million times (it's more like 3, but it's extremely frustrating
就像一百万次(更像是3次，但是非常令人沮丧
anyway). This code on my .emacs that I copied from [[https://github.com/davvil/.emacs.d/blob/master/init.el][davvil init.el on Github]]
无论如何)。我从[[https://github.com/davvil/.emacs.d/blob/master/init.el][davvil init]复制的。埃尔在Github]]
fixed it:
固定:

#+BEGIN_EXAMPLE
;; esc quits
(defun minibuffer-keyboard-quit ()
"Abort recursive edit.
In Delete Selection mode, if the mark is active, just deactivate it;
then it takes a second \[keyboard-quit] to abort the minibuffer."
(interactive)
(if (and delete-selection-mode transient-mark-mode mark-active)
(setq deactivate-mark t)
(when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
(abort-recursive-edit)))
(define-key evil-normal-state-map [escape] 'keyboard-quit)
(define-key evil-visual-state-map [escape] 'keyboard-quit)
(define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
(global-set-key [escape] 'evil-exit-emacs-state)
#+END_EXAMPLE

* Start maximized, please
*请开始最大化
:PROPERTIES:
属性:
:CUSTOM_ID: start-maximized-please
:CUSTOM_ID start-maximized-please
:END:
结束:

Another minor annoyance was that Emacs (GUI) didn't start maximized by default, but
另一个小麻烦是Emacs (GUI)在默认情况下没有开始最大化，但是
this is easy to fix:
这很容易解决:

#+BEGIN_EXAMPLE
(custom-set-variables
'(initial-frame-alist (quote ((fullscreen . maximized))))) ;; start maximized
#+END_EXAMPLE

* c-k/c-j for page down/up
* c-k/c-j表示向下/向上的页面
:PROPERTIES:
属性:
:CUSTOM_ID: c-kc-j-for-page-downup
:CUSTOM_ID c-kc-j-for-page-downup
:END:
结束:

One thing that surprised me considering how complete Evil is, is the lack of Vim's
考虑到邪恶是如此的彻底，有一件事让我惊讶，那就是没有Vim
Control-d/Control-u for page down/up. Probably because C-u is pretty important in
Control-d/Control-u用于向下/向上页面。可能因为C-u非常重要
Emacs (it's the shortcut to give a numeric parameter to other commands, I think).
Emacs(我认为这是为其他命令提供数字参数的快捷方式)。
I've in fact these mapped on my .vimrc to c-k/c-j (because I think they're more
事实上，我已经把这些映射到我的。vimrc到c-k/c-j(因为我认为它们更
consistent with Vim's j/k movement keys) so that's how I mapped them in Emacs:
与Vim的j/k移动键一致)所以这就是我在Emacs中映射它们的方式:

#+BEGIN_EXAMPLE
(define-key evil-normal-state-map (kbd "C-k") (lambda ()
(interactive)
(evil-scroll-up nil)))
(define-key evil-normal-state-map (kbd "C-j") (lambda ()
(interactive)
(evil-scroll-down nil)))
#+END_EXAMPLE

* Coding Style and spaces instead of tabs
*编写样式和空格，而不是制表符
:PROPERTIES:
属性:
:CUSTOM_ID: coding-style-and-spaces-instead-of-tabs
:CUSTOM_ID coding-style-and-spaces-instead-of-tabs
:END:
结束:

Emacs by default do the really evil thing of using tab characters for
默认情况下，Emacs做了一件非常糟糕的事情:使用制表符
indentation. To do the right thing and use spaces with 4 spaces per tab:
缩进。正确的做法和使用空格与4空格每标签:
=(setq-default tab-width 4 indent-tabs-mode nil)=. Also, I prefer the “bsd” style
=(setq-default tab-width 4 indent-tab -mode nil)=另外，我更喜欢“bsd”风格
on my code on C-like languages (C, C++, Java, D...) but with 4 spaces tabs
在我的代码上的C类语言(C, c++， Java, D…)，但有4个空格标签
instead of 8 so I also added: =(setq-default c-basic-offset 4 c-default-style "bsd")=.
因此，我还添加了:=(setq-default c-basic-offset 4 c-default style "bsd")。

There is also a nice package called “dtrt-indent” that can automatically determine
还有一个很好的程序包叫做“dtrt-indent”，可以自动确定
the indentation settings used on the file that you're currently editting and adapt
正在编辑和调整的文件上使用的缩进设置
Emacs's settings to them. It's great when you're editing external files not
Emacs的设置。当你编辑外部文件时，这是很好的
created by you or that for some reason follow different indentation rules that the
由您创建的或由于某种原因遵循不同的缩进规则
ones you've in your config file.
在你的配置文件中。

#+BEGIN_EXAMPLE
(package 'dtrt-indent)
(dtrt-indent-mode 1)
#+END_EXAMPLE

* Auto-indent with the Return key
*使用返回键自动缩进
:PROPERTIES:
属性:
:CUSTOM_ID: auto-indent-with-the-return-key
:CUSTOM_ID auto-indent-with-the-return-key
:END:
结束:

By default Emacs doesn't indent new lines until you press the TAB key. That is not
默认情况下，Emacs在按TAB键之前不会缩进新行。这并不是
good. But it can be changed easily enough to do the Vim thing, adjusting
好。但它可以很容易地改变，足以做Vim的事情，调整
indentation on every new line automatically with:
每行自动缩进:

#+BEGIN_EXAMPLE
(define-key global-map (kbd "RET") 'newline-and-indent)
#+END_EXAMPLE

* Show matching paren
*显示匹配的参数
:PROPERTIES:
属性:
:CUSTOM_ID: show-matching-paren
:CUSTOM_ID show-matching-paren
:END:
结束:

If you want to show the matching parenthesis, brace or bracket automatically, add
如果要自动显示匹配的括号、大括号或括号，请添加
this option: =(show-paren-mode t)=. You can also install the Autopairs package to
这个选项:=(show- pareni -mode t)=。您还可以安装Autopairs软件包
automatically add the matching parens/braces/etc after adding the opening one.
在添加开始的括号后，自动添加匹配的括号/括号/等等。
I've mixed feelings about it because while very convenient (specially with Lisp!)
我对它有复杂的感觉，因为虽然它非常方便(特别是使用Lisp!)
it can be also very annoying when you want to surround something with parents and
当你想要和父母在一起的时候也会很烦人
it adds a useless “)” after the opening one, I should use “Surround” on these
它增加了一个无用的“)”在打开一个，我应该使用“环绕”这些
cases, but half of the time I forget it. To enable autopairs put this on your
但是有一半的时间我忘记了。要开启自动驾驶，把这个放在你的
config file after installing the package:
安装包后的配置文件:

#+BEGIN_EXAMPLE
(require 'autopair)
(autopair-global-mode)
#+END_EXAMPLE

* Fill column, auto line breaking and column limit mark
*填充列、自动断行和列限制标记
:PROPERTIES:
属性:
:CUSTOM_ID: fill-column-auto-line-breaking-and-column-limit-mark
:CUSTOM_ID fill-column-auto-line-breaking-and-column-limit-mark
:END:
结束:

To visually mark the configured fill-column for the mode (like the =colorcolumn=
以可视方式标记模式配置的填充列(如=colorcolumn=)
option in Vim) install the package =fill-column-indicator=, then you'll enable it
安装package =fill-column-indicator=，然后启用它
on every mode where you want to display it with =fci-mode= (see below).
在你想要显示它的每个模式下=fci-mode=(见下文)。

To configure auto line breaking when the line exceed 82 chars for text and
若要配置文本和的行超过82字符时的自动断行
markdown files, with fill indicator line:
标记文件，填充指示线:

#+BEGIN_EXAMPLE
(add-hook 'text-mode-hook (lambda ()
(turn-on-auto-fill)
(fci-mode)
(set-fill-column 82)))
(add-hook 'markdown-mode-hook (lambda ()
(turn-on-auto-fill)
(fci-mode)
(set-fill-column 82)))
#+END_EXAMPLE

To set the non-auto-line limit for Python a C-mode (and D) to 94:
将Python的非自动行限制设为c模式(和D)为94:

#+BEGIN_EXAMPLE
(add-hook 'python-mode-hook (lambda ()
(fci-mode)
(set-fill-column 94)))
(add-hook 'c-mode-hook (lambda ()
(fci-mode)
(set-fill-column 94)))

(add-hook 'd-mode-hook (lambda ()
(fci-mode)
(set-fill-column 94)))
#+END_EXAMPLE

* Silver Searcher (ag)
*银禧(署理)
:PROPERTIES:
属性:
:CUSTOM_ID: silver-searcher-ag
:CUSTOM_ID silver-searcher-ag
:END:
结束:

If you don't know it, the Silver Searcher is like Ack but a lot faster. The “ag”
如果你不知道的话，Silver Searcher有点像Ack，但是要快得多。“公司”
package will allow you to make searches with it without leaving Emacs and show
包将允许您进行搜索与它没有留下Emacs和显示
the results in a quickfix-style windows where you can select results and jump to
在quickfix样式的窗口中可以选择结果并跳转到其中
them: M-x ag RET [search] RET [directory] RET.
它们是:M-x ag RET[搜索]RET[目录]RET。

* Spanish keyboard remaps
西班牙语键盘重映射
:PROPERTIES:
属性:
:CUSTOM_ID: spanish-keyboard-remaps
:CUSTOM_ID spanish-keyboard-remaps
:END:
结束:

I use Spanish keyboards. Yes, I know, Vim is much better with an English keyboard,
我用西班牙键盘。是的，我知道，Vim的英文键盘要好得多，
but I'm 36 and have been using the Spanish layouts since I was 8, which means that
但我已经36岁了，从8岁起就开始使用西班牙式布局，这意味着
my brain is too hardwired to it. But with a few remaps I made my Vim experience
我的大脑太依赖它了。但通过几次重拍，我获得了Vim体验
much better. These were =-= (minus sign) in normal mode as =/= (to search), == as
好多了。这些是=-=(负号)在正常模式as =/=(搜索)，== as
=escape= in insert mode (I want to try the kj thing) and == as =:=. When you
=escape= in insert mode(我想尝试一下kj)， == as =:=。当你
remap keys in Emacs you have to know the name of the function that the shortcut
在Emacs中，你必须知道快捷键所在函数的名称
key will point to. Fortunately using =C-h k= (Control-h, release, k) will tell you
钥匙将指向。幸运的是使用=C-h k= (Control-h, release, k)会告诉你
the name of the function associated with the next key you press, so getting the
与您按下的下一个键相关联的函数的名称，因此获取
name of the functions for these remaps is easy. The =/= and =:= remaps were easy:
这些重新映射的函数的名称很简单。=/=和=:=映射很简单:

#+BEGIN_EXAMPLE
(define-key evil-normal-state-map "-" 'evil-search-forward)
(define-key evil-normal-state-map " " 'evil-ex)
(define-key evil-insert-state-map " " 'evil-normal-state)
#+END_EXAMPLE

* Don't create backup files
*不要创建备份文件
:PROPERTIES:
属性:
:CUSTOM_ID: dont-create-backup-files
:CUSTOM_ID dont-create-backup-files
:END:
结束:

I use version control and I'm a compulsive saver, so I don't need backup
我使用版本控制，我是一个强制的保护程序，所以我不需要备份
files. I've these disabled on Vim and I've also disabled them on Emacs:
文件。我在Vim上禁用了它们，在Emacs上也禁用了它们:

#+BEGIN_EXAMPLE
(setq make-backup-files nil)
#+END_EXAMPLE

* Don't move back the cursor one position when exiting insert mode
退出插入模式时，不要将光标向后移动一个位置
:PROPERTIES:
属性:
:CUSTOM_ID: dont-move-back-the-cursor-one-position-when-exiting-insert-mode
:CUSTOM_ID dont-move-back-the-cursor-one-position-when-exiting-insert-mode
:END:
结束:

This is something that I hated in Vim so I had it disabled with the following
这是我在Vim中讨厌的东西，所以我在下面禁用了它
lines on my .vimrc:
我的vimrc上的线:

#+BEGIN_EXAMPLE
autocmd InsertEnter * let CursorColumnI = col('.')
autocmd CursorMovedI * let CursorColumnI = col('.')
autocmd InsertLeave * if col('.') != CursorColumnI | call cursor(0, col('.')+1) | endif
#+END_EXAMPLE

To get the same behaviour in Evil you just have to set one option:
想要在《邪恶》中获得同样的效果，你只需要设置一个选项:

#+BEGIN_EXAMPLE
(setq evil-move-cursor-back nil)
#+END_EXAMPLE

* Remember the cursor position of files when reopening them
*请记住文件重新打开时的光标位置
:PROPERTIES:
属性:
:CUSTOM_ID: remember-the-cursor-position-of-files-when-reopening-them
:CUSTOM_ID remember-the-cursor-position-of-files-when-reopening-them
:END:
结束:

Pretty easy:
很简单:

#+BEGIN_EXAMPLE
(setq save-place-file "~/.emacs.d/saveplace")
(setq-default save-place t)
(require 'saveplace)
#+END_EXAMPLE

* Disable scroll bars
*禁用滚动条
:PROPERTIES:
属性:
:CUSTOM_ID: disable-scroll-bars
:CUSTOM_ID disable-scroll-bars
:END:
结束:

By default Emacs put a scroll bar on every window (split) which IMO is incredibly
默认情况下，Emacs会在每个窗口(分屏)上放置一个滚动条，这在IMO上是难以置信的
ugly. I already have the % of my position on the file in Powerline so I don't need
丑。我已经有我的位置的%在电力线的文件，所以我不需要
any scroll bars: =(scroll-bar-mode -1)=.
任何滚动条:=(滚动条-模式-1)=。

* “Graphical” GDB
*“图形”GDB
:PROPERTIES:
属性:
:CUSTOM_ID: graphical-gdb
:CUSTOM_ID graphical-gdb
:END:
结束:

Emacs GDB mode (enabled with M-x gdb RET binary_path) is pretty cool because it
Emacs GDB模式(使用M-x GDB RET binary_path启用)非常酷，因为它
create several windows in the style of typical IDE debuggers, but that's not
创建几个典型IDE调试器风格的窗口，但那不是
enabled by default, to enable it: =(setq gdb-many-windows t)=.
默认情况下启用，启用它:=(setq gdb-many-windows t)=。

Once you're in GDB mode with the binary loaded you can change to the source code
一旦进入GDB模式并加载了二进制文件，就可以切换到源代码
windows (use =C-x o= to switch between splits or just mouse clicks, Vim-style
windows(使用=C-x o=在分割和鼠标点击之间切换，vi风格
=C-w= key bindings doesn't work in gdb mode), load the source code file you want
=C-w=键绑定在gdb模式下不起作用)，加载你想要的源代码文件
to set breakpoints on and set a break point with M-x gud-break. Then you can run
设置断点并使用M-x古德-break设置断点。然后你就可以跑了
the program with “run” (r) on the gdb window and once in the break point advance with
该程序在gdb窗口上带有“run”(r)，并且一次在断点上前进带有
next (n) or step (s). Local vars and registers are show in one window, breakpoints
在一个窗口(断点)中显示本地变量和寄存器
and the stack frame in another one.
以及另一个中的堆栈帧。

* Color Identifiers Mode and Color Delimiters
*颜色标识符模式和颜色分隔符
:PROPERTIES:
属性:
:CUSTOM_ID: color-identifiers-mode-and-color-delimiters
:CUSTOM_ID color-identifiers-mode-and-color-delimiters
:END:
结束:

The plugin =colors-identifiers-mode= colorize every variable in a different color.
plugin =colors-identifiers-mode=为每个变量赋予不同的颜色。
I've mixed feelings about it because the code looks like a fruit salad, but it
我对它有复杂的感觉，因为代码看起来像水果沙拉，但它
makes really easy to visually identify where variables are used. I'm using it for
使得在视觉上识别变量的使用非常容易。我用它来
now. Setup is:
现在。设置:

#+BEGIN_EXAMPLE
(package 'color-identifiers-mode)
(global-color-identifiers-mode)
#+END_EXAMPLE

Another firm step into the total fruitsalarization of your Emacs is the Rainbow
另一个坚定的步骤，以全面水果化你的Emacs是彩虹
Delimiters package that will color nested delimiters on a different color so you
分隔符包，将嵌套的分隔符涂上不同的颜色
can check easily which of them are pairs without having to move the cursor over
可以很容易地检查其中哪些是对，而不需要移动光标
them. When you have lots of nested parenthesis this helps a lot to see the pairs
他们。当你有很多嵌套的括号时，这有助于看到很多对
without having to move the cursor over them.
不需要把光标移过去。

#+BEGIN_EXAMPLE
(package 'rainbow-delimiters)
(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
#+END_EXAMPLE

* Diminish to clean clutter from the modeline
*减少从modeline清理杂物
:PROPERTIES:
属性:
:CUSTOM_ID: diminish-to-clean-clutter-from-the-modeline
:CUSTOM_ID diminish-to-clean-clutter-from-the-modeline
:END:
结束:

Diminish will remove the minor mode indicators from the mode line (or powerline).
将从模式线(或电力线)中删除次要模式指示器。
Example config:
示例配置:

#+BEGIN_EXAMPLE
(require 'diminish)
(diminish 'visual-line-mode)
(after 'autopair (diminish 'autopair-mode))
(after 'undo-tree (diminish 'undo-tree-mode))
(after 'auto-complete (diminish 'auto-complete-mode))
(after 'projectile (diminish 'projectile-mode))
(after 'yasnippet (diminish 'yas-minor-mode))
(after 'guide-key (diminish 'guide-key-mode))
(after 'eldoc (diminish 'eldoc-mode))
(after 'smartparens (diminish 'smartparens-mode))
(after 'company (diminish 'company-mode))
(after 'elisp-slime-nav (diminish 'elisp-slime-nav-mode))
(after 'git-gutter+ (diminish 'git-gutter+-mode))
(after 'magit (diminish 'magit-auto-revert-mode))
(after 'hs-minor-mode (diminish 'hs-minor-mode))
(after 'color-identifiers-mode (diminish 'color-identifiers-mode))
#+END_EXAMPLE

* Select last yanked text
*选择最后拉拽的文本
:PROPERTIES:
属性:
:CUSTOM_ID: select-last-yanked-text
:CUSTOM_ID select-last-yanked-text
:END:
结束:

This is a pretty useful shotcut I've on my .vimrc that selects the last pasted (yanked) text:
这是一个非常有用的shotcut我在我的。vimrc选择最后粘贴(猛拉)文本:

#+BEGIN_EXAMPLE
nnoremap <leader>V `[v`]
#+END_EXAMPLE

Thanks to the comment by delexi I know that the function in Emacs is called
感谢delexi的评论，我知道Emacs中的函数被调用了
=exchange-point-and-mark=which defaults to =C-x C-x= but I've remapped to
=exchange-point-and-mark=它默认为=C-x C-x=但我已经重新映射了
leader-V with:
领袖vs:

#+BEGIN_EXAMPLE
(evil-leader/set-key "V" 'exchange-point-and-mark)
#+END_EXAMPLE

* Other Emacs alternatives for popular Vim plugins
*其他Emacs替代流行的Vim插件
:PROPERTIES:
属性:
:CUSTOM_ID: other-emacs-alternatives-for-popular-vim-plugins
:CUSTOM_ID other-emacs-alternatives-for-popular-vim-plugins
:END:
结束:

- Powerline => Powerline-Evil
-电力线=>电力线邪恶
- Emmet => emmet-mode. I mapped “m” to “emmet-expand-line” because the
- Emmet => Emmet模式。我将“m”映射到“emmet-expand-line”，因为
default C-j shortcut is already defined in Evil.
默认的C-j快捷方式已经在Evil中定义。
- Surround => evil-surround (same operators)
- Surround => evil-surround(相同的操作符)
- Tabular.vim => M-x align-regexp RET regexp RET (with a visual selection)
——表格。vim => M-x
- Rename => M-x dired-jump, R to rename the file, RET to reopen.
-重命名=> M-x dired-jump, R重命名文件，RET重新打开。
- jDaddy => I only really used it to prettify json objects, this can be done with
- jDaddy =>我只使用它美化json对象，这是可以做到的
the functions defined [[http://irreal.org/blog/?p=354#comment-79015][by James P.]].
定义的函数[[http://irreal.org/blog/?p = 354 #评论- 79015][由詹姆斯p]]。
- Autocomplete and company mode works much like YouCompleteMe on Vim: they give an
-自动完成和公司模式的工作很像你完成的Vim:他们给一个
improved completion when you're programming. I don't know the difference between
改进了编程时的完成性。我不知道两者的区别
both, Company is newer, I think, but the ac-dcd package for completing the D
两者都是，我想公司比较新，但ac-dcd包用于完成D
language is for Autocomplete so that's what I'm using.
语言是用于自动完成的，这就是我所使用的。
- Vimdiff => M-x ediff-files or ediff-buffers. Pretty similar. Press =?= for help.
- Vimdiff => M-x ediff_files或ediff_buffer。非常相似。新闻= ?=寻求帮助。
If you use Helm (just use it) when you're in a helm file list you can press TAB
如果你使用头盔(只是使用它)，当你在一个头盔文件列表，你可以按TAB键
and in the actions list you can select one to marking the file for ediff; much
在操作列表中，你可以选择一个来标记文件的ediff;多
quicker than browsing by hand to the files to compare.
比手动浏览文件要快得多。
- netrw/nerdtree => M-x dired (included) or M-x dired+ (installable).
- netrw/nerdtree => M-x dired(包含)或M-x dired+(可安装)。

* Other random thoughts about Emacs, Evil and Vim
其他关于Emacs、Evil和Vim的随机想法
:PROPERTIES:
属性:
:CUSTOM_ID: other-random-thoughts-about-emacs-evil-and-vim
:CUSTOM_ID other-random-thoughts-about-emacs-evil-and-vim
:END:
结束:

- Copy and paste with the system clipboard works without having to paste from the
-复制和粘贴与系统剪贴板的工作不需要从粘贴
="+= or ="*= register. It's still saved on those registers, but also in the
="+= or ="*=寄存器。它仍然保存在那些寄存器中，但也在
default register so if you paste after copying from any other desktop program
默认注册，所以如果你复制后粘贴从任何其他桌面程序
and then paste without specifying any register it will pull that register. Nice.
然后粘贴，不指定任何寄存器它会拉那个寄存器。好了。
- Evil doesn't have =:pu=/=:put= (paste below current line).
- Evil没有=:pu=/=:put=(粘贴到当前行下面)。
- Some windows with Evil (like =:registers=) use Emacs key binding of
-一些windows与邪恶(如=:寄存器=)使用Emacs键绑定的
=q= to exit instead of Vim =esc=.
=q=退出，而不是Vim =esc=。
- The toolbar is actually useful for a newbie like me. Check it. To use the
-工具栏实际上是有用的新手喜欢我。检查它。使用
toolbar without the mouse you've the =F10= key binding.
没有鼠标的工具栏=F10=键绑定。
- Paralellization is very nice to have. I love to have my syntax checked without
-有副肋很好。我喜欢检查我的语法
pauses, but...
停顿了一下,但是……
- Not everything is perfectly paralellized. For example, when the package
-不是每件事都是完美的。例如，当包
manager is loading the information from a package on a split (and sometimes it
经理正在加载信息从一个分裂的包(有时它
takes its time), all the interface hangs. One nice feature of Emacs is that you
所有的接口都挂起了。Emacs的一个很好的特性是您
can almost always cancel any long running process with Control-G.
几乎总是可以用Control-G取消任何长时间运行的进程。
