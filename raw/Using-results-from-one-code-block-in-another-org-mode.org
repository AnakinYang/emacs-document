#+TITLE: Using results from one code block in another org-mode
#+URL: http://kitchingroup.cheme.cmu.edu/org/2019/02/12/Using-results-from-one-code-block-in-another-org-mode.org
#+AUTHOR: lujun9972
#+TAGS: raw
#+DATE: [2019年 03月 05日 星期二 18:15:29 CST]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t n:nil ::t |:t ^:nil -:nil f:t *:t <:nil

* DONE Using results from one code block in another org-mode
*在另一个组织模式下使用一个代码块的结果
CLOSED: [2019-02-12 Tue 09:20]
[2019-02-12星期二09:20]
:PROPERTIES:
属性:
:categories: emacs,elisp,orgmode
类别:emacs、elisp orgmode
:date:     2019/02/12 09:20:58
日期:2019/02/12
:updated:  2019/02/25 14:17:16
更新:2019/02/25 14:17:16
:org-url:  http://kitchingroup.cheme.cmu.edu/org/2019/02/12/Using-results-from-one-code-block-in-another-org-mode.org
:org-url: http://kitchingroup.cheme.cmu.edu/org/2019/02/12/Using-results-from-one-code-block-in-another-org-mode.org
:permalink: http://kitchingroup.cheme.cmu.edu/blog/2019/02/12/Using-results-from-one-code-block-in-another-org-mode/index.html
永久链接:http://kitchingroup.cheme.cmu.edu/blog/2019/02/12/Using-results-from-one-code-block-in-another-org-mode/index.html
:END:
结束:

One really great feature in org-mode is you have many options to pass data between code-blocks. In this post we look at some of these options using emacs-lisp as the language. This runs in a /session/ where you can keep variables in memory between blocks, and use them in subsequent blocks.
org模式中一个非常棒的特性是，您可以使用许多选项在代码块之间传递数据。在这篇文章中，我们将介绍使用emacs-lisp作为语言的一些选项。这在/session/中运行，您可以将变量保存在块之间的内存中，并在后续块中使用它们。

Here we set a variable to a value.
这里我们将一个变量设置为一个值。

#+BEGIN_SRC emacs-lisp
# + BEGIN_SRC emacs lisp
(setq some-variable 42)
42 (setq一些变量)
#+END_SRC
# + END_SRC

#+RESULTS:
# +结果:
: 42

Then later in another block we can use that variable:
然后在另一个块中我们可以使用这个变量:

#+BEGIN_SRC emacs-lisp
# + BEGIN_SRC emacs lisp
(+ some-variable 1)
(+一些变量1)
#+END_SRC
# + END_SRC

#+RESULTS:
# +结果:
: 43

While you are in the session, =some-variable= can be used. If you want some mind-bending trouble, the emacs-lisp session is global, and you can access =some-variable= even in another buffer! Don't do that. When you close emacs this variable will disappear, and all that is left are the results from above.
在会话期间，可以使用=some-variable=。如果您想要一些令人费解的麻烦，emacs-lisp会话是全局的，您可以访问=some-variable=甚至在另一个缓冲区中!不要这样做。当您关闭emacs时，该变量将消失，只剩下上面的结果。

There is another way to pass information from one block to another using named src blocks and variables in the block header. This allows you to pass data between blocks by name, and you will see later you can even access the results by name from other files.
还有一种方法可以使用块标头中的命名src块和变量将信息从一个块传递到另一个块。这允许您按名称在块之间传递数据，稍后您将看到甚至可以按名称从其他文件访问结果。

** :var
* *:var

First, we give our src block a name like this:
首先，我们给我们的src块一个这样的名字:

#+BEGIN_EXAMPLE
#+name: block-1
#+BEGIN_SRC emacs-lisp
(current-time-string)
#+END_SRC
#+END_EXAMPLE

When we run this, the results will have a name too.
当我们运行它时，结果也会有一个名字。

#+name: block-1
# +名字:1
#+BEGIN_SRC emacs-lisp
# + BEGIN_SRC emacs lisp
(current-time-string)
(current-time-string)
#+END_SRC
# + END_SRC

#+RESULTS: block-1
# +结果:1
: Tue Feb 12 08:19:23 2019
: 2019年2月12日星期二08:19:23

Now, we can use the named result as /input/ to a new block using the :var header.
现在，我们可以使用:var标头将命名结果作为/input/用于一个新块。

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp :var input=block-1
(format "We got %S in block-1" input)
#+END_SRC
#+END_EXAMPLE

When we run this block, emacs will run block-1 and put the output in to the variable =input= which we use inside the code block.
当我们运行这个块时，emacs将运行block-1并将输出放入变量=input=中，该变量是我们在代码块中使用的。

#+BEGIN_SRC emacs-lisp :var input=block-1
@ #+BEGIN_SRC emacs-lisp:var输入=block-1
(format "We got %S in block-1" input)
(格式“我们在block-1中得到了%S”输入)
#+END_SRC
# + END_SRC

#+RESULTS:
# +结果:
: We got "Tue Feb 12 08:20:44 2019" in block-1
字体我们在block-1中看到了“2019年2月12日星期二8:20:44”

Some things to note:
注意以下几点:
1. Every time you run this, block-1 gets rerun.
1. 每次运行它，block-1都会重新运行。
2. The results in this block are not the same as in block-1
2. 此块中的结果与块-1中的结果不同
3. The results in block-1 are not changed when you run the second block.
3.当您运行第二个块时，block-1中的结果不会改变。

You may not want to rerun block-1 each time; maybe it is an expensive calculation, or maybe it should not be changed. You can prevent this behavior by using the :cache header.
您可能不想每次都重新运行block-1;也许这是一个昂贵的计算，也许它不应该被改变。您可以使用:cache标头来防止这种行为。

** :cache
* *:缓存

If you specify =:cache yes= then org-mode /should/ store a hash of the code block with the results, and if the code block hasn't changed then it should not run again.
如果您指定=:cache yes=，那么org-mode /应该/存储一个带有结果的代码块散列，如果代码块没有改变，那么它就不应该再次运行。

#+BEGIN_EXAMPLE
#+name: block-2
#+BEGIN_SRC emacs-lisp :cache yes
(current-time-string)
#+END_SRC
#+END_EXAMPLE

#+name: block-2
# +名字:区块2
#+BEGIN_SRC emacs-lisp :cache yes
#+BEGIN_SRC emacs-lisp:缓存是
(current-time-string)
(current-time-string)
#+END_SRC
# + END_SRC

#+RESULTS[16a95c8b6a2ad5f5f5ed18b60f13c5b8904ba8d6]: block-2
# +结果[16 a95c8b6a2ad5f5f5ed18b60f13c5b8904ba8d6]:区块2
: Tue Feb 12 08:06:22 2019
: 2019年2月12日星期二08:06:22

Now, we use block-2 as input to a block, we see the output is the same as the output from block-2.
现在，我们使用block-2作为block的输入，我们可以看到block-2的输出和block-2的输出是一样的。

#+BEGIN_SRC emacs-lisp :var input=block-2
@ #+BEGIN_SRC emacs-lisp:var输入=block-2
(format "We got %S in block-2" input)
(格式“我们在block-2中得到了%S”输入)
#+END_SRC
# + END_SRC

#+RESULTS:
# +结果:
: We got "Tue Feb 12 08:06:22 2019" in block-2
字体我们在block-2中看到了“2019年2月12日星期二08:06:22”

Ok, but what if my results are too large to put in the buffer, or too complex for text? You still have some options.
好吧，但是如果我的结果太大而不能放入缓冲区，或者太复杂而不能写入文本怎么办?你还有一些选择。

** :wrap
* *:包装

Suppose we generate some json in one block, and we want to use it in another block. We still want to see the json in the buffer as an intermediate result. We can wrap the output in a json block like this.
假设我们在一个块中生成一些json，并希望在另一个块中使用它。我们仍然希望看到缓冲区中的json作为中间结果。我们可以像这样将输出包装在json块中。

#+name: json
# +名称:json
#+BEGIN_SRC emacs-lisp :wrap json :cache yes
#+BEGIN_SRC emacs-lisp:包装json:缓存是
(require 'json)
(需要的json)
(json-encode `(("date" . ,(current-time-string))))
(json-encode”(“日期”。,(current-time-string))))
#+END_SRC
# + END_SRC

#+RESULTS[2daea688af88cfac7bd5862c0b42c69351d516dd]: json
# +结果[2 daea688af88cfac7bd5862c0b42c69351d516dd]: json
#+begin_json
# + begin_json
{"date":"Tue Feb 12 08:30:20 2019"}
{“日期”:“2019年2月12日星期二08:30:20”}
#+end_json
# + end_json

Then, we can simply input that output into a new block.
然后，我们可以简单地将输出输入到一个新块中。

#+BEGIN_SRC emacs-lisp :var input=json
@ #+BEGIN_SRC emacs-lisp:var输入=json
(format "We got %S in json" input)
(格式“We got %S in json”输入)
#+END_SRC
# + END_SRC

#+RESULTS:
# +结果:
: We got "{"date":"Tue Feb 12 08:30:20 2019"}
:我们得到“{”日期:“2019年2月12日星期二8:30:20”}
: " in json
:“json格式

This admittedly still pretty simple, text-based data. It is probably not a good idea to do this with binary data.
诚然，这仍然是非常简单的、基于文本的数据。对二进制数据这样做可能不是一个好主意。

Note you can refer to this result even in another org-file:
注意，你可以参考这个结果，甚至在另一个组织文件:

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp :var input=./2019-02-12.org:json
input
#+END_SRC

#+RESULTS:
: {"date":"Tue Feb 12 08:30:20 2019"}
#+END_EXAMPLE


** :file
* *:排队

It may be that your data is too large to conveniently put into your org-file, or maybe it is binary data. No problem, just put it into an external file using the :file header. It looks like this:
可能是您的数据太大，无法方便地放入您的组织文件，也可能是二进制数据。没问题，只需使用:file头将其放入外部文件即可。它是这样的:

#+BEGIN_EXAMPLE
#+name: block-3
#+BEGIN_SRC emacs-lisp :cache yes :file block-3
(require 'json)
(json-encode `(("date" . ,(current-time-string))))
#+END_SRC

#+RESULTS[a14d376653bd8c40a0961ca95f21d8837dddec66]: block-3
[[file:block-3]]
#+END_EXAMPLE


Note that you have to provide a file name for this. Sometimes that is nice if you want a human recognizable file to send to someone, but it would also be nice if there was an automatic naming scheme, e.g. based on an sha-1 hash of the src block.
注意，您必须为此提供一个文件名。有时，如果您希望将一个人类可识别的文件发送给某人，这是很好的，但如果有一个自动命名方案也会很好，例如基于src块的sha-1散列。

#+name: block-3
# +名字:第3部分
#+BEGIN_SRC emacs-lisp :cache yes :file block-3
#+BEGIN_SRC emacs-lisp:cache yes:file block-3
(require 'json)
(需要的json)
(json-encode `(("date" . ,(current-time-string))))
(json-encode”(“日期”。,(current-time-string))))
#+END_SRC
# + END_SRC

#+RESULTS[a14d376653bd8c40a0961ca95f21d8837dddec66]: block-3
# +结果[a14d376653bd8c40a0961ca95f21d8837dddec66]:第3部分
[[file:block-3]]
[[文件:第3部分]]

Now you can use other tools to check out the file. Here we can still use simple shell tools.
现在您可以使用其他工具来检出文件。在这里，我们仍然可以使用简单的shell工具。

#+BEGIN_SRC sh :results code
#+BEGIN_SRC sh:结果代码
cat block-3
猫第3部分
#+END_SRC
# + END_SRC

#+RESULTS:
# +结果:
#+begin_src sh
# + begin_src sh
{"date":"Tue Feb 12 08:46:55 2019"}
{“日期”:“2019年2月12日星期二08:46:55”}
#+end_src
# + end_src


The output of block-3 is a file name:
block-3的输出是一个文件名:

#+BEGIN_SRC emacs-lisp :var input=block-3
@ #+BEGIN_SRC emacs-lisp:var input=block-3
input
输入
#+END_SRC
# + END_SRC

#+RESULTS:
# +结果:
: /Users/jkitchin/Box Sync/kitchingroup/jkitchin/journal/2019/02/12/block-3
同步:/用户/ jkitchin /盒/ kitchingroup / jkitchin /杂志/ 2019/02/12 /第3部分

So you can use it in a new block to read the data in, and then do something new with it.
因此，您可以在一个新的块中使用它来读取数据，然后对其进行一些新的操作。

#+BEGIN_SRC emacs-lisp :var input=block-3
@ #+BEGIN_SRC emacs-lisp:var input=block-3
(with-temp-buffer
(with-temp-buffer
(insert-file-contents input)
(insert-file-contents输入)
(format "We got %S in block-3" (json-read-from-string (buffer-string))))
(format "We got %S in block-3" (json-read-from-string (buffer-string))
#+END_SRC
# + END_SRC

#+RESULTS:
# +结果:
: We got ((date . "Tue Feb 12 08:46:55 2019")) in block-3
例如我们有约会。“2019年2月12日星期二08:46:55”))在block-3中

** "remote" data
* *“远程”数据

The blocks do not have to be in order. If you want, you can put your blocks in an appendix, and then just have analysis blocks here that use them. That way, you can have short blocks here that are more readable, but longer, more complex blocks elsewhere that do not clutter your document.
积木不一定要按顺序排列。如果你愿意，你可以把你的模块放在附录里，然后在这里有使用它们的分析模块。这样，您可以在这里使用短块，这样可读性更好，但是在其他地方使用更长、更复杂的块，这样就不会使文档混乱。

#+BEGIN_SRC emacs-lisp :var input=appendix-data
(with-temp-buffer
(insert-file-contents input)
(format "We got %S in the appendix data" (json-read-from-string (buffer-string))))
#+END_SRC

#+RESULTS:
: We got "{"date":"Tue Feb 12 09:11:12 2019"}" in the appendix data
:我们在附录数据中得到了“{”date:“Tue Feb 12 09:11:12 2019”}


** Manually saving data in files
**手动保存文件中的数据

Note you can also manually save data in a file, for example:
注意你也可以手动保存数据在一个文件中，例如:

#+name: block-4
# +名字:第4部分
#+BEGIN_SRC emacs-lisp
# + BEGIN_SRC emacs lisp
(require 'json)
(需要的json)
(let ((f "block-4.json"))
(让((f块- 4. - json))
(with-temp-file f
(with-temp-file f
(prin1
(prin1
(json-encode `(("date" . ,(current-time-string))))
(json-encode”(“日期”。,(current-time-string))))
(current-buffer)))
(当前缓冲区)))
f)
f)
#+END_SRC
# + END_SRC

#+RESULTS: block-4
# +结果:第4部分
: block-4.json
:块- 4. - json

We put the filename as the last variable which is returned by the block, so that we don't have to manually type it later in the next block. You know, try not to repeat yourself...
我们将文件名作为块返回的最后一个变量，这样我们就不必在下一个块中手动输入它。你知道，尽量不要重复你自己…

This just shows we did write out to our file:
这只是表明我们写了我们的文件:

#+BEGIN_SRC sh
# + BEGIN_SRC sh
cat block-4.json
猫块- 4. - json
#+END_SRC
# + END_SRC

#+RESULTS:
# +结果:
: :"Tue Feb 12 08:50:00 2019"}
::“2019年2月12日星期二08:50:00”}

And we read the file in here, using the filename from block-4 as an input variable.
我们在这里读取文件，使用block-4中的文件名作为输入变量。

#+BEGIN_SRC emacs-lisp :var input=block-4
@ #+BEGIN_SRC emacs-lisp:var输入=block-4
(with-temp-buffer
(with-temp-buffer
(insert-file-contents input)
(insert-file-contents输入)
(format "We got %S in block-4" (json-read-from-string (buffer-string))))
(format "We got %S in block-4" (json-read-from-string (buffer-string))
#+END_SRC
# + END_SRC

#+RESULTS:
# +结果:
: We got "{"date":"Tue Feb 12 08:51:25 2019"}" in block-4
:我们得到“{”日期:“2月12日星期二08:51:25 2019”}在block-4

** An appendix for data
**资料的附录
:PROPERTIES:
属性:
:ID:       0452775B-D200-4B9B-BC09-C6935D9183A4
:身份证:0452775 b-d200-4b9b-bc09-c6935d9183a4
:END:
结束:

#+name: appendix-data
# +名字:appendix-data
#+BEGIN_SRC emacs-lisp
# + BEGIN_SRC emacs lisp
(require 'json)
(需要的json)
(let ((f "appendix.json"))
(让((f“appendix.json”))
(with-temp-file f
(with-temp-file f
(prin1
(prin1
(json-encode `(("date" . ,(current-time-string))))
(json-encode”(“日期”。,(current-time-string))))
(current-buffer)))
(当前缓冲区)))
f)
f)
#+END_SRC
# + END_SRC

#+RESULTS: appendix-data
# +结果:appendix-data
: appendix.json
:appendix.json


** Caveats
* *注意事项

Using org-mode like this is almost always finding the right tradeoffs in what is persistent, and where is it stored. Not all of the intermediate data/calculations are stored; if they are really cheap you can just run the code blocks again. If they are really small, i.e. easy for your to read in a few lines, you can store them in the document. If they are really large, you can store them in a file.
使用这样的组织模式几乎总是在持久性和存储位置方面找到正确的权衡。并非所有中间数据/计算都已储存;如果它们真的很便宜，你可以再次运行代码块。如果它们非常小，也就是说，很容易在几行代码中读取，那么可以将它们存储在文档中。如果它们非常大，可以将它们存储在文件中。

The beauty of having everything in an org-file is you have a single file that is easy to transport. When the files get too large though, it can become impractical, e.g. emacs may slow down if you try to put thousands of lines of xml data into the buffer. Then, you have to make some decisions about what to keep, where to keep it, and in what form to keep it.
在一个组织文件中包含所有内容的美妙之处在于您只有一个易于传输的文件。但是，当文件变得太大时，它可能变得不切实际，例如，如果试图将数千行xml数据放入缓冲区，emacs可能会变慢。然后，你必须做出一些决定，关于保存什么，保存在哪里，以什么形式保存。

For short projects where you only need a single compute session, having everything in memory may be fine. For longer projects, say one that is long enough you will close all the buffers, and possibly restart emacs in between working on it, then you have to make some decisions about what to save from each block so you can continue the work in the next session. Again, you have to decide what to save, where to save, and in what form.
对于只需要单个计算会话的短期项目，将所有内容都放在内存中可能没有问题。对于较长的项目，比如一个足够长的项目，您将关闭所有缓冲区，并可能在处理它的间隙重新启动emacs，然后您必须做出一些关于从每个块中保存什么内容的决定，以便在下一个会话中继续工作。同样，您必须决定保存什么、在何处保存以及以什么形式保存。

Once you start saving data outside the org-file, it becomes less portable, or more tricky to move the file because you need to also move all the data files to keep it intact. I have explored a concept of making an org-archive in the past, where you get a list of all files linked in the org-file, but this so far has just been worked out for some small proof of concept ideas.
一旦您开始在组织文件之外保存数据，它的可移植性就会降低，或者移动文件会变得更加棘手，因为您还需要移动所有的数据文件来保持它的完整性。在过去，我曾探讨过创建一个组织归档的概念，在这个概念中，您可以获得组织文件中链接的所有文件的列表，但到目前为止，这只是一些概念概念的小证明。

Not all languages are the same in org-mode. They do not all support sessions for example, and they may not all work like the examples here. The scimax iPython modifications do not behave like the examples above. That is probably due to bugs I have inadvertently introduced, and in the future I will try to make it work like emacs-lisp does above.
并不是所有的语言在组织模式下都是相同的。例如，它们并不都支持会话，而且它们可能不都像这里的示例一样工作。修改scimax iPython的行为与上面的示例不同。这可能是由于我无意中引入的bug造成的，以后我将尝试使它像上面emacs-lisp那样工作。

Overall, org-mode has one of the most flexible and powerful systems for passing and reusing data in documents I have ever seen. It is not perfect, and in such a powerful system there are many unexplored or lightly traveled corners that may have hazards in them. It still seems pretty promising though.
总的来说，org-mode是我见过的在文档中传递和重用数据的最灵活、最强大的系统之一。它不是完美的，在这样一个强大的系统中，有许多未经探索或很少旅行的角落可能存在危险。不过看起来还是很有希望的。
