#+TITLE: Use org-radiobutton to select an option from a list
#+URL:
#+AUTHOR: lujun9972
#+TAGS: raw
#+DATE: [2018-03-11 Sun 15:50]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t n:nil ::t |:t ^:nil -:nil f:t *:t <:nil

* DONE Use org-radiobutton to select an option from a list :ignore:
*使用org-radiobutton从列表中选择一个选项:忽略:
CLOSED: [2018-03-11 Sun 15:50]
关馆时间:[2018-03-11 Sun 15:50]
:PROPERTIES:
属性:
:BLOG_FILENAME: 2018-03-11-Use-org-radiobutton-to-select-an-option-from-a-list
:BLOG_FILENAME: 2018 - 03 - 11 -使用-组织- radiobutton -选择- -选项- - -从一个列表中
:PUBDATE:  [2018-03-11 Sun 15:50]
:发布日期:[2018-03-11 Sun 15:50]
:END:
结束:
:LOGBOOK:
LOGBOOK:
- State "DONE"       from              [2018-03-11 Sun 15:50]
-状态“完成”[2018-03-11 Sun 15:50]
:END:
结束:
:CLOCK:
时钟:
CLOCK: [2018-03-11 Sun 15:20]--[2018-03-11 Sun 15:50] =>  0:30
时钟:[2018-03-11 Sun 15:20]—[2018-03-11 Sun 15:50] => 0:30
:END:
结束:

#+BEGIN_SRC elisp :exports none
@ #+BEGIN_SRC elisp:不导出
(use-package org-radiobutton)
(use-package org-radiobutton)
#+END_SRC
# + END_SRC

Ever since I've come across the [[http://howardism.org/Technical/Emacs/literate-devops.html][Literate DevOps]] article I was hooked
自从我读到这篇文章，我就被吸引住了
and immediately started writing down "org notebooks" every time an
并立即开始写“组织记事本”每次一个
incident occured along with all the code and steps on how to fix it in
事件与所有的代码以及如何修复它的步骤一起发生
case it might happen in the future (protip: it /will/ happen again).
如果它在未来可能发生(提示:它/将/再次发生)。

Recently we had some problems with webhook requests behaving weird and
最近我们遇到了一些webhook请求行为怪异的问题
so I created a little notebook to query the mongo database where we
所以我创建了一个小笔记本来查询我们所在的mongo数据库
store all the requests and some more functions (ranging from elisp to
存储所有请求和更多的功能(从elisp到
jq to ruby) to process the results.  As you sure know, threading data
来处理结果。你肯定知道，线程数据
between code blocks in different languages is painless with =org-mode=
在不同语言的代码块之间使用=org-mode=是无痛的
and babel.
和巴别塔。

So imagine a block like this (using [[https://github.com/krisajenkins/ob-mongo][ob-mongo]]):
因此，想象这样一个块(使用[[https://github.com/krisajenkins/ob-mongo][ob-mongo]]):

#+BEGIN_SRC org
# + BEGIN_SRC组织
,#+NAME: query
# +名称:查询
,#+BEGIN_SRC mongo :db logs :host localhost :port 27017
db日志:host localhost:port 27017
db.webhookLogs.find({endpoint: "AddCustomer"}).sort({_id: -1}).limit(1)
db.webhookLogs。找到({端点:“AddCustomer”})。排序({_id: 1}) .limit (1)
,#+END_SRC
# END_SRC +,
#+END_SRC
# + END_SRC

This gives me the most recent request to the =AddCustomer= endpoint.
这给出了对=AddCustomer= endpoint的最新请求。
The results of this block are then piped into other code blocks to
然后将此块的结果通过管道输送到其他代码块
process the request, you can imagine how that looks.
处理请求，您可以想象它是什么样子。

Usually I run the entire app stack locally but we also have separate
通常我在本地运行整个应用程序堆栈，但我们也有单独的
staging and production environments.  So after I run the notebook on
准备和生产环境。所以在我运行笔记本之后
my own local stack I want to try it out in staging.
我自己的本地堆栈，我想尝试它在分期。

I use [[https://github.com/rejeep/prodigy.el][prodigy]] to manage my ssh tunnels and so all I need to do is
我使用[[https://github.com/rejeep/prodigy.el][prodigy]]来管理我的ssh通道，所以我需要做的就是
change the port to one pointing to staging and re-run the notebook.
将端口更改为指向staging并重新运行笔记本。
The problem is that I have multiple query blocks and so I have to go
问题是我有多个查询块，所以我必须离开
and change all of the =:port= arguments.
并更改所有的=:port=参数。

I have solved this by creating a block that would work as a source for
我通过创建一个可以作为源的块来解决这个问题
the port and then reference it dynamically in the header line:
然后在标题行动态引用它:

#+BEGIN_SRC org
# + BEGIN_SRC组织
,#+NAME: port
# +姓名:港
,#+BEGIN_SRC elisp
,# + BEGIN_SRC elisp
27017
,#+END_SRC
# END_SRC +,

,#+NAME: query
# +名称:查询
,#+BEGIN_SRC mongo :db logs :host localhost :port (org-babel-ref-resolve "port")
db日志:host localhost:port (org-babel-ref-resolve "port")
db.webhookLogs.find({endpoint: "AddCustomer"}).sort({_id: -1}).limit(1)
db.webhookLogs。找到({端点:“AddCustomer”})。排序({_id: 1}) .limit (1)
,#+END_SRC
# END_SRC +,
#+END_SRC
# + END_SRC

Since we can call elisp in the header I use =org-babel-ref-resolve= and
因为我们可以在页眉中调用elisp，所以我使用=org-babel-ref-resolve= and
give it the name of the source block and babel will automatically
给它源块的名字，babel就会自动执行
replace it with the value of the block.
用块的值替换它。

This solves the problem of changing the constant at one place but as I
这解决了在一个地方改变常数的问题
got to work with more environments I tended to forget what port was
要在更多的环境中工作，我往往会忘记端口是什么
what.  So I created a list above the block to remind me of the
什么。所以我在block上面创建了一个列表来提醒我
available values:
可用值:

#+BEGIN_SRC org
# + BEGIN_SRC组织
Use one of the following ports to operate on the given environment:
使用下列其中一个端口来操作给定的环境:

- localhost :: 27017
- localhost:: 27017
- staging :: 27004
-分期:27004
- production :: 27005
-制作:27005

,#+NAME: port
# +姓名:港
,#+BEGIN_SRC elisp
,# + BEGIN_SRC elisp
27017
,#+END_SRC
# END_SRC +,

,#+NAME: query
# +名称:查询
,#+BEGIN_SRC mongo :db logs :host localhost :port (org-babel-ref-resolve "port")
db日志:host localhost:port (org-babel-ref-resolve "port")
db.webhookLogs.find({endpoint: "AddCustomer"}).sort({_id: -1}).limit(1)
db.webhookLogs。找到({端点:“AddCustomer”})。排序({_id: 1}) .limit (1)
,#+END_SRC
# END_SRC +,
#+END_SRC
# + END_SRC

We can use the org mode list description syntax =foo ::= to attach a
我们可以使用org模式列表描述语法=foo::=来附加a
label to each item and leave the number as the "value".
标签上的每一项，并留下数字作为“值”。

This is starting to look an awful lot like a list of choices I could
这看起来很像我的选择列表
pick from.  So my thinking goes like this: let's make it a checkbox
选择从。所以我的想法是这样的:让我们把它变成一个复选框
list and then select the option by checking the option.  The trouble
列表，然后通过检查该选项来选择该选项。麻烦的
there is that toggling the input would require me to un-toggle the
要切换输入，需要取消切换
current one and then toggle the desired option.  Ideally, toggling one
当前一个，然后切换所需的选项。理想情况下,切换一个
checkbox would uncheck the other so that there is always exactly one
复选框将取消另一个复选框，以便始终只有一个
option selected: in other words, I wanted a radiobutton list.
选项选择:换句话说，我想要一个radiobutton列表。

After a quick google session I've found (via [[http://irreal.org/blog/?p=4644][Irreal]]) that [[http://kitchingroup.cheme.cmu.edu/blog/2015/10/05/A-checkbox-list-in-org-mode-with-one-value/][John Kitchin]]
通过快速的谷歌会话，我发现(通过[[http://irreal.org/blog/?p=4644][Irreal]])， [[http://kitchingroup.cheme.cmu.edu/blog/2015/10/05/A-checkbox-list-in-org-mode-with-one-value/][John Kitchin]]
already figured this out.  I took his code and cleaned it up a bit to
已经算出来了。我把他的代码整理了一下
work with "modern" org mode (the post is three years old) and packaged
使用“现代”组织模式(post已经有三年历史)和打包
it as [[https://github.com/Fuco1/org-radiobutton][org-radiobutton]].
这是[[https://github.com/Fuco1/org-radiobutton] [org-radiobutton]]。

Now I have a nice menu I can go to and with a single =C-c C-c= on the
现在我有一个漂亮的菜单，我可以去和一个单一的=C-c -c=上
option I want I can select the environment where to run the notebook.
选项我想我可以选择运行笔记本的环境。
Org mode is so cool!
组织模式太酷了!

#+BEGIN_SRC org
# + BEGIN_SRC组织
Check one of the following ports to operate on the given environment:
检查下列端口之一，以操作给定的环境:

,#+attr_org: :radio
# + attr_org::收音机
,#+NAME: port
# +姓名:港
- [ ] localhost :: 27017
-[]本地主机::27017
- [X] staging :: 27004
- [X]分期:27004
- [ ] production :: 27005
-[]产量:27005

,#+NAME: query
# +名称:查询
,#+BEGIN_SRC mongo :db logs :host localhost :port (org-radiobutton-value "port")
db日志:host localhost:port (org-radiobutton-value "port")
db.webhookLogs.find({endpoint: "AddCustomer"}).sort({_id: -1}).limit(1)
db.webhookLogs。找到({端点:“AddCustomer”})。排序({_id: 1}) .limit (1)
,#+END_SRC
# END_SRC +,
#+END_SRC
# + END_SRC

I'm going over all of my notebooks converting all the ugly option
我正在检查我所有的笔记本，转换所有的丑陋选项
hacks to this setup and it is so damn pleasing! :D
黑客到这个设置，它是如此该死的高兴!:D
