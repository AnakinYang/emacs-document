#+TITLE: Advanced Usage of Dependencies Between Tasks Using Org-mode
#+URL: http://karl-voit.at/2016/12/18/org-depend/
#+AUTHOR: lujun9972
#+TAGS: raw
#+DATE: [2018年 03月 02日 星期五 14:19:05 CST]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:nil
Update 2018-02-02: Link to [[https://elpa.gnu.org/packages/org-edna.html][org-edna]]
更新2018-02-02:链接到[[https://elpa.gnu.org/packages/org-edna.html][org-edna]]

This blog article is for advanced users of [[../../../../tags/emacs][Emacs]] [[http://orgmode.org][org-mode]] and people who are curious how non-trivial todo management can be accomplished using those tools.
这篇博客文章是为[[.. .. .. .. .. ..]的高级用户而写的。/tags/emacs][emacs]][[http://orgmode.org][org-mode]]以及那些对如何使用这些工具完成非琐碎的todo管理感到好奇的人。

Defining dependencies between todo tasks is done via the contribution package =org-depend.el=. It offers a nice set of features. However, I do only use a sub-set for my workflows. Therefore, this article is not an exhaustive description of =org-depend.el= but it gives ideas on how to use and improve it.
定义todo任务之间的依赖关系通过贡献包=org- dependent .el=完成。它提供了一组很好的特性。但是，我只对我的工作流使用一个子集合。因此，本文并不是对=org-depend的详尽描述。但是它给出了如何使用和改进它的想法。

** Advanced Snippets With yasnippet and yankpad
**高级片段，带有雅思佩特和扬克佩特
:PROPERTIES:
属性:
:CUSTOM_ID: advanced-snippets-with-yasnippet-and-yankpad
:CUSTOM_ID advanced-snippets-with-yasnippet-and-yankpad
:CLASS: section-title
类:节标题
:END:
结束:

For a one-time workflow, I create the tasks and define dependencies manually. However, when I have to do things multiple times, I tend to use a [[../../../../apps-I-am-using][snippet software]] which inserts the headings and tasks on a keyboard shortcut. I wrote a [[../../../../Textbausteine][German blog article on text snippet tools]].
对于一次性工作流，我手动创建任务并定义依赖项。然而，当我不得不多次做某事时，我倾向于使用[[.. .. .. .. .. ..][snippet software]]将标题和任务插入键盘快捷方式。我写了一个[[.. .. .. .. ..][关于文本片段工具的德语博客文章]]。

A simple static snippet is for example =ccn= =TAB= which inserts my credit card number. A simple dynamic snippet is =dd= =TAB= which inserts the current day in ISO format such as =2016-12-17=. For a complex workflow as described further down, you'll need a snippet tool which delivers also complex, interactive snippets.
一个简单的静态代码片段是=ccn= =TAB=，它插入了我的信用卡号。一个简单的动态代码片段是=dd= =TAB=，它以ISO格式插入当前日期，如=2016-12-17=。对于下面描述的复杂工作流，您将需要一个代码片段工具，它还提供复杂的、交互式的代码片段。

For using simple to very advanced Emacs snippets there is [[https://github.com/joaotavora/yasnippet][yasnippet]]. With yasnippet, you are managing your snippets in separate files in directories according to your major modes such as org-mode. Invoking a snippet is done by typing the defined short abbreviation of the snippet (such as =dd=) followed by typically the =TAB= key.
对于使用简单到非常高级的Emacs片段，有[[https://github.com/joaotavora/yasni佩特][yasni佩特]]。有了yasnippet，您可以根据您的主要模式(如org模式)在目录中分别管理文件片段。调用代码片段是通过键入代码片段定义的简短缩写(例如=dd=)，然后通常是=TAB=键来完成的。

I was using yasnippet for many years when I found [[https://github.com/Kungsgeten/yankpad][yankpad]] which is a wrapper for yasnippet. In contrast to yasnippet, yankpad manages snippets in an Org-mode file as separate headings (in contrast to files in directories). Since most of my snippets are for Org-mode, I happily embraced yankpad and switched all of my Org-mode snippets to it. This makes the maintenance more easy because I have the full feature set of org-mode while writing snippets.
我使用雅思劈劈很多年，才发现[[https://github.com/Kungsgeten/yankpad][yankpad]]，这是一个披肩的雅思劈劈。与yasnippet相比，yankpad将org模式文件中的代码片段作为单独的标题进行管理(与目录中的文件相反)。由于我的大多数代码片段都是面向组织模式的，所以我很高兴地接受了yankpad，并将所有的组织模式代码片段都切换到了它。这使得维护更加容易，因为我在编写代码片段时拥有完整的org模式特性集。

With such a capable snippet system, I define complex workflows only once without having to cope with dependence definitions when I create an instance of this workflow. Therefore, for workflows I am using regularly, complexity is put into the snippet template which I am able to benefit instantly.
使用这样一个有能力的snippet系统，我只定义了一次复杂的工作流，而不必在创建该工作流的实例时处理依赖定义。因此，对于我经常使用的工作流，复杂性被放到代码片段模板中，我能够立即从中受益。

** Example Use-Case: Organizing an Cabaret Evening With Friends
**示例用例:与朋友组织一个歌舞晚会
:PROPERTIES:
属性:
:CUSTOM_ID: example-use-case-organizing-an-cabaret-evening-with-friends
:CUSTOM_ID example-use-case-organizing-an-cabaret-evening-with-friends
:CLASS: section-title
类:节标题
:END:
结束:

I love going to cabaret events with my friends. To minimize the organization effort without forgetting something important, I maintain a simple workflow:
我喜欢和朋友一起去看歌舞表演。为了尽量减少组织工作而不忘记一些重要的东西，我保持一个简单的工作流程:

1. Basic information on the event: artist, date, short description, ...
1. 活动基本信息:艺术家，日期，简短描述，…
2. Make reservations for the tickets
2. 预定机票
3. Send out an email to my friends asking who is joining
3.给我的朋友发封邮件，问问谁会加入
4. Write down everyone who is joining us
4. 记下每一个加入我们的人
5. Send out a reminder email shortly before the event so no one forgets
5. 在活动开始前不久发一封提醒邮件，这样没人会忘记
6. Create an org-mode event for the event evening itself
6. 为活动之夜本身创建一个组织模式事件

** Using an Advanced, Interactive Snippet
**使用高级的交互式代码片段
:PROPERTIES:
:CUSTOM_ID: using-an-advanced-interactive-snippet
:CLASS: section-title
:END:

Let's assume, I stumbled over an news paper article of one of my favorite artists coming to town.
假设，我在报纸上无意中看到了我最喜欢的一位艺术家的文章。

I switch to my org-mode file which contains such events. I invoke the keyboard sequence to insert a yankpad snippet and then choose the snippet for cabaret. Emacs asks me the day of the event (using a date picker), the name of the artist, the name of the cabaret program, the location (choosing from a pre-defined list of venues), how many seats I am going to reserve, the date of the first and second email.
我切换到包含这些事件的组织模式文件。我调用键盘序列来插入一个yankpad代码片段，然后选择cabaret的代码片段。Emacs会询问我活动的日期(使用日期选择器)、艺术家的名字、歌舞表演项目的名称、地点(从预先定义的场地列表中选择)、我将预订多少座位、第一封和第二封电子邮件的日期。

My yankpad snippet looks like below. You also need my simple wrapper functions for asking and inserting stuff: =my-capture-prompt=, =my-capture-selection=, and =my-capture-insert= which can be found in [[https://github.com/novoid/dot-emacs/blob/master/main.el][my Emacs setup]].
我的yankpad代码片段如下所示。您还需要我的简单包装器函数来询问和插入内容:=my- cap- prompt=， =my- cap- selection=， =my- cap- insert=，这些内容可以在[[https://github.com/novoid/dot-emacs/blob/master/main.el][my Emacs setup]]中找到。

#+begin_src org
  ,** Cabaret `(my-capture-prompt "date of event" 'my-event-date)`: `(my-capture-prompt "artist" 'my-artist)`
  :PROPERTIES:
  :ID: `(my-capture-insert 'my-event-date)`-cabaret
  :END:

  - Title: `(my-capture-prompt "title" 'my-title)`
  - `(my-capture-prompt "Num of seats" 'my-num-seats)` seats reserved:
  - 2: My girlfriend and I
  - 2:
  - 2:
  - 2:

  ,*** WAITING Make reservation for `(my-capture-insert 'my-num-seats)` seats
  :PROPERTIES:
  :ID: `(my-capture-insert 'my-event-date)`-reservation
  :TRIGGER: `(my-capture-insert 'my-event-date)`-offer-seats(TODO) `(my-capture-insert 'my-event-date)`-reminder-email(TODO)
  :END:

  ,*** Email: offer `(my-capture-insert 'my-num-seats)`-2 seats
  SCHEDULED: <`(my-capture-prompt "date 1st email" 'my-email-date)`>
  :PROPERTIES:
  :ID: `(my-capture-insert 'my-event-date)`-offer-seats
  :END:

  Email template:
  ,#+BEGIN_QUOTE
  Cabaret: `(my-capture-insert 'my-artist)` on `(my-capture-insert 'my-event-date)`

  Hi friends!

  Who: `(my-capture-insert 'my-artist)`
  What: "`(my-capture-insert 'my-title)`"
  When: `(my-capture-insert 'my-event-date)` 19:15
  Where: `(my-capture-selection '("Theatercafé" "Orpheum") 'my-location)`

  First come, first served. We've got `(my-capture-insert 'my-num-seats)` seats.

  Karl
  ,#+END_QUOTE

  ,*** Send reminder email
  SCHEDULED: <`(my-capture-prompt "date reminder" 'my-reminder-date)`>
  :PROPERTIES:
  :BLOCKER: `(my-capture-insert 'my-event-date)`-offer-seats
  :ID: `(my-capture-insert 'my-event-date)`-reminder-email
  :END:

  ,*** `(my-capture-insert 'my-artist)`: "`(my-capture-insert 'my-title)`" (`(my-capture-insert 'my-location)`)
  :PROPERTIES:
  :ID: `(my-capture-insert 'my-event-date)`-cabaret-event
  :END:

  <`(my-capture-insert 'my-event-date)` 20:00-23:30>

#+end_src

As you can see, with the =my-capture-promt= and the =my-capture-insert= functions, it is very easy to re-use for example the date of the event multiple times.
可以看到，使用=my-capture-promt=和=my-capture-insert=函数，很容易重用事件的日期等。

Applying the snippet and creating an instance will result in something like this:
应用该代码段并创建一个实例将得到如下结果:

#+BEGIN_EXAMPLE
0_sync_master.sh 1_add_new_article_manual.sh 1_add_new_article_newspaper.sh 2_start_translating.sh 3_continue_the_work.sh 4_finish.sh 5_pause.sh base.sh parse_url_by_manual.sh parse_url_by_newspaper.py parse_url_by_newspaper.sh project.cfg reformat.sh urls_checker.sh Cabaret 2017-01-24: Thomas Maurer
:PROPERTIES:
:ID: 2017-01-24-cabaret
:END:

- Title: Der Tolerator
- 8 seats reserved:
- 2: My girlfriend and I
- 2:
- 2:
- 2:

0_sync_master.sh 1_add_new_article_manual.sh 1_add_new_article_newspaper.sh 2_start_translating.sh 3_continue_the_work.sh 4_finish.sh 5_pause.sh base.sh parse_url_by_manual.sh parse_url_by_newspaper.py parse_url_by_newspaper.sh project.cfg reformat.sh urls_checker.sh WAITING Make reservation for 8 seats
:PROPERTIES:
:ID: 2017-01-24-reservation
:TRIGGER: 2017-01-24-offer-seats(TODO) 2017-01-24-reminder-email(TODO)
:END:

0_sync_master.sh 1_add_new_article_manual.sh 1_add_new_article_newspaper.sh 2_start_translating.sh 3_continue_the_work.sh 4_finish.sh 5_pause.sh base.sh parse_url_by_manual.sh parse_url_by_newspaper.py parse_url_by_newspaper.sh project.cfg reformat.sh urls_checker.sh Email: offer 8-2 seats
SCHEDULED: <2017-01-05>
:PROPERTIES:
:ID: 2017-01-24-offer-seats
:END:

Email template:
#+BEGIN_QUOTE
Cabaret: Thomas Maurer on 2017-01-24

Hi friends!

Who: Thomas Maurer
What: "Der Tolerator"
When: 2017-01-24 19:15
Where: Theatercafé

First come, first served. We've got 8 seats.

Karl
#+END_QUOTE

0_sync_master.sh 1_add_new_article_manual.sh 1_add_new_article_newspaper.sh 2_start_translating.sh 3_continue_the_work.sh 4_finish.sh 5_pause.sh base.sh parse_url_by_manual.sh parse_url_by_newspaper.py parse_url_by_newspaper.sh project.cfg reformat.sh urls_checker.sh Send reminder email
SCHEDULED: <2017-01-21>
:PROPERTIES:
:BLOCKER: 2017-01-24-offer-seats
:ID: 2017-01-24-reminder-email
:END:

0_sync_master.sh 1_add_new_article_manual.sh 1_add_new_article_newspaper.sh 2_start_translating.sh 3_continue_the_work.sh 4_finish.sh 5_pause.sh base.sh parse_url_by_manual.sh parse_url_by_newspaper.py parse_url_by_newspaper.sh project.cfg reformat.sh urls_checker.sh Thomas Maurer: "Der Tolerator" (Theatercafé)
:PROPERTIES:
:ID: 2017-01-24-cabaret-event
:END:

<2017-01-24 20:00-23:30>

#+END_EXAMPLE

Notice that with multiple cabaret events on different dates, the IDs are still unique due to the event date being part of it and all dependencies are pre-defined accordingly.
注意，对于不同日期的多个cabaret事件，id仍然是惟一的，因为事件日期是其中的一部分，并且所有依赖项都是预先定义的。

Once the reservation is acknowledged and its task is marked as done, the two tasks for sending out the emails get their "TODO" status via =:TRIGGER:=.
确认预订并将其任务标记为done后，发送电子邮件的两个任务将通过=:TRIGGER:=获得“TODO”状态。

Update 2017-11-23: the propagation of the status keyword [[http://lists.gnu.org/archive/html/emacs-orgmode/2017-11/msg00260.html][does not work for some cases]].
更新2017-11-23:状态关键字的传播[[http://lists.gnu.org/archive/html/emacs-orgmode/2017-11/msg00260.html][在某些情况下不工作]]。

To demonstrate a blocking precondition, I added a =:BLOCKER:= dependency for the reminder email task which is a bit redundant in this particular example. There is a subtle additional difference with the =:BLOCKER:= heading as well: as long as the blocking ID is not marked as done (or canceled), the =:BLOCKER:= task does not get on my agenda. This is awesome because I don't see already defined and scheduled tasks as long as the pre-condition is not met. Therefore, I always define =:TRIGGER:= and =:BLOCKER:= dependencies in my workflows in order to keep my agenda not messed up with todos I am not able to do now.
为了演示阻塞先决条件，我为提醒电子邮件任务添加了=:BLOCKER:= dependency，在这个特定的示例中，它有点多余。与=:BLOCKER:= heading还有一个细微的额外区别:只要阻塞ID没有标记为完成(或取消)，=:BLOCKER:=任务就不会出现在我的日程中。这非常棒，因为只要不满足先决条件，我就看不到已经定义和计划的任务。因此，我总是在我的工作流程中定义=:TRIGGER:=和=:BLOCKER:=依赖项，以使我的日程不被我现在无法处理的todos搞得一团糟。

Defining a complex snippet takes time and effort. Although once you have defined a complex snippet for a workflow, the beauty is that a workflow instance can be easily set-up for many times.
定义一个复杂的代码片段需要时间和精力。尽管您已经为工作流定义了一个复杂的代码片段，但它的优点是可以轻松地多次设置工作流实例。

** Advanced Workflows
* *先进的工作流
:PROPERTIES:
属性:
:CUSTOM_ID: advanced-workflows
:CUSTOM_ID advanced-workflows
:CLASS: section-title
类:节标题
:END:
结束:

The cabaret example is a rather simple one just to demonstrate the basic idea. Much more complex workflows I use are project templates, eBay-purchase workflow, [[https://en.wikipedia.org/wiki/Scrum_%2528software_development%2529][Scrum]] stories management, and even whole lecture management for an entire term including exam preparation and student grading that consists of dozens of headings.
卡巴莱酒店的例子比较简单，只是为了演示基本的思想。我使用的更复杂的工作流程是项目模板，eBay-purchase工作流，[[https://en.wikipedia.org/wiki/Scrum_%2528software_development%2529][Scrum]]故事管理，甚至是整个学期的整个课程管理，包括考试准备和学生评分，这些都是由几十个标题组成的。

Additional to the =:TRIGGER:= and =:BLOCKER:= dependencies I was using in my snippet, =org-depend.el= offers other features as well. With =chain-siblings(KEYWORD)= the next heading gets the status =KEYWORD= when the current heading gets marked as done. Then there is =chain-siblings-scheduled= which moves on the SCHEDULED date to the next heading as well. =chain-find-next(KEYWORD[,OPTIONS])= helps you finding the "next" heading.
除了在代码片段中使用的=:TRIGGER:=和=:BLOCKER:= dependencies之外，还有=:org-depend。el=还提供了其他功能。With =chain-sibling(关键字)=当当前标题被标记为完成时，下一个标题会得到status =KEYWORD=。然后是=chain-siblings-scheduled=它也将在预定日期移动到下一个标题。=chain-find-next(KEYWORD[，OPTIONS])=帮助查找“下一个”标题。

Although those are nifty features, I don't use them because I would need even more elaborate features which I discuss in the following sections.
虽然这些是很好的特性，但我不使用它们，因为我需要更详细的特性，我将在下面几节中讨论这些特性。

** Room for Improvements
**改进空间
:PROPERTIES:
属性:
:CUSTOM_ID: room-for-improvements
:CUSTOM_ID room-for-improvements
:CLASS: section-title
类:节标题
:END:
结束:

Since I am a power-user of =org-depend.el= and [[https://lists.gnu.org/archive/html/emacs-orgmode/2016-12/msg00236.html][Carsten asked for ideas on improving =org-depend.el=]] I wrote down some possible improvements that would ease my personal digital life.
因为我是=org-depend的高级用户。el=和[[https://lists.gnu.org/archive/html/emacs-orgmode/2016-12/msg00236.html]]我写下了一些可能会改善我的个人数字生活的方法。

Some of them are probably solved with a few lines of Elisp code. Unfortunately, I am very bad at coding Elisp myself and thus can't extend Emacs the way I would love to.
其中一些问题可能用几行Elisp代码就解决了。不幸的是，我自己对Elisp的编码能力很差，因此不能以我想要的方式扩展Emacs。

*** Improvement: ID Picker
***改进:ID选择器
:PROPERTIES:
属性:
:CUSTOM_ID: improvement-id-picker
:CUSTOM_ID improvement-id-picker
:CLASS: section-title
类:节标题
:END:
结束:

First of all, I'd like to see some kind of ID picker when defining =:TRIGGER:= and =:BLOCKER:= dependencies.
首先，我希望在定义=:TRIGGER:=和=:BLOCKER:= dependencies时看到某种ID选择器。

This should work like this: after setting up the task in headings and giving them IDs, I'd like to invoke a "I want to define a dependency"-command. It first asks me what property I want to set: =:TRIGGER:= or =:BLOCKER:=.
这应该是这样工作的:在标题中设置任务并给它们id之后，我想调用一个“我想定义一个依赖项”命令。它首先询问我要设置什么属性:=:TRIGGER:=或=:BLOCKER:=。

Then I get asked to select any ID which could be found within the same sub-hierarchy (or even in all files?).
然后我被要求选择任何可以在相同的子层次结构中找到的ID(或者甚至在所有文件中?)

After being asked for the KEYWORD to be set for =:TRIGGER:= dependencies (if applicable), the property is added to the current heading accordingly.
在被要求将关键字设置为=:TRIGGER:= dependencies(如果适用)之后，属性将相应地添加到当前标题。

This would drastically improve creating dependency definitions and prevent typing errors in the first place.
这将极大地改进依赖项定义的创建，并在第一时间防止键入错误。

*** Improvement: Generating IDs From Heading and Date
***改进:根据标题和日期生成id
:PROPERTIES:
属性:
:CUSTOM_ID: improvement-generating-ids-from-heading-and-date
:CUSTOM_ID improvement-generating-ids-from-heading-and-date
:CLASS: section-title
类:节标题
:END:
结束:

So far, I define =:ID:= properties manually. There are settings that result in random IDs set for any new heading. I don't like random ID numbers because I would like to get a hint what heading this might be when I see it.
到目前为止，我手动定义了=:ID:=属性。有些设置会导致为任何新标题设置随机id。我不喜欢随机的身份证号码，因为我想得到一个提示，这可能是什么标题，当我看到它。

Usually, my IDs start with the current ISO day to enforce uniqueness and look like this:
通常，我的id从当前的ISO日开始执行唯一性，如下所示:

*Title*
*标题*
*Manual ID*
*手动ID *
Update notebook
更新的笔记本
2016-12-18-update-notebook
2016 - 12 - 18 -更新笔记本
Schedule a meeting with Bob
和鲍勃安排一个会议
2016-12-18-schedule-meeting-bob
2016 - 12 - 18 -计划-会议-鲍勃
Add additional URLs to lecture notes
在课堂笔记中添加额外的url
2016-12-18-add-URLs-to-lecture
2016 - 12 - 18 - - url添加到讲座

Wouldn't it be nice when there is a command which takes the current heading title and auto-generates the ID property accordingly? I guess this is not that hard to do:
如果有一个命令使用当前标题并自动生成相应的ID属性，这不是很好吗?我想这并不难做到:

*Title*
*标题*
*Auto-generated ID*
*自动生成ID *
Update notebook
更新的笔记本
2016-12-18-Update-notebook
2016 - 12 - 18 -更新笔记本
Schedule a meeting with Bob
和鲍勃安排一个会议
2016-12-18-Schedule-a-meeting-with-Bob
2016 - 12 - 18 -计划- - -会见鲍勃
Add additional URLs to lecture notes
在课堂笔记中添加额外的url
2016-12-18-Add-additional-URLs-to-lecture-notes
2016 - 12 - 18 -添加额外的url - -讲座笔记

*** Improvement: Assistant for Creating Workflow Elements
***改进:帮助创建工作流元素
:PROPERTIES:
属性:
:CUSTOM_ID: improvement-assistant-for-creating-workflow-elements
:CUSTOM_ID improvement-assistant-for-creating-workflow-elements
:CLASS: section-title
类:节标题
:END:
结束:

This is an idea that Christophe Schockaert [[https://lists.gnu.org/archive/html/emacs-orgmode/2016-12/msg00251.html][wrote on the mailinglist]]: Why not having an assistant which does multiple things at once?
这是Christophe Schockaert [[https://lists.gnu.org/archive/html/emacs-orgmode/2016-12/msg00251.html][在邮件列表中写道]:为什么不拥有一个可以同时做多件事情的助手呢?

#+BEGIN_QUOTE
# + BEGIN_QUOTE
[...]\
Besides that, I wonder if/how we could automate the following course of
除此之外，我想知道我们是否可以自动化以下的课程
actions:\
- let have point on an entry\
- create a new "TODO-like" entry as a link to that entry\
- assign an ID to both entries: lets say "ID-original" and "ID-duplicate"\
- in the new entry: define a BLOCKER property set on "ID-original"\
- in the original entry: define a TRIGGER property set as
-在原始条目中:定义一个触发器属性集为
ID-duplicate(DONE)\
At first sight:\
- the new entry could be created besides the original or in a file where
-新的项目可以创建除了原来的或在一个文件
it is ready to refile\
- the TODO state in the new entry could be set with a default, I think
-我认为新条目中的TODO状态可以设置为默认状态
it is so easy to switch afterwards with Org keystrokes\
- the triggered state might better be a parameter (possibly a customized
-触发状态最好是一个参数(可能是自定义的)
default as "TODO"): otherwise, it would be necessary to go inside the
默认值为“TODO”):否则，必须进入
drawer to change it\
Currently, I am doing all this manually, quite often. [...]
目前，我通常都是手动完成这些工作。[…]
#+END_QUOTE
# + END_QUOTE

I can copy that: this is a very common set of operations which are done together. However, I personally would like to have the previously mentioned functions above *in addition* to this assistant.
我可以复制:这是一组非常常见的操作，它们是一起完成的。但是，我个人希望除了这个助理之外，还有上面提到的功能。

*** Improvement: TRIGGER in Combination With Set SCHEDULED
***改进:触发器与Set调度相结合
:PROPERTIES:
属性:
:CUSTOM_ID: improvement-trigger-in-combination-with-set-scheduled
:CUSTOM_ID improvement-trigger-in-combination-with-set-scheduled
:CLASS: section-title
类:节标题
:END:
结束:

I love the =:TRIGGER:= property because I can mark headings as open tasks only if they can be done now. Only headings which are ready to be looked at do have the =TODO= keyword.
我喜欢=:TRIGGER:=属性，因为我可以将标题标记为打开的任务，除非它们现在就可以完成。只有可以查看的标题才有=TODO=关键字。

One limitation of =org-depend.el= is that I am only to move forward scheduled dates to siblings and I am not able to define a different scheduled date.
=org-depend的一个限制。el=是我只能将计划日期向前移动到兄弟姐妹，我不能定义一个不同的计划日期。

Assume following syntax:
假设如下语法:

#+BEGIN_EXAMPLE
0_sync_master.sh 1_add_new_article_manual.sh 1_add_new_article_newspaper.sh 2_start_translating.sh 3_continue_the_work.sh 4_finish.sh 5_pause.sh base.sh parse_url_by_manual.sh parse_url_by_newspaper.py parse_url_by_newspaper.sh project.cfg reformat.sh urls_checker.sh TODO Asking the client about the project
:PROPERTIES:
:TRIGGER: 2016-12-18-send-offer(TODO,2016-12-23)
:END:

0_sync_master.sh 1_add_new_article_manual.sh 1_add_new_article_newspaper.sh 2_start_translating.sh 3_continue_the_work.sh 4_finish.sh 5_pause.sh base.sh parse_url_by_manual.sh parse_url_by_newspaper.py parse_url_by_newspaper.sh project.cfg reformat.sh urls_checker.sh Send offer to client
:PROPERTIES:
:ID: 2016-12-18-send-offer
:END:
#+END_EXAMPLE

I extended the option of the trigger property so that I added an ISO date to the keyword parameter.
我扩展了触发器属性的选项，以便向关键字参数添加ISO日期。

What I'd expect is that on finishing the first task, the heading with the ID =2016-12-18-send-offer= not only gets the keyword =TODO= but also is scheduled for 2016-12-23 as well.
我希望在完成第一个任务时，ID =2016-12-18-send-offer=的标题不仅得到关键字=TODO=，而且也被安排在2016-12-23。

Notice that the send-offer heading is not necessarily located in the same sub-hierarchy as the ask-client heading. Therefore, sibling-operations are not the whole answer here.
请注意，发送-报价标题不一定位于与询问-客户标题相同的子层次结构中。因此，兄弟操作并不是这里的全部答案。

Additional to this, I'd like to have the possibility to define relative schedule dates as stated in [[http://orgmode.org/manual/The-date_002ftime-prompt.html#The-date_002ftime-prompt][manual for the date prompt]]:
除此之外，我希望能够定义相关的日程日期，如[[http://orgmode.org/manual/date_002ftime -prompt.html# the -date_002ftime-prompt][日期提示的手册]]:

=2016-12-18-send-offer(TODO,.)=
= 2016 - 12 - 18 -发送提供(TODO。) =
the day when marking the asking-task as done
将询问任务标记为已完成的那一天
=2016-12-18-send-offer(TODO,+3d)=
= 2016 - 12 - 18 -发送提供(TODO, + 3 d) =
3 days after the scheduled date of the asking-task
询问任务的预定日期后3天
=2016-12-18-send-offer(TODO,.+3d)=
= 2016 - 12 - 18 -发送报价(TODO。+ 3 d) =
3 days from the day when marking the asking-task as done
自任务完成之日起3天内完成
=2016-12-18-send-offer(TODO,mon)=
= 2016 - 12 - 18 -发送提供(TODO, mon) =
nearest Monday from the day when marking the asking-task as done
最接近完成任务当天的星期一
=2016-12-18-send-offer(TODO,+2tue)=
= 2016 - 12 - 18 -发送提供(TODO, + 2星期二)=
second Tuesday from the day when marking the asking-task as done
第二个星期二，从标记任务完成的那一天算起

*** Improvement: Canceled Tasks Do Cancel Their Dependencies as Well
改进:被取消的任务也会取消它们的依赖关系
:PROPERTIES:
属性:
:CUSTOM_ID: improvement-canceled-tasks-do-cancel-their-dependencies-as-well
:CUSTOM_ID improvement-canceled-tasks-do-cancel-their-dependencies-as-well
:CLASS: section-title
类:节标题
:END:
结束:

Wouldn't it be nice to have a general setting (or a property?) whether or not I want to handle canceled tasks differently as tasks marked as done?
如果有一个通用设置(或属性?)不是更好吗?

Imagine the example from above. Does it really make sense to send an offer when I canceled the ask-client task? Many people probably would love to cancel all follow-up workflow tasks as well.
想象一下上面的例子。当我取消了询问客户的任务时，发送报价真的有意义吗?许多人可能也想取消所有后续的工作流任务。

** Conclusion
* *的结论
:PROPERTIES:
属性:
:CUSTOM_ID: conclusion
结论:CUSTOM_ID:
:CLASS: section-title
类:节标题
:END:
结束:

While most people do not need advanced workflow management, such as dependencies between tasks, I do love this Org-mode feature. It was the reason I started with Org-mode in the first place. I love that my agenda only shows tasks which can be done *now* and whose dependencies are already met.
虽然大多数人不需要高级工作流管理，比如任务之间的依赖关系，但我确实喜欢这个组织模式特性。这就是我开始使用组织模式的原因。我喜欢我的日程表只显示“现在”可以完成的任务和已经完成的任务。

So even when you did not feel the urge to define your workflows with a snippet/template system you might enjoyed this article. Maybe you are going to start defining simple workflows as well.
因此，即使您不想使用代码片段/模板系统来定义工作流，您也会喜欢这篇文章。也许您也将开始定义简单的工作流。

I'd love to read your comments on snippets, workflows, dependencies and such: write me an email or commend via Disqus (see below).
我很乐意阅读你对代码片段、工作流程、依赖关系等的评论:给我写一封电子邮件或通过Disqus推荐(见下文)。

** org-edna
* * org-edna
:PROPERTIES:
属性:
:CUSTOM_ID: org-edna
:CUSTOM_ID org-edna
:CLASS: section-title
类:节标题
:END:
结束:

As an alternative to org-depend, I was recommended to take a look at [[https://elpa.gnu.org/packages/org-edna.html][org-edna]]. From the first impression, it is quite similar to org-depend but different. It is more complex and allows more advanced definitions of dependencies. I am looking forward to testing org-edna and I'll blog about it.
作为对org-depend的一种替代方法，我被推荐查看[[https://elpa.gnu.org/packages/org-edna.html][org-edna]]。从第一印象上看，它与组织非常相似，但又有所不同。它更复杂，并且允许对依赖项进行更高级的定义。我期待着测试org-edna，我将在博客上谈论它。
