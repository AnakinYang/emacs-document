#+TITLE: Exploring Emacs chart Library
#+URL: http://francismurillo.github.io/2017-04-15-Exploring-Emacs-chart-Library/
#+AUTHOR: lujun9972
#+TAGS: raw
#+DATE: [2020年 02月 08日 星期六 18:55:48 HKT]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t n:nil ::t |:t ^:nil -:nil f:t *:t <:nil

** 条形图
:PROPERTIES:
:CUSTOM_ID: org9a9b82e
:END:

[[https://en.wikipedia.org/wiki/Bar_chart#p-search][Bar Charts]] is a simple way to visualize grouped data through colorful rectangles. In the world of text buffers and shell output, it is surprising that Emacs has a library to draw colored rectangles: =chart=.
[[https://en.wikipedia.org/wiki/Bar_chart#p-search][Bar Charts]]是一种通过彩色矩形可视化分组数据的简单方法。在文本缓冲区和shell输出的世界中，Emacs有一个用来绘制彩色矩形的库:=chart=。

#+BEGIN_EXAMPLE
(require 'chart)

(chart-bar-quickie
'vertical "Favorite Type of Movie" ;; Type & Title
'("Comedy" "Action" "Romance" "Drama" "Sci-Fi") "Genre" ;; Keys & Label
'(4 5 6 1 4) "People" ;; Values & Label
)
#+END_EXAMPLE

[[http://francismurillo.github.io/hacker/images/exploring-emacs-chart--cover.png]]

As the screenshot shows above, it is not sophisticated enough to warrant deep examination but still impressive within the realm of text buffers. The context of being builtin leads to fascinating queries about the Emacs interpreter such as =memory-usage=.
正如上面的屏幕截图所示，它还不够复杂，不足以进行深入的检查，但在文本缓冲区范围内仍然令人印象深刻。构建的上下文会导致关于Emacs解释器的有趣查询，如=memory-usage=。

[[http://francismurillo.github.io/hacker/images/exploring-emacs-chart--memory-usage.png]]

If you want to try it out, you can use the command =load-library= to import =chart=. It defines the following demo command for exploration:
如果您想尝试一下，可以使用命令=load-library=来导入=chart=。它定义了下面的演示命令进行探索:

- =chart-emacs-storage= :: This charts the output of =memory-usage=
- =chart-emacs-storage=::这个图表显示了=memory-usage=的输出
- =chart-emacs-lists= :: Like =chart-emacs-storage=, this counts /buffers/, /frames/, /processes/, /faces/ and /x-display/ within the Emacs session
- =chart-emacs-lists=::与chart-emacs-storage=::类似，在Emacs会话中，它会计数/buffer /， /frames/， /processes/， /faces/和/x-display/
- =chart-rmail-from= :: With =rmail=, it groups user sender occurrences by mail
- =chart-rmail-from=:: With =rmail=，它通过邮件对用户发送方的事件进行分组
- =chart-space-usage= :: After selecting a directory, it shows the disk usage by file type within said directory
- =chart-space-usage=::在选择一个目录之后，它会根据该目录中的文件类型显示磁盘使用情况
- =chart-file-count= :: After selecting a directory, it displays file type occurrences within the directory
- =chart-file-count=::在选择目录之后，它会显示目录中出现的文件类型
- =chart-test-it-all= :: A chart testing positive and negative values
- =chart-test-it-all=::测试正负值的图表

Aside from those demo commands, how can we use it and make a chart?
除了这些演示命令之外，我们如何使用它来制作图表呢?

** Making A Chart
做一张图表
:PROPERTIES:
:CUSTOM_ID: orgff4f6b1
:END:

After some reading and exploration, the starting command or function to understand this library is =chart-bar-quickie=, the rest seem internal. Although this function has a total of eight arguments which two are optional, it encapsulates everything needed to make the chart including labels and data rather than instantiating /classes/ and /objects/. A small snippet to elaborate:
经过一些阅读和探索，理解这个库的起始命令或函数是=chart-bar-quickie=，其余的似乎是内部的。虽然这个函数总共有8个参数，其中两个是可选的，但是它封装了创建图表所需的一切，包括标签和数据，而不是实例化/classes/和/objects/。一个小片段来阐述:

#+BEGIN_EXAMPLE
(defun fn/chart-comparator-< (left right)
"A sample comparator for the values.
Each parameter is a key-value cos pair and should function as a
comparator like `<', `=', or `>'."
(pcase-let ((`(,left-key . ,left-value) left) ;; left is a cons of key and value
(`(,right-key . ,right-value) right) ;; ditto with right
)
(< left-value right-value)))

(chart-bar-quickie
'vertical ;; Chart direction, either 'vertical or 'horizontal
"Chart Title" ;; Chart title
'("Alpha" "Beta" "Gamma" "Delta") ;; X-Axis values or keys
"X Line" ;; X-Axis label
'(4 3 2 1) ;; Y-Axis values
"Y Line" ;; Y-Axis label
;; Optional
3 ;; Max value allowed, anything higher is not shown
#'fn/chart-comparator-< ;; Sorting or ordering function
)
#+END_EXAMPLE

[[http://francismurillo.github.io/hacker/images/exploring-emacs-chart--sample.png]]

Once evaluated, this creates a new buffer based on the title and renders the bar chart there. The display itself is inert unlike =tabulated-list-mode= or any special buffer modes, so do not expect special key bindings or commands that sort, zoom, refresh the chart out of the box. Aside from tempering expectations, all the major (if not all) functionality is within that function. (Sadly, looking any deeper does not yield any more insights.) Lastly, the only caveat here is that the size of the keys and values should be the same which is natural as it matches each key with the corresponding value.
一旦求值，就会根据标题创建一个新的缓冲区，并在那里呈现条形图。显示本身是惰性的，不像=列表模式=或任何特殊的缓冲模式，所以不要期望特殊的键绑定或命令来排序、缩放、刷新图表。除了缓和预期之外，所有主要(如果不是全部)功能都在该功能中。(遗憾的是，再往深处看也不会产生更多的洞见。)最后，这里唯一需要注意的是，键和值的大小应该是相同的，这很自然，因为它将每个键与相应的值匹配起来。

** Demonstration
\* \*示威
:PROPERTIES:
:CUSTOM_ID: org3dfd9a1
:END:

As an example, let us tackle a statistical query on a dataset. We will play with the [[https://vincentarelbundock.github.io/Rdatasets/csv/datasets/HairEyeColor.csv][Hair Eye Color dataset]] which looks like this:
作为一个示例，让我们处理一个数据集上的统计查询。我们将使用[[https://vincentarelbundock.github.io/Rdatasets/csv/datasets/HairEyeColor。csv][头发眼睛颜色数据集]]，它看起来像这样:

#+BEGIN_EXAMPLE
"","Hair","Eye","Sex","Freq"
"1","Black","Brown","Male",32
"2","Brown","Brown","Male",53
"3","Red","Brown","Male",10
"4","Blond","Brown","Male",3
"5","Black","Blue","Male",11
#+END_EXAMPLE

Before we query, let us import the data which is a good exercise for CSV parsing in Emacs:
查询之前，让我们导入数据，这是一个很好的练习CSV解析在Emacs:

#+BEGIN_EXAMPLE
(setq csv-dataset-file (expand-file-name "HairEyeColor.csv" "~/Downloads"))

(defun read-lines (file) ;; Take your pick: custom, find-file, f-read-text
(with-temp-buffer
(insert-file-contents-literally file)
(split-string
(decode-coding-region (point-min) (point-max) 'utf-8 t)
"n"
t)))

(defun read-csv-field (field) ;; Remove the pesky enclosed double quoting
(cond
((zerop (length field)) "")
((and (string-equal (substring-no-properties field 0 1) """)
(string-equal (substring-no-properties field -1) """))
(substring-no-properties field 1 -1))
(t (string-to-number field))))

(defun read-csv-line (line)
(let ((raw-fields ;; This assumes no rogue commas need escaping
(split-string line ",")))
(mapcar #'read-csv-field raw-fields)))

(defun read-csv-file (file)
(mapcar #'read-csv-line (read-lines file)))


(setq dataset (read-csv-file csv-dataset-file))

;; Generated output
(("" "Hair" "Eye" "Sex" "Freq")
("1" "Black" "Brown" "Male" 32)
("2" "Brown" "Brown" "Male" 53)
("3" "Red" "Brown" "Male" 10)
("4" "Blond" "Brown" "Male" 3))
#+END_EXAMPLE

Libraries exist for this purpose such as =csv=, =el-csv= or =parse-csv= and utilities like =f= or =parsec= but doing it yourself is an occasional opportunity to review the basics. With that handled, what can we ask of the data? *What is the frequency of eye colors?* Before that, we need to group the data:
有一些库是为此目的而存在的，如=csv=、=el-csv=或=parse-csv=，以及诸如=f=或=parsec=这样的实用程序，但是您可以偶尔自己动手查看基础知识。在这种情况下，我们能对数据提出什么要求呢?\*眼睛颜色的频率是多少?\*在此之前，我们需要对数据进行分组:

#+BEGIN_EXAMPLE
(setq headers (car dataset) ;; Only mentioned, not needed
records (cdr dataset))

(defun group-by (f xs) ;; A quick write on -group-by
(let ((groups (list)))
(mapc
(lambda (x)
(let* ((key (funcall f x))
(key-group (assoc key groups)))
(unless key-group
(push (cons key (list)) groups)
(setq key-group (assoc key groups)))
(setcdr key-group (cons x (cdr key-group)))))
xs)
groups))

(defun group-records-by-eye-color (records)
(let* ((raw-eye-groups (group-by (apply-partially #'nth 2) records))
(eye-groups (mapcar
(lambda (eye-group)
(pcase-let ((`(,eye-color . ,eye-records) eye-group))
(let ((eye-frequencies ;; Extract frequencies and collect it
(mapcar (apply-partially #'nth 4) eye-records)))
(cons eye-color
(apply #'+ eye-frequencies) ;; Shiv for sum
))))
raw-eye-groups)))
eye-groups))


(setq eye-color-groups (group-records-by-eye-color records))

;; Generated output
(("Green" . 64)
("Hazel" . 93)
("Blue" . 215)
("Brown" . 220))
#+END_EXAMPLE

After writing the extraction, getting the bar chart is straightforward.
在编写提取之后，获取柱状图就很简单了。

#+BEGIN_EXAMPLE
(chart-bar-quickie
'horizontal
"Eye Colors"
(mapcar #'car eye-color-groups) "Colors"
(mapcar #'cdr eye-color-groups) "Frequency")
#+END_EXAMPLE

[[http://francismurillo.github.io/hacker/images/exploring-emacs-chart--eye-color.png]]
[http://francismurillo.github.io/hacker/images/exploring-emacs-chart--eye-color.png]

Neat but let's arrange it by descending order:
很整洁，但让我们按降序排列:

#+BEGIN_EXAMPLE
(defun on (f op) ;; Haskell's on operator
(lexical-let ((f f) ;; Sad that parameters aren't lexically scoped here
(op op))
(lambda (left right)
(funcall op (funcall f left) (funcall f right)))))

(chart-bar-quickie
'horizontal
"Eye Colors - Descending"
(mapcar #'car eye-color-groups) "Colors"
(mapcar #'cdr eye-color-groups) "Frequency"
nil
(on #'cdr #'>) ;; A comparator lambda also works but done for variety
)
#+END_EXAMPLE

[[http://francismurillo.github.io/hacker/images/exploring-emacs-chart--eye-color-descending.png]]

Looking at it, /brown/ and /blue/ eye colors are quite frequent. Nothing groundbreaking or epic. How about applying the same process with /hair color/? We get the following chart:
看着它，/棕色/和/蓝色/眼睛的颜色很常见。没有什么突破性的或史诗般的东西。用同样的方法处理/发色/怎么样?我们得到如下图表:

[[http://francismurillo.github.io/hacker/images/exploring-emacs-chart--hair-color.png]]

With /hair color/ as the variable, /brown/ and /blonds/ are many. Nothing fancy. We could change the variable into /gender/ but nothing more would be gained. The real question for any visualization is *what does it mean?* Rather, what insights can we interpret from the data? Since it is a sample, it might not mean anything nor does it have to. This is a library exploration, not a statistical lesson that is beyond scope.
以/头发颜色/为变量，/棕色/和/金发/很多。没有什么幻想。我们可以把变量改成/gender/，但不会得到更多的结果。任何可视化的真正问题是\*它意味着什么?相反，我们能从数据中解读出什么见解?因为它是一个样本，它可能没有任何意义，也不需要。这是一个图书馆的探索，而不是一个超出范围的统计教训。

** 结论
:PROPERTIES:
:CUSTOM_ID: org454b2f4
:END:

Strangely, that is all there is to it: *a neat and easy builtin bar chart library.* Since it is not pixel precise, it does not compete with the modern visualizations tools or languages such as [[https://en.wikipedia.org/wiki/Python_%28programming_language%29][Python]], [[https://www.r-project.org/][R]] or [[https://www.haskell.org/][Haskell]] although it does not have to. It simply is nice to have and fun to know.
奇怪的是，这就是它的全部:\*一个整洁而简单的构建条形图库。\*因为它不是像素精确,它不与现代可视化工具或语言等[[https://en.wikipedia.org/wiki/Python_%28programming_language%29] [Python]], [[https://www.r-project.org/] [R]]或[[https://www.haskell.org/] [Haskell]]尽管它不需要。拥有它很好，知道它也很有趣。

Interestingly, if bar charts can be made with ASCII, how about pies or bubbles. Can Emacs be a modern visualization tool?
有趣的是，如果柱状图可以用ASCII来表示，那么扇形图和气泡图呢?Emacs可以成为现代可视化工具吗?
