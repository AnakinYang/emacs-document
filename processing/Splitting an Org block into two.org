#+TITLE: Splitting an Org block into two
#+URL: https://scripter.co/splitting-an-org-block-into-two/
#+AUTHOR: lujun9972
#+TAGS: raw
#+DATE: [2018年 09月 17日 星期一 17:02:10 HKT]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t n:nil ::t |:t ^:nil -:nil f:t *:t <:nil

* Problem
*问题
If I have a huge Org Src block, I'd like to split it into multiple Org
如果我有一个巨大的Org Src块，我想把它分成多个Org
Src blocks so that I can write my explanations in-between.
Src块，以便我可以写我的解释之间。

So I'd like to quickly split up:
所以我想快速地分解一下:

#+BEGIN_EXAMPLE
#+begin_src emacs-lisp
(message "one")
(message "two")
#+end_src
#+END_EXAMPLE

into:
into:

#+BEGIN_EXAMPLE
#+begin_src emacs-lisp
(message "one")
#+end_src

#+begin_src emacs-lisp
(message "two")
#+end_src
#+END_EXAMPLE

* Action Plan [[#action-plan][#]]
*行动计划[[#行动计划][#]]
:PROPERTIES:
属性:
:CUSTOM_ID: action-plan
:CUSTOM_ID:活动计划
:END:
结束:

1. Write a function to return non-nil if point is in *any* Org block
1. 写一个函数来返回非nil如果点在*任何* Org块
-- Not just “src”, “example”, “export” or any of the inbuilt Org
——不仅仅是“src”，“example”，“export”或者任何一个内建的组织
blocks.. but also any Org Special block like =#+begin_foo .. #+end_foo=.
块. .还有任何像=#+begin_foo。# + end_foo =。
2. Write a function that does this imagined block splitting.
2. 编写一个函数来实现这个想象中的块分割。
3. Overload the M-return binding so that this block splitting
3.重载M-return绑定，使该块分裂
function gets called only when the point is inside an Org block
函数仅当该点位于Org块内时才被调用
(detected using that first function).
(使用第一个函数检测)。

Thanks to the comment by reader *Mankoff*, I learnt
感谢读者*Mankoff*的评论，我了解到
about the =org-babel-demarcate-block= function (bound by default to
关于=org-babel-demarcate-block=函数(默认绑定到
C-c C-v d and C-c C-v C-d).
C-c C-v d和C-c C-v C-d)。

This function varies from the solution in this post in at least two
这个函数至少在两个方面与本文中的解决方案不同
ways:
方法:

1. It works only for Org Src blocks.
1. 它只对Org Src块有效。
2. It splits the block exactly at where the point is, whereas I would
2. 它正好在点的位置把物体分开，而我可以
like to always split only at EOL or BOL.
我喜欢只在EOL或BOL里分手。

But I can see that =org-babel-demarcate-block= can cover most of the
但是我可以看到=org-babel-demarcate-block=可以覆盖大部分
block splitting use cases.
块分割用例。

* Am I in an Org block? [[#org-in-any-block-p][#]]
*我在一个组织块吗? [[# org-in-any-block-p] [#]]
:PROPERTIES:
属性:
:CUSTOM_ID: org-in-any-block-p
:CUSTOM_ID org-in-any-block-p
:END:
结束:

Before venturing into writing this function, I looked at these
在开始编写这个函数之前，我查看了这些
existing ones, but none did what I exactly wanted:
现有的，但没有一个是我真正想要的:

- =org-in-src-block-p= :: Returns non-nil only if the point is in a
- =org-in-src-block-p=::仅当点在
=#+begin_src .. #+end_src= block; not when point is in any other
= # + begin_src . .# + end_src =块;当点在任何其他点
Org block.
组织块。
- =org-in-block-p= :: Returns non-nil only if the point is in one of
- =org-in-block-p=::仅当点位于
the pre-defined block names passed as a list (='("src" "example" "quote" ..)=). So this again won't work as I cannot pre-define all
以列表形式传递的预定义块名(='("src" "example" "quote" ..)=)。这也不行，因为我不能预先定义所有
Org Special blocks.
组织特殊的街区。

So I define the below =modi/org-in-any-block-p= function that returns
因此，我定义下面的=modi/org-in-any-block-p=返回的函数
non-nil if the point is in-between any =#+begin_FOOBAR .. #+end_FOOBAR=. Thankfully, I was able to reuse a lot of logic from
如果该点位于any =#+begin_FOOBAR之间，则非nil。# + end_FOOBAR =。谢天谢地，我可以重用很多逻辑
the =org-between-regexps-p= function (=org-in-block-p= uses that
=org-between-regexps-p= function (=org-in-block-p=使用它)
function internally).
函数内部)。

<<code-snippet-1>>
< < code-snippet-1 > >

#+BEGIN_EXAMPLE
(defun modi/org-in-any-block-p ()
"Return non-nil if the point is in any Org block.

The Org block can be *any*: src, example, verse, etc., even any
Org Special block.

This function is heavily adapted from `org-between-regexps-p'."
(save-match-data
(let ((pos (point))
(case-fold-search t)
(block-begin-re "^[[:blank:]]*#\+begin_\(?1:.+?\)\(?: .*\)*$")
(limit-up (save-excursion (outline-previous-heading)))
(limit-down (save-excursion (outline-next-heading)))
beg end)
(save-excursion
;; Point is on a block when on BLOCK-BEGIN-RE or if
;; BLOCK-BEGIN-RE can be found before it...
(and (or (org-in-regexp block-begin-re)
(re-search-backward block-begin-re limit-up :noerror))
(setq beg (match-beginning 0))
;; ... and BLOCK-END-RE after it...
(let ((block-end-re (concat "^[[:blank:]]*#\+end_"
(match-string-no-properties 1)
"\( .*\)*$")))
(goto-char (match-end 0))
(re-search-forward block-end-re limit-down :noerror))
(> (setq end (match-end 0)) pos)
;; ... without another BLOCK-BEGIN-RE in-between.
(goto-char (match-beginning 0))
(not (re-search-backward block-begin-re (1+ beg) :noerror))
;; Return value.
(cons beg end))))))
#+END_EXAMPLE

[[code-snippet-1][Code Snippet 1]]
[[code-snippet-1][代码片段1]]

: Function to check if point is in any Org block
函数检查点是否在任何组织块中

- =(case-fold-search t)= ensures that either =#+BEGIN_ ..= or =#+begin_ ..= match.
- =(case-fold-search t)=确保其中一个=#+BEGIN_ ..=或=#+begin_ ..=匹配。
- The regular expression in =block-begin-re= matches with
-正则表达式=block-begin-re=匹配
="#+begin_src foo"= or =" #+begin_src foo"= or ="#+BEGIN_EXAMPLE"=
= " # + begin_src foo " = = " # + begin_src foo " =或= " # + BEGIN_EXAMPLE " =
or ="#+begin_FOOBAR"= or ..
or ="#+begin_FOOBAR"= or ..
- The =limit-up= and =limit-down= are set to the buffer locations of
-将=limit-up=和=limit-down=设置为的缓冲区位置
the previous and next Org headings. The following regexp searches
上一个和下一个组织标题。以下是regexp搜索
are limited to happen in those bounds for better performance.
为了获得更好的性能，只能在这些范围内发生。
- The =block-end-re= is dynamically constructed based on the string
- =block-end-re=是基于字符串动态构造的
matched using =block-begin-re=. This is so that if ="#+begin_quote"=
匹配使用= block-begin-re =。这样if ="#+begin_quote"=
is found initially, it matches the block ending with specifically
最初找到，它匹配块结束与具体
="#+end_quote"= and not something like ="#+end_src"=.
="#+end_quote"=而不是"#+end_src"=。
- nil is returned if the point is not between =#+begin_FOOBAR .. #+end_FOOBAR=.
如果点不在=#+begin_FOOBAR ..# + end_FOOBAR =。

- Caveat :: I haven't gone extra lengths to support nested block cases,
警告:我没有做额外的长度来支持嵌套块的情况，
specifically where the point is outside the inner-most
特别是在最内层之外的地方
block, but still inside the outer block:
块，但仍在外部块内:

#+BEGIN_EXAMPLE
#+begin_src org
▮
#+begin_src emacs-lisp
(message "hello!")
#+end_src
#+end_src
#+END_EXAMPLE

* If so, split the block [[#org-block-split][#]]
*如果是，则拆分block [[#org-block-split][#]]
:PROPERTIES:
属性:
:CUSTOM_ID: org-block-split
:CUSTOM_ID org-block-split
:END:
结束:

With the “point in an Org block” detection working, I now needed the
随着“组织块中的点”检测工作，我现在需要
split to happen with these rules:
分裂发生与这些规则:

1. If the point is anywhere on the line, but not at the beginning of
1. 如果点在直线上的任何一点，但不是在点的开始
the line (BOL),
线(BOL),

- Go to the end of the line, and then split the block.
-走到行尾，然后把木块分开。

So if the point is after the first =message= identifier,
如果点在第一个=message=标识符之后，
or at the end of that first =message= line:
或者在第一个=message=行的末尾:

#+BEGIN_EXAMPLE
#+begin_src emacs-lisp
(message "one")▮
(message "two")
#+end_src
#+END_EXAMPLE

Split the block at the point *after* =(message "one")= and move
在* =(message "one")=后*处拆分块并移动
the point to between the split blocks:
分块之间的点:

#+BEGIN_EXAMPLE
#+begin_src emacs-lisp
(message "one")
#+end_src
▮
#+begin_src emacs-lisp
(message "two")
#+end_src
#+END_EXAMPLE

2. Otherwise (if point is at BOL),
2. 否则(如果点在BOL)，

- Split the block exactly at that point.
-正好在那一点把木块分开。

So if the point is at the beginning of the second =message= line:
因此，如果该点位于第二个=message=行的开头:

#+BEGIN_EXAMPLE
#+begin_src emacs-lisp
(message "one")
▮(message "two")
#+end_src
#+END_EXAMPLE

Split the block at the point *before* =(message "two")= and move
在* =(消息“two”)=之前*处拆分块并移动
the point to between the split blocks:
分块之间的点:

#+BEGIN_EXAMPLE
#+begin_src emacs-lisp
(message "one")
#+end_src
▮
#+begin_src emacs-lisp
(message "two")
#+end_src
#+END_EXAMPLE

So here's the code that follows that spec:
下面是遵循该规范的代码:

<<code-snippet-2>>
< < code-snippet-2 > >

#+BEGIN_EXAMPLE
(defun modi/org-split-block ()
"Sensibly split the current Org block at point."
(interactive)
(if (modi/org-in-any-block-p)
(save-match-data
(save-restriction
(widen)
(let ((case-fold-search t)
(at-bol (bolp))
block-start
block-end)
(save-excursion
(re-search-backward "^\(?1:[[:blank:]]*#\+begin_.+?\)\(?: .*\)*$" nil nil 1)
(setq block-start (match-string-no-properties 0))
(setq block-end (replace-regexp-in-string
"begin_" "end_" ;Replaces "begin_" with "end_", "BEGIN_" with "END_"
(match-string-no-properties 1))))
;; Go to the end of current line, if not at the BOL
(unless at-bol
(end-of-line 1))
(insert (concat (if at-bol "" "n")
block-end
"nn"
block-start
(if at-bol "n" "")))
;; Go to the line before the inserted "#+begin_ .." line
(beginning-of-line (if at-bol -1 0)))))
(message "Point is not in an Org block")))
#+END_EXAMPLE

[[code-snippet-2][Code Snippet 2]]
[[code-snippet-2][代码片段2]]

: Function to split the current Org block in sensible fashion
函数以合理的方式分割当前的组织块

- The regexp for extracting =block-start= is the same as
-用于提取=block-start=的regexp与
=block-begin-re= in code snippet [[code-snippet-1][1]], but
=block-begin-re= in code snippet [[code-snippet-1][1]]，但是
with different sub-grouping.
不同的子群。
- The =block-end= string is derived from sub-group 1 of =block-start=
- =block-end= string派生自=block-start=的子组1
string -- just replacing “begin_” with “end_”.
string——用“end_”替换“begin_”。
- And then based on if the point was initially at BOL (=at-bol=), the
-然后根据该点在BOL (=at- BOL =)处的初始值
insertion of newlines and movement of point is done accordingly.
插入新行和移动点都是这样做的。

* Now make M-return do that [[#M-return-split-block-dwim][#]]
*现在让M-return做那个[[#M-return-split-block-dwim][#]]
:PROPERTIES:
属性:
:CUSTOM_ID: M-return-split-block-dwim
:CUSTOM_ID M-return-split-block-dwim
:END:
结束:

With these two functions evaluated, =M-x modi/org-split-block= will
对这两个函数求值，=M-x modi/org-split-block= will
work right away.
马上工作。

    But where's the fun in that‽\

I needed to have the Org block splitting happen with an intuitive
我需要有一个直观的Org块分裂发生
binding --- like M-return.
绑定——就像M-return。

- By default, M-return is used to either create new headings, or do
-默认情况下，M-return要么用来创建新标题，要么用来
other things like insert an item, wrap a region in table, etc. based
其他事情，比如插入一个项目，在表中包装一个区域，等等
on the context. See the doc-string of =org-meta-return= (function
在上下文。查看=org-meta-return=(函数的doc-string
bound to this key by default) for more info.
绑定到此键默认)以获取更多信息。
- But it doesn't have a context for “point in an Org block”. So it
-但它没有“组织块中的点”的上下文。所以它
tries to create a heading when inside a block too, which doesn't
在一个块中也尝试创建一个标题，但是没有
make much sense.
多大意义。
- So fix that by adding that context.
-所以通过添加上下文来解决这个问题。

So I *advise* =org-meta-return= to call =modi/org-split-block= when
因此，我*advise* =org-meta-return= to call =modi/org-split-block= when
the point is inside an Org block.
这个点在一个Org块中。

The advising function =modi/org-meta-return= is the same as the
通知函数=modi/org-meta-return=与
advised function =org-meta-return= (as of ), except
建议的函数=org-meta-return=(截至)，除非
that a new context =(modi/org-in-any-block-p)= is added.
添加新上下文=(modi/org-in-any-block-p)=。

You can tweak the precedence of this new context by moving the
可以通过移动
=((modi/org-in-any-block-p) #'modi/org-split-block)= form in that
=(莫迪/org-in-any-block-p
=cond= form.
=气孔导度=形式。

<<code-snippet-3>>
< < code-snippet-3 > >

#+BEGIN_EXAMPLE
(defun modi/org-meta-return (&optional arg)
"Insert a new heading or wrap a region in a table.

Calls `org-insert-heading', `org-insert-item',
`org-table-wrap-region', or `modi/org-split-block' depending on
context. When called with an argument, unconditionally call
`org-insert-heading'."
(interactive "P")
(org-check-before-invisible-edit 'insert)
(or (run-hook-with-args-until-success 'org-metareturn-hook)
(call-interactively (cond (arg #'org-insert-heading)
((org-at-table-p) #'org-table-wrap-region)
((org-in-item-p) #'org-insert-item)
((modi/org-in-any-block-p) #'modi/org-split-block)
(t #'org-insert-heading)))))
(advice-add 'org-meta-return :override #'modi/org-meta-return)
#+END_EXAMPLE

[[code-snippet-3][Code Snippet 3]]=org-meta-return= to add context of point being inside any Org block
[[Code - Snippet -3][Code Snippet 3]]= Org -meta-return=在任何组织块中添加点的上下文

: Advisingto add context of point being inside any Org block
:建议在任何组织块中添加点的上下文

Now with the point in *any* Org block, M-return away!
现在在点在*任何*组织块，m -返回!

* Full code [[#full-code][#]]
* Full code [[# Full code][#]]
:PROPERTIES:
属性:
:CUSTOM_ID: full-code
:CUSTOM_ID:完整代码
:END:
结束:

Look for the source of =modi/org-split-block= (and dependent
查找=modi/org-split-block=(且依赖)的来源
functions) added to [[https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-org.el][=setup-org.el=]] in my Emacs config.
函数)添加到我的Emacs配置中的[[https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-org.el][=setup-org.el=]]。
