#+TITLE: TIP: How to make ERC fun to use : emacs
#+URL: https://www.reddit.com/r/emacs/comments/8ml6na/tip_how_to_make_erc_fun_to_use/
#+AUTHOR: lujun9972
#+TAGS: raw
#+DATE: [2018年 06月 20日 星期三 13:08:42 CST]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t n:nil ::t |:t ^:nil -:nil f:t *:t <:nil
Another week, another trick. This week, I will present you my way of using =erc=, following the recommendation of several people. I apologize in advance for the relatively long post, I just like to be complete so that anyone can understand this post. First, for those who don't know IRC, it's roughly, which allows you to communicate with other people in real time on different channels. IRC is the best way for me to get a quick answer to a simple question and to learn from more competent people than me on a subject. For example, what I like to do when I learn a new language is to join their IRC channel, scan the logs at the end of each day and try to understand the questions with their answers asked. At first, it's confusing, but little by little I am familiar with the vocabulary used.
又一个星期，又一个诡计。本周，我将根据几个人的建议，向您介绍我使用=erc=的方法。我为这篇相对较长的文章提前道歉，我只是想写得完整一些，这样任何人都能看懂这篇文章。首先，对于那些不了解IRC的人来说，它是粗略的，它允许你通过不同的渠道与他人实时沟通。IRC是我快速回答一个简单问题的最好方法，也是我向比我更有能力的人学习的最好方法。例如，当我学习一门新语言的时候，我喜欢做的是加入他们的IRC频道，在每天结束的时候浏览日志，试着理解他们提出的问题并给出答案。起初，它令人困惑，但渐渐地我熟悉了所用的词汇。

Before going any further, here is what my =erc= looks like:
在继续之前，我的=erc=是这样的:

After ERC configuration
在ERC配置

If you're still interested in knowing more, then let's keep going!
如果你仍然有兴趣知道更多，那么让我们继续!

The question you need to ask yourself is how to use IRC so that it saves you more time than waste, because we quickly tend to spend our days sailing between the different channels, a bit like on Reddit. For my part, I wanted a configuration that was pleasant to read, targeting only what is necessary to be read and that informs me when someone has answered my question.
你需要问自己的问题是如何使用IRC来节省你的时间而不是浪费时间，因为我们很快就会把时间花在不同的频道上，有点像Reddit。就我而言，我想要一个易于阅读的配置，只针对需要阅读的内容，当有人回答了我的问题时，它会通知我。

Without going into details, here is the beginning of the configuration that I use:
无需详细介绍，以下是我使用的配置的开始:

#+BEGIN_EXAMPLE
(use-package erc
:custom
(erc-autojoin-channels-alist '(("freenode.net" "#archlinux" "#bash" "#bitcoin"
"#emacs" "#gentoo" "#i3" "#latex" "#org-mode" "#python")))
(erc-autojoin-timing 'ident)
(erc-fill-function 'erc-fill-static)
(erc-fill-static-center 22)
(erc-hide-list '("JOIN" "PART" "QUIT"))
(erc-lurker-hide-list '("JOIN" "PART" "QUIT"))
(erc-lurker-threshold-time 43200)
(erc-prompt-for-nickserv-password nil)
(erc-server-reconnect-attempts 5)
(erc-server-reconnect-timeout 3)
(erc-track-exclude-types '("JOIN" "MODE" "NICK" "PART" "QUIT"
"324" "329" "332" "333" "353" "477"))
:config
(add-to-list 'erc-modules 'notifications)
(add-to-list 'erc-modules 'spelling)
(erc-services-mode 1)
(erc-update-modules))
#+END_EXAMPLE

Roughly, this makes it possible to make a nice margin for the display, allow a connection using the password from my =authinfo.gpg= file, avoid warning me when a user joins and leaves a channel, enable notifications and the spell checking on the fly.
大致上，这使它成为可能，使一个良好的空白显示，允许连接使用密码从我的=authinfo。gpg=文件，避免在用户加入或离开通道时警告我，动态启用通知和拼写检查。

Besides, for people like me, who want to store your password in a GPG file, you just need to specify a file priority list, to tell =erc= where to start looking for your password first:
此外，对于像我这样的人，谁想把你的密码存储在一个GPG文件，你只需要指定一个文件优先级列表，告诉=erc=从哪里开始寻找你的密码:

#+BEGIN_EXAMPLE
(setq auth-sources '("~/Sync/shared/.authinfo.gpg"
"~/.authinfo.gpg"
"~/.authinfo"
"~/.netrc"))
#+END_EXAMPLE

and of course, don't forget to add this line in your =.authinfo.gpg= file, where <nickname> and <password> match your real information:
当然，不要忘记在=.authinfo中添加这一行。gpg=文件，其中<昵称>和<密码>匹配您的真实信息:

#+BEGIN_EXAMPLE
machine irc.freenode.net login <nickname> password <password>
#+END_EXAMPLE

*NOTE:* replace =auth-sources= with the one that suits you best.
*注意:*将=auth-sources=替换为最适合您的那个。

If you are still with me, I will list you some functions that I use, which allow to complete the configuration presented above.
如果您还和我在一起，我将列出一些我使用的函数，这些函数允许您完成上面的配置。

-- In order to avoid opening several =erc= instances, I use a function that will ensure that only one connection instance exists:
——为了避免打开多个=erc=实例，我使用了一个函数来确保只有一个连接实例存在:

#+BEGIN_EXAMPLE
(defun my/erc-start-or-switch ()
"Connects to ERC, or switch to last active buffer."
(interactive)
(if (get-buffer "irc.freenode.net:6667")
(erc-track-switch-buffer 1)
(when (y-or-n-p "Start ERC? ")
(erc :server "irc.freenode.net" :port 6667 :nick "rememberYou"))))
#+END_EXAMPLE

-- Another thing that I like, is to automatically receive a notification when I get a private message, or when my nickname is quoted on a channel so I can respond quickly. This notification includes as title the pseudonym of the person as well as his message as content:​​
——我喜欢的另一件事是，当我收到私人消息时，或者当我的昵称被引用到某个频道时，我会自动收到通知，这样我可以快速响应。此通知的标题包括该人的笔名及其信息内容:

#+BEGIN_EXAMPLE
(defun my/erc-notify (nickname message)
"Displays a notification message for ERC."
(let* ((channel (buffer-name))
(nick (erc-hl-nicks-trim-irc-nick nickname))
(title (if (string-match-p (concat "^" nickname) channel)
nick
(concat nick " (" channel ")")))
(msg (s-trim (s-collapse-whitespace message))))
(alert (concat nick ": " msg) :title title)))
#+END_EXAMPLE

-- One thing that bothered me about =erc= was that I liked to know how many people were on the channel so I could get an idea if I was going to get a quick answer or not. This is done with the following code:
——令我烦恼的一件事是，我想知道频道上有多少人，这样我就能知道我是否能得到一个快速的回答。这是通过以下代码完成的:

#+BEGIN_EXAMPLE
(defun my/erc-count-users ()
"Displays the number of users connected on the current channel."
(interactive)
(if (get-buffer "irc.freenode.net:6667")
(let ((channel (erc-default-target)))
(if (and channel (erc-channel-p channel))
(message "%d users are online on %s"
(hash-table-count erc-channel-users)
channel)
(user-error "The current buffer is not a channel")))
(user-error "You must first start ERC")))
#+END_EXAMPLE

-- From time to time I wanted to copy and paste a source on a channel, and get myself kicked for spam after sending this message several times in a short time. To avoid these problems, this function comes to your rescue:​
有时我想复制和粘贴一个来源的渠道，并得到自己踢的垃圾邮件后，发送这条消息几次在很短的时间。为了避免这些问题，这个功能来拯救你:

#+BEGIN_EXAMPLE
(defun my/erc-preprocess (string)
"Avoids channel flooding."
(setq str
(string-trim
(replace-regexp-in-string "n+" " " str))))
#+END_EXAMPLE

-- Two other packages I like to use. The first package is =erc-hl-nicks=, which allows me to associate a color with a pseudonym. I find it convenient because it gives me a first visual impression if a person answered. Finally, the second package is =erc-image=, which automatically displays images as links, on a channel. This allows me to avoid having to click on the link to see the image:
——另外两个我喜欢用的包裹。第一个包是=erc-hl-nicks=，它允许我将颜色与假名联系起来。我发现它很方便，因为如果有人回答，它会给我一个第一印象。最后，第二个包是=erc-image=，它在通道上自动将图像显示为链接。这使我可以避免点击链接查看图像:

#+BEGIN_EXAMPLE
(use-package erc-hl-nicks
:after erc)

(use-package erc-image
:after erc)
#+END_EXAMPLE

In order to not overload this post, you can find my complete configuration on [[https://github.com/rememberYou/.emacs.d][GitHub]].
为了不超载这篇文章，你可以找到我的完整配置在[[https://github.com/beryou/.emacs.d][GitHub]]。

Feel free to complete this post by sharing a few points of your configuration that you want to share, as well as various packages that you use.
您可以通过分享一些您想要分享的配置点，以及您使用的各种包来完成这篇文章。

See you soon on IRC! I wish you a good evening or a good day, Emacs friend!
IRC上再见!祝你有一个美好的夜晚或美好的一天，Emacs的朋友!
