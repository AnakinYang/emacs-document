#+TITLE: Peek definition with Emacs frame
#+URL: http://tuhdo.github.io/emacs-frame-peek.html
#+AUTHOR: lujun9972
#+TAGS: raw
#+DATE: [2018-02-05 一 15:28]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t n:nil ::t |:t ^:nil -:nil f:t *:t <:nil


In many IDEs, peek definition is a feature that opens a definition (of a function, a class, a symbol, etc) in a popup window without leaving the current buffer. Most of the time, jumping into a definition, then jump back, is enough, so why bother leaving the current buffer to reload a whole new buffer, then go back for another reload. This is distracting.
在许多ide中，peek定义是在弹出窗口中打开定义(函数、类、符号等)而不离开当前缓冲区的特性。大多数情况下，跳到一个定义，然后跳回来就足够了，所以为什么要离开当前缓冲区去重新加载一个全新的缓冲区，然后再回去重新加载呢?这是分心。

An example of peek definition:
peek定义的一个例子:

[[http://tuhdo.github.io/static/peek-definition-vs.png][peek-definition-vs.png]]
[[http://tuhdo.github.io/static/peek-definition-vs.png] [peek-definition-vs.png]]
(Source: Microsoft)
(来源:微软(Microsoft)。

I already searched for an alternative in Emacs, but apparently, all the solutions that involve a popup is slow and lacking. The space for displaying text is limited, and there is no font locking. You can't even search, or if it does, search is difficult and slow.
我已经在Emacs中寻找了一个替代方案，但显然，所有涉及弹出窗口的解决方案都很慢而且缺乏。显示文本的空间有限，而且没有字体锁定。你甚至不能搜索，或者如果搜索，搜索是困难和缓慢的。

Recently, while jumping around code definitions, I lost track of the original buffer I start the jump chain, e.g. I started at file1.c, then jumped to file2.c, file3.h, file4.c, and so on, until I forgot that I started at file1.c (file1.c can be a long and hard to remember name). It makes me want to do this whole code hopping process in another separated frame/buffer instead of messing with my current buffer. I tried improved the process:
最近，在跳转代码定义时，我丢失了开始跳转链的原始缓冲区的轨迹，例如从file1开始。c，然后跳转到file2。c, file3。h, file4。c，等等，直到我忘记我是从file1.c开始的(file1.c可能很长，很难记住它的名称)。这让我想在另一个独立的帧/缓冲区中执行整个代码跳跃过程，而不是打乱我当前的缓冲区。我尝试改进流程:

+ Using a different buffer: Initially, I create another buffer and start from there. However, it is usually the case that the other buffer is also a useful buffer.
+使用不同的缓冲区:最初，我创建另一个缓冲区，并从那里开始。然而，通常情况下，另一个缓冲区也是一个有用的缓冲区。
+ Using a different workspace: I am using [[https://github.com/wasamasa/eyebrowse][eyebrowse]], a package that can create a whole new workspace and save the previous window configuration as another workspace. Effectively, you can switch between different window configurations with ease. This solution quickly becomes cumbersome, because I must remember which workspace is for browsing code, not to mention it is quite common for me to create 5 other workspaces for other purposes. It quickly becomes a burden to manage the workspaces.
+使用不同的工作空间:我正在使用[[https://github.com/wasamasa/eyebrowse][eyebrowse]]，这个包可以创建一个全新的工作空间，并将之前的窗口配置保存为另一个工作空间。有效地，您可以轻松地在不同的窗口配置之间切换。这个解决方案很快就变得很麻烦，因为我必须记住哪个工作空间用于浏览代码，更不用说为其他目的创建5个其他工作空间了。它很快成为管理工作空间的负担。

It is at this point that I suddenly remember frames. That's right, Emacs frames! It is perfect for this use case. I can do whatever I want in this frame, and when done, simply close it with C-x 5 0. With frames, the number of my workspaces (using eyebrowse) is kept at a manageable number.
就在这时，我突然想起了框架。没错，Emacs帧!它非常适合这个用例。我可以在这个坐标系中做任何我想做的事，当完成时，只需用c - x50关闭它。使用框架，我的工作空间(使用eyebrowse)的数量保持在一个可管理的数量。

But wait, if an Emacs frame is small enough, isn't it the same as a popup window, but with every feature of a buffer (syntax highlighting, code jumping, etc) available? Not to mention, making a frame is much more lightweight than other popup solutions.
但是等等，如果Emacs帧足够小，它是不是和弹出窗口一样，但是有缓冲区的每个特性(语法高亮、代码跳跃等)可用?更不用说，制作一个框架比其他弹出式解决方案要轻得多。

At this point, implementing a peek definition in Emacs is simply automating these steps:
此时，在Emacs中实现peek定义就是简单地自动化这些步骤:

1 Find the absolute position of the current beginning of the symbol at point, in pixels.
求符号当前起始点的绝对位置，以像素为单位。
2 Create a new invisible frame, with the current buffer in it.
创建一个新的不可见的框架，其中包含当前缓冲区。
3 Position the new frame right under the beginning of the symbol at point.
将新帧定位在符号开始的正下方。
4 Jump to the symbol at point.
4跳转到符号点。
5 Make frame visible again.
5让帧再次可见。

That's all for a peek definition popup:
这就是一个peek定义的弹出窗口:

[[http://tuhdo.github.io/static/peek-definition-emacs.gif][peek-definition-emacs.gif]]
[[http://tuhdo.github.io/static/peek-definition-emacs.gif] [peek-definition-emacs.gif]]

In the example, I used rtags-find-symbol-at-point function for jumping. But you can use any
在本例中，我使用rtag -find-symbol-at-point函数进行跳转。但是你可以用任何一个
function that finds a definition, as long as it jumps to a buffer. Finally, here is the code:
函数查找定义，只要它跳转到缓冲区。最后，代码如下:

#+begin_example
# + begin_example
(defun rtags-peek-definition ()
(defun rtags-peek-definition ()
"Peek at definition at point using rtags."
使用rtags查看定义点。
(interactive)
(互动)
(let ((func (lambda ()
(函数)
(rtags-find-symbol-at-point)
(rtags-find-symbol-at-point)
(rtags-location-stack-forward))))
(rtags-location-stack-forward))))
(rtags-start-process-unless-running)
(rtags-start-process-unless-running)
(make-peek-frame func)))
(make-peek-frame func)))

(defun make-peek-frame (find-definition-function &rest args)
(defun make-peek-frame (find- define -function &rest args))
"Make a new frame for peeking definition"
“给偷看定义一个新框架”
(when (or (not (rtags-called-interactively-p)) (rtags-sandbox-id-matches))
(when (or (not (rtag -called- interactivly -p)) (rtag -sandbox-id-matches))
(let (summary
(让(总结
doc-frame
doc-frame
x y
x
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 1. Find the absolute position of the current beginning of the symbol at point, ;;
;;1. 求符号当前起始点的绝对位置，;;
;; in pixels.                                                                     ;;
;;以像素为单位。;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(abs-pixel-pos (save-excursion
(abs-pixel-pos (save-excursion
(beginning-of-thing 'symbol)
(beginning-of-thing的象征)
(window-absolute-pixel-position))))
(window-absolute-pixel-position))))
(setq x (car abs-pixel-pos))
(setq x (car abs-pixel-pos))
;; (setq y (cdr abs-pixel-pos))
;;(setq y (cdr abs-pixel-pos))
(setq y (+ (cdr abs-pixel-pos) (frame-char-height)))
(setq y (+ (cdr abs-pixel-pos) (frame-char-height)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 2. Create a new invisible frame, with the current buffer in it. ;;
;;2. 创建一个新的不可见的框架，其中包含当前缓冲区。;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(setq doc-frame (make-frame '((minibuffer . nil)
设置文档帧(make-frame))。nil)
(name . "*RTags Peek*")
(名字。“\* RTags Peek \*”)
(width . 80)
(宽度。80)
(visibility . nil)
(可见性。nil)
(height . 15))))
(高度。15))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 3. Position the new frame right under the beginning of the symbol at point. ;;
;;3.将新帧定位在符号起始点的正下方。;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(set-frame-position doc-frame x y)
(set-frame-position doc-frame x y)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 4. Jump to the symbol at point. ;;
;;4. 跳转到点上的符号。;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(with-selected-frame doc-frame
(with-selected-frame doc-frame
(apply find-definition-function args)
(应用find-definition-function args)
(read-only-mode)
(只读模式下运行)
(when semantic-stickyfunc-mode (semantic-stickyfunc-mode -1))
(当语义- stickyfuncm -mode(语义- stickyfuncm -mode -1))
(recenter-top-bottom 0))
(recenter-top-bottom 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 5. Make frame visible again ;;
;;5. 使帧再次可见;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(make-frame-visible doc-frame))))
(make-frame-visible doc-frame))))
#+end_example
# + end_example

Then, bind the new command to a key and try it out:
然后，将新命令绑定到一个键，并尝试:

#+BEGIN_SRC emacs-lisp
# + BEGIN_SRC emacs lisp
(global-set-key (kbd "C-c p") 'rtags-peek-definition)
(全球集键(kbd“C-c - p”)“rtags-peek-definition)
#+END_SRC
# + END_SRC

To close the peek frame, simply use C-x 5 0 (runs delete-frame command). You can bind it to another key to close frame easier, e.g. f12 key.
要关闭peek帧，只需使用C-x 5 0(运行删除帧命令)。你可以绑定到另一个关键关闭帧更容易，例如f12键。

The more I use Emacs, the more I start realizing how useful frames are. Especially with Emacs 26 onward, there is an option to remove a frame from OS taskbar, effectively you cannot use Alt+Tab to switch to any child frame created in Emacs. With this feature, you can create many Emacs frames without creating a mess that renders Alt+tab unusable. Perhaps it is the time to embrace the frames.
我使用Emacs越多，就越开始意识到帧是多么有用。特别是在Emacs 26之后，有一个选项可以从OS任务栏中删除一个框架，实际上你不能使用Alt+Tab切换到Emacs中创建的任何子框架。有了这个特性，您可以创建许多Emacs帧，而不会造成Alt+tab不可用的混乱。也许是时候接受这些框架了。
